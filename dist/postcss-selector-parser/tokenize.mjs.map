{
  "version": 3,
  "sources": ["../../src/postcss-selector-parser/tokenTypes.js", "../../src/postcss-selector-parser/tokenize.js"],
  "sourcesContent": ["export const ampersand        = 38; // `&`.charCodeAt(0);\nexport const asterisk         = 42; // `*`.charCodeAt(0);\nexport const at               = 64; // `@`.charCodeAt(0);\nexport const comma            = 44; // `,`.charCodeAt(0);\nexport const colon            = 58; // `:`.charCodeAt(0);\nexport const semicolon        = 59; // `;`.charCodeAt(0);\nexport const openParenthesis  = 40; // `(`.charCodeAt(0);\nexport const closeParenthesis = 41; // `)`.charCodeAt(0);\nexport const openSquare       = 91; // `[`.charCodeAt(0);\nexport const closeSquare      = 93; // `]`.charCodeAt(0);\nexport const dollar           = 36; // `$`.charCodeAt(0);\nexport const tilde            = 126; // `~`.charCodeAt(0);\nexport const caret            = 94; // `^`.charCodeAt(0);\nexport const plus             = 43; // `+`.charCodeAt(0);\nexport const equals           = 61; // `=`.charCodeAt(0);\nexport const pipe             = 124; // `|`.charCodeAt(0);\nexport const greaterThan      = 62; // `>`.charCodeAt(0);\nexport const space            = 32; // ` `.charCodeAt(0);\nexport const singleQuote      = 39; // `'`.charCodeAt(0);\nexport const doubleQuote      = 34; // `\"`.charCodeAt(0);\nexport const slash            = 47; // `/`.charCodeAt(0);\nexport const bang             = 33; // `!`.charCodeAt(0);\n\nexport const backslash        = 92; // '\\\\'.charCodeAt(0);\nexport const cr               = 13; // '\\r'.charCodeAt(0);\nexport const feed             = 12; // '\\f'.charCodeAt(0);\nexport const newline          = 10; // '\\n'.charCodeAt(0);\nexport const tab              = 9; // '\\t'.charCodeAt(0);\n\n// Expose aliases primarily for readability.\nexport const str              = singleQuote;\n\n// No good single character representation!\nexport const comment          = -1;\nexport const word             = -2;\nexport const combinator       = -3;\n", "import * as t from './tokenTypes';\n\nconst unescapable = {\n    [t.tab]: true,\n    [t.newline]: true,\n    [t.cr]: true,\n    [t.feed]: true,\n};\nconst wordDelimiters = {\n    [t.space]: true,\n    [t.tab]: true,\n    [t.newline]: true,\n    [t.cr]: true,\n    [t.feed]: true,\n\n    [t.ampersand]: true,\n    [t.asterisk]: true,\n    [t.bang]: true,\n    [t.comma]: true,\n    [t.colon]: true,\n    [t.semicolon]: true,\n    [t.openParenthesis]: true,\n    [t.closeParenthesis]: true,\n    [t.openSquare]: true,\n    [t.closeSquare]: true,\n    [t.singleQuote]: true,\n    [t.doubleQuote]: true,\n    [t.plus]: true,\n    [t.pipe]: true,\n    [t.tilde]: true,\n    [t.greaterThan]: true,\n    [t.equals]: true,\n    [t.dollar]: true,\n    [t.caret]: true,\n    [t.slash]: true,\n};\n\n\nconst hex = {};\nconst hexChars = \"0123456789abcdefABCDEF\";\nfor (let i = 0; i < hexChars.length; i++) {\n    hex[hexChars.charCodeAt(i)] = true;\n}\n\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\nfunction consumeWord (css, start) {\n    let next = start;\n    let code;\n    do {\n        code = css.charCodeAt(next);\n        if (wordDelimiters[code]) {\n            return next - 1;\n        } else if (code === t.backslash) {\n            next = consumeEscape(css, next) + 1;\n        } else {\n            // All other characters are part of the word\n            next++;\n        }\n    } while (next < css.length);\n    return next - 1;\n}\n\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\nfunction consumeEscape (css, start) {\n    let next = start;\n    let code = css.charCodeAt(next + 1);\n    if (unescapable[code]) {\n        // just consume the escape char\n    } else if (hex[code]) {\n        let hexDigits = 0;\n        // consume up to 6 hex chars\n        do {\n            next++;\n            hexDigits++;\n            code = css.charCodeAt(next + 1);\n        } while (hex[code] && hexDigits < 6);\n        // if fewer than 6 hex chars, a trailing space ends the escape\n        if (hexDigits < 6 && code === t.space) {\n            next++;\n        }\n    } else {\n        // the next char is part of the current word\n        next++;\n    }\n    return next;\n}\n\nexport const FIELDS = {\n    TYPE: 0,\n    START_LINE: 1,\n    START_COL: 2,\n    END_LINE: 3,\n    END_COL: 4,\n    START_POS: 5,\n    END_POS: 6,\n};\n\nexport default function tokenize (input) {\n    const tokens   = [];\n    let css        = input.css.valueOf();\n    let {length}   = css;\n    let offset     = -1;\n    let line       =  1;\n    let start      =  0;\n    let end        =  0;\n\n    let code,\n        content,\n        endColumn,\n        endLine,\n        escaped,\n        escapePos,\n        last,\n        lines,\n        next,\n        nextLine,\n        nextOffset,\n        quote,\n        tokenType;\n\n    function unclosed (what, fix) {\n        if ( input.safe ) { // fyi: this is never set to true.\n            css += fix;\n            next = css.length - 1;\n        } else {\n            throw input.error('Unclosed ' + what, line, start - offset, start);\n        }\n    }\n\n    while ( start < length ) {\n        code = css.charCodeAt(start);\n\n        if ( code === t.newline ) {\n            offset = start;\n            line  += 1;\n        }\n\n        switch ( code ) {\n        case t.space:\n        case t.tab:\n        case t.newline:\n        case t.cr:\n        case t.feed:\n            next = start;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n                if ( code === t.newline ) {\n                    offset = next;\n                    line  += 1;\n                }\n            } while (\n                code === t.space   ||\n                code === t.newline ||\n                code === t.tab     ||\n                code === t.cr      ||\n                code === t.feed\n            );\n\n            tokenType = t.space;\n            endLine = line;\n            endColumn = next - offset - 1;\n            end = next;\n            break;\n\n        case t.plus:\n        case t.greaterThan:\n        case t.tilde:\n        case t.pipe:\n            next = start;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n            } while (\n                code === t.plus        ||\n                code === t.greaterThan ||\n                code === t.tilde       ||\n                code === t.pipe\n            );\n\n            tokenType = t.combinator;\n            endLine = line;\n            endColumn = start - offset;\n            end = next;\n            break;\n\n        // Consume these characters as single tokens.\n        case t.asterisk:\n        case t.ampersand:\n        case t.bang:\n        case t.comma:\n        case t.equals:\n        case t.dollar:\n        case t.caret:\n        case t.openSquare:\n        case t.closeSquare:\n        case t.colon:\n        case t.semicolon:\n        case t.openParenthesis:\n        case t.closeParenthesis:\n            next = start;\n            tokenType = code;\n            endLine = line;\n            endColumn = start - offset;\n            end = next + 1;\n            break;\n\n        case t.singleQuote:\n        case t.doubleQuote:\n            quote = code === t.singleQuote ? \"'\" : '\"';\n            next  = start;\n            do {\n                escaped = false;\n                next    = css.indexOf(quote, next + 1);\n                if ( next === -1 ) {\n                    unclosed('quote', quote);\n                }\n                escapePos = next;\n                while ( css.charCodeAt(escapePos - 1) === t.backslash ) {\n                    escapePos -= 1;\n                    escaped = !escaped;\n                }\n            } while ( escaped );\n\n            tokenType = t.str;\n            endLine = line;\n            endColumn = start - offset;\n            end = next + 1;\n            break;\n\n        default:\n            if ( code === t.slash && css.charCodeAt(start + 1) === t.asterisk ) {\n                next = css.indexOf('*/', start + 2) + 1;\n                if ( next === 0 ) {\n                    unclosed('comment', '*/');\n                }\n\n                content = css.slice(start, next + 1);\n                lines   = content.split('\\n');\n                last    = lines.length - 1;\n\n                if ( last > 0 ) {\n                    nextLine   = line + last;\n                    nextOffset = next - lines[last].length;\n                } else {\n                    nextLine   = line;\n                    nextOffset = offset;\n                }\n\n                tokenType = t.comment;\n                line   = nextLine;\n                endLine = nextLine;\n                endColumn = next - nextOffset;\n            } else if (code === t.slash) {\n                next = start;\n                tokenType = code;\n                endLine = line;\n                endColumn = start - offset;\n                end = next + 1;\n            } else {\n                next = consumeWord(css, start);\n                tokenType = t.word;\n                endLine = line;\n                endColumn = next - offset;\n            }\n\n            end = next + 1;\n            break;\n        }\n\n        // Ensure that the token structure remains consistent\n        tokens.push([\n            tokenType,              // [0] Token type\n            line,                   // [1] Starting line\n            start - offset,         // [2] Starting column\n            endLine,                // [3] Ending line\n            endColumn,              // [4] Ending column\n            start,                  // [5] Start position / Source index\n            end,                    // [6] End position\n        ]);\n\n        // Reset offset for the next token\n        if (nextOffset) {\n            offset = nextOffset;\n            nextOffset = null;\n        }\n\n        start = end;\n    }\n\n    return tokens;\n}\n"],
  "mappings": "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",
  "names": []
}
