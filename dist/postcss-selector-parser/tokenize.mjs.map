{
  "version": 3,
  "sources": ["../../src/postcss-selector-parser/tokenTypes.js", "../../src/postcss-selector-parser/tokenize.js"],
  "sourcesContent": ["export const ampersand = 38; // `&`.charCodeAt(0);\r\nexport const asterisk = 42; // `*`.charCodeAt(0);\r\nexport const at = 64; // `@`.charCodeAt(0);\r\nexport const comma = 44; // `,`.charCodeAt(0);\r\nexport const colon = 58; // `:`.charCodeAt(0);\r\nexport const semicolon = 59; // `;`.charCodeAt(0);\r\nexport const openParenthesis = 40; // `(`.charCodeAt(0);\r\nexport const closeParenthesis = 41; // `)`.charCodeAt(0);\r\nexport const openSquare = 91; // `[`.charCodeAt(0);\r\nexport const closeSquare = 93; // `]`.charCodeAt(0);\r\nexport const dollar = 36; // `$`.charCodeAt(0);\r\nexport const tilde = 126; // `~`.charCodeAt(0);\r\nexport const caret = 94; // `^`.charCodeAt(0);\r\nexport const plus = 43; // `+`.charCodeAt(0);\r\nexport const equals = 61; // `=`.charCodeAt(0);\r\nexport const pipe = 124; // `|`.charCodeAt(0);\r\nexport const greaterThan = 62; // `>`.charCodeAt(0);\r\nexport const space = 32; // ` `.charCodeAt(0);\r\nexport const singleQuote = 39; // `'`.charCodeAt(0);\r\nexport const doubleQuote = 34; // `\"`.charCodeAt(0);\r\nexport const slash = 47; // `/`.charCodeAt(0);\r\nexport const bang = 33; // `!`.charCodeAt(0);\r\nexport const backslash = 92; // '\\\\'.charCodeAt(0);\r\nexport const cr = 13; // '\\r'.charCodeAt(0);\r\nexport const feed = 12; // '\\f'.charCodeAt(0);\r\nexport const newline = 10; // '\\n'.charCodeAt(0);\r\nexport const tab = 9; // '\\t'.charCodeAt(0);\r\n// Expose aliases primarily for readability.\r\nexport const str = singleQuote;\r\n// No good single character representation!\r\nexport const comment = -1;\r\nexport const word = -2;\r\nexport const combinator = -3;\r\n", "import * as t from './tokenTypes';\r\nconst unescapable = {\r\n    [t.tab]: true,\r\n    [t.newline]: true,\r\n    [t.cr]: true,\r\n    [t.feed]: true,\r\n};\r\nconst wordDelimiters = {\r\n    [t.space]: true,\r\n    [t.tab]: true,\r\n    [t.newline]: true,\r\n    [t.cr]: true,\r\n    [t.feed]: true,\r\n    [t.ampersand]: true,\r\n    [t.asterisk]: true,\r\n    [t.bang]: true,\r\n    [t.comma]: true,\r\n    [t.colon]: true,\r\n    [t.semicolon]: true,\r\n    [t.openParenthesis]: true,\r\n    [t.closeParenthesis]: true,\r\n    [t.openSquare]: true,\r\n    [t.closeSquare]: true,\r\n    [t.singleQuote]: true,\r\n    [t.doubleQuote]: true,\r\n    [t.plus]: true,\r\n    [t.pipe]: true,\r\n    [t.tilde]: true,\r\n    [t.greaterThan]: true,\r\n    [t.equals]: true,\r\n    [t.dollar]: true,\r\n    [t.caret]: true,\r\n    [t.slash]: true,\r\n};\r\nconst hex = {};\r\nconst hexChars = \"0123456789abcdefABCDEF\";\r\nfor (let i = 0; i < hexChars.length; i++) {\r\n    hex[hexChars.charCodeAt(i)] = true;\r\n}\r\n/**\r\n *  Returns the last index of the bar css word\r\n * @param {string} css The string in which the word begins\r\n * @param {number} start The index into the string where word's first letter occurs\r\n */\r\nfunction consumeWord(css, start) {\r\n    let next = start;\r\n    let code;\r\n    do {\r\n        code = css.charCodeAt(next);\r\n        if (wordDelimiters[code]) {\r\n            return next - 1;\r\n        }\r\n        else if (code === t.backslash) {\r\n            next = consumeEscape(css, next) + 1;\r\n        }\r\n        else {\r\n            // All other characters are part of the word\r\n            next++;\r\n        }\r\n    } while (next < css.length);\r\n    return next - 1;\r\n}\r\n/**\r\n *  Returns the last index of the escape sequence\r\n * @param {string} css The string in which the sequence begins\r\n * @param {number} start The index into the string where escape character (`\\`) occurs.\r\n */\r\nfunction consumeEscape(css, start) {\r\n    let next = start;\r\n    let code = css.charCodeAt(next + 1);\r\n    if (unescapable[code]) {\r\n        // just consume the escape char\r\n    }\r\n    else if (hex[code]) {\r\n        let hexDigits = 0;\r\n        // consume up to 6 hex chars\r\n        do {\r\n            next++;\r\n            hexDigits++;\r\n            code = css.charCodeAt(next + 1);\r\n        } while (hex[code] && hexDigits < 6);\r\n        // if fewer than 6 hex chars, a trailing space ends the escape\r\n        if (hexDigits < 6 && code === t.space) {\r\n            next++;\r\n        }\r\n    }\r\n    else {\r\n        // the next char is part of the current word\r\n        next++;\r\n    }\r\n    return next;\r\n}\r\nexport const FIELDS = {\r\n    TYPE: 0,\r\n    START_LINE: 1,\r\n    START_COL: 2,\r\n    END_LINE: 3,\r\n    END_COL: 4,\r\n    START_POS: 5,\r\n    END_POS: 6,\r\n};\r\nexport default function tokenize(input) {\r\n    const tokens = [];\r\n    let css = input.css.valueOf();\r\n    let { length } = css;\r\n    let offset = -1;\r\n    let line = 1;\r\n    let start = 0;\r\n    let end = 0;\r\n    let code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\r\n    function unclosed(what, fix) {\r\n        if (input.safe) { // fyi: this is never set to true.\r\n            css += fix;\r\n            next = css.length - 1;\r\n        }\r\n        else {\r\n            throw input.error('Unclosed ' + what, line, start - offset, start);\r\n        }\r\n    }\r\n    while (start < length) {\r\n        code = css.charCodeAt(start);\r\n        if (code === t.newline) {\r\n            offset = start;\r\n            line += 1;\r\n        }\r\n        switch (code) {\r\n            case t.space:\r\n            case t.tab:\r\n            case t.newline:\r\n            case t.cr:\r\n            case t.feed:\r\n                next = start;\r\n                do {\r\n                    next += 1;\r\n                    code = css.charCodeAt(next);\r\n                    if (code === t.newline) {\r\n                        offset = next;\r\n                        line += 1;\r\n                    }\r\n                } while (code === t.space ||\r\n                    code === t.newline ||\r\n                    code === t.tab ||\r\n                    code === t.cr ||\r\n                    code === t.feed);\r\n                tokenType = t.space;\r\n                endLine = line;\r\n                endColumn = next - offset - 1;\r\n                end = next;\r\n                break;\r\n            case t.plus:\r\n            case t.greaterThan:\r\n            case t.tilde:\r\n            case t.pipe:\r\n                next = start;\r\n                do {\r\n                    next += 1;\r\n                    code = css.charCodeAt(next);\r\n                } while (code === t.plus ||\r\n                    code === t.greaterThan ||\r\n                    code === t.tilde ||\r\n                    code === t.pipe);\r\n                tokenType = t.combinator;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next;\r\n                break;\r\n            // Consume these characters as single tokens.\r\n            case t.asterisk:\r\n            case t.ampersand:\r\n            case t.bang:\r\n            case t.comma:\r\n            case t.equals:\r\n            case t.dollar:\r\n            case t.caret:\r\n            case t.openSquare:\r\n            case t.closeSquare:\r\n            case t.colon:\r\n            case t.semicolon:\r\n            case t.openParenthesis:\r\n            case t.closeParenthesis:\r\n                next = start;\r\n                tokenType = code;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next + 1;\r\n                break;\r\n            case t.singleQuote:\r\n            case t.doubleQuote:\r\n                quote = code === t.singleQuote ? \"'\" : '\"';\r\n                next = start;\r\n                do {\r\n                    escaped = false;\r\n                    next = css.indexOf(quote, next + 1);\r\n                    if (next === -1) {\r\n                        unclosed('quote', quote);\r\n                    }\r\n                    escapePos = next;\r\n                    while (css.charCodeAt(escapePos - 1) === t.backslash) {\r\n                        escapePos -= 1;\r\n                        escaped = !escaped;\r\n                    }\r\n                } while (escaped);\r\n                tokenType = t.str;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next + 1;\r\n                break;\r\n            default:\r\n                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\r\n                    next = css.indexOf('*/', start + 2) + 1;\r\n                    if (next === 0) {\r\n                        unclosed('comment', '*/');\r\n                    }\r\n                    content = css.slice(start, next + 1);\r\n                    lines = content.split('\\n');\r\n                    last = lines.length - 1;\r\n                    if (last > 0) {\r\n                        nextLine = line + last;\r\n                        nextOffset = next - lines[last].length;\r\n                    }\r\n                    else {\r\n                        nextLine = line;\r\n                        nextOffset = offset;\r\n                    }\r\n                    tokenType = t.comment;\r\n                    line = nextLine;\r\n                    endLine = nextLine;\r\n                    endColumn = next - nextOffset;\r\n                }\r\n                else if (code === t.slash) {\r\n                    next = start;\r\n                    tokenType = code;\r\n                    endLine = line;\r\n                    endColumn = start - offset;\r\n                    end = next + 1;\r\n                }\r\n                else {\r\n                    next = consumeWord(css, start);\r\n                    tokenType = t.word;\r\n                    endLine = line;\r\n                    endColumn = next - offset;\r\n                }\r\n                end = next + 1;\r\n                break;\r\n        }\r\n        // Ensure that the token structure remains consistent\r\n        tokens.push([\r\n            tokenType, // [0] Token type\r\n            line, // [1] Starting line\r\n            start - offset, // [2] Starting column\r\n            endLine, // [3] Ending line\r\n            endColumn, // [4] Ending column\r\n            start, // [5] Start position / Source index\r\n            end, // [6] End position\r\n        ]);\r\n        // Reset offset for the next token\r\n        if (nextOffset) {\r\n            offset = nextOffset;\r\n            nextOffset = null;\r\n        }\r\n        start = end;\r\n    }\r\n    return tokens;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
