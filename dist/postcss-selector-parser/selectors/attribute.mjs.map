{
  "version": 3,
  "sources": ["../../../src/cssesc/index.js", "../../../src/postcss-selector-parser/util/unesc.js", "../../../src/postcss-selector-parser/util/ensureObject.js", "../../../src/postcss-selector-parser/selectors/node.js", "../../../src/postcss-selector-parser/selectors/namespace.js", "../../../src/postcss-selector-parser/selectors/types.js", "../../../src/postcss-selector-parser/selectors/attribute.js"],
  "sourcesContent": ["var object = {};\r\nvar hasOwnProperty = object.hasOwnProperty;\r\nvar merge = function merge(options, defaults) {\r\n    if (!options) {\r\n        return defaults;\r\n    }\r\n    var result = {};\r\n    for (var key in defaults) {\r\n        // `if (defaults.hasOwnProperty(key) { \u2026 }` is not needed here, since\r\n        // only recognized option names are used.\r\n        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\r\n    }\r\n    return result;\r\n};\r\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\r\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\r\nvar regexAlwaysEscape = /['\"\\\\]/;\r\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\r\n// https://mathiasbynens.be/notes/css-escapes#css\r\nvar cssesc = function cssesc(string, options) {\r\n    options = merge(options, cssesc.options);\r\n    if (options.quotes != 'single' && options.quotes != 'double') {\r\n        options.quotes = 'single';\r\n    }\r\n    var quote = options.quotes == 'double' ? '\"' : '\\'';\r\n    var isIdentifier = options.isIdentifier;\r\n    var firstChar = string.charAt(0);\r\n    var output = '';\r\n    var counter = 0;\r\n    var length = string.length;\r\n    while (counter < length) {\r\n        var character = string.charAt(counter++);\r\n        var codePoint = character.charCodeAt();\r\n        var value = void 0;\r\n        // If it\u2019s not a printable ASCII character\u2026\r\n        if (codePoint < 0x20 || codePoint > 0x7E) {\r\n            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\r\n                // It\u2019s a high surrogate, and there is a next character.\r\n                var extra = string.charCodeAt(counter++);\r\n                if ((extra & 0xFC00) == 0xDC00) {\r\n                    // next character is low surrogate\r\n                    codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\r\n                }\r\n                else {\r\n                    // It\u2019s an unmatched surrogate; only append this code unit, in case\r\n                    // the next code unit is the high surrogate of a surrogate pair.\r\n                    counter--;\r\n                }\r\n            }\r\n            value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n        }\r\n        else {\r\n            if (options.escapeEverything) {\r\n                if (regexAnySingleEscape.test(character)) {\r\n                    value = '\\\\' + character;\r\n                }\r\n                else {\r\n                    value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n                }\r\n            }\r\n            else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\r\n                value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n            }\r\n            else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\r\n                value = '\\\\' + character;\r\n            }\r\n            else {\r\n                value = character;\r\n            }\r\n        }\r\n        output += value;\r\n    }\r\n    if (isIdentifier) {\r\n        if (/^-[-\\d]/.test(output)) {\r\n            output = '\\\\-' + output.slice(1);\r\n        }\r\n        else if (/\\d/.test(firstChar)) {\r\n            output = '\\\\3' + firstChar + ' ' + output.slice(1);\r\n        }\r\n    }\r\n    // Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\r\n    // since they\u2019re redundant. Note that this is only possible if the escape\r\n    // sequence isn\u2019t preceded by an odd number of backslashes.\r\n    output = output.replace(regexExcessiveSpaces, ($0, $1, $2) => {\r\n        if ($1 && $1.length % 2) {\r\n            // It\u2019s not safe to remove the space, so don\u2019t.\r\n            return $0;\r\n        }\r\n        // Strip the space.\r\n        return ($1 || '') + $2;\r\n    });\r\n    if (!isIdentifier && options.wrap) {\r\n        return quote + output + quote;\r\n    }\r\n    return output;\r\n};\r\n// Expose default options (so they can be overridden globally).\r\ncssesc.options = {\r\n    'escapeEverything': false,\r\n    'isIdentifier': false,\r\n    'quotes': 'single',\r\n    'wrap': false\r\n};\r\ncssesc.version = '3.0.0';\r\nexport default cssesc;\r\n", "// Many thanks for this post which made this migration much easier.\r\n// https://mathiasbynens.be/notes/css-escapes\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {[string, number]|undefined}\r\n */\r\nfunction gobbleHex(str) {\r\n    const lower = str.toLowerCase();\r\n    let hex = '';\r\n    let spaceTerminated = false;\r\n    for (let i = 0; i < 6 && lower[i] !== undefined; i++) {\r\n        const code = lower.charCodeAt(i);\r\n        // check to see if we are dealing with a valid hex char [a-f|0-9]\r\n        const valid = (code >= 97 && code <= 102) || (code >= 48 && code <= 57);\r\n        // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\r\n        spaceTerminated = code === 32;\r\n        if (!valid) {\r\n            break;\r\n        }\r\n        hex += lower[i];\r\n    }\r\n    if (hex.length === 0) {\r\n        return undefined;\r\n    }\r\n    const codePoint = parseInt(hex, 16);\r\n    const isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;\r\n    // Add special case for\r\n    // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\r\n    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\r\n    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\r\n        return ['\\uFFFD', hex.length + (spaceTerminated ? 1 : 0)];\r\n    }\r\n    return [\r\n        String.fromCodePoint(codePoint),\r\n        hex.length + (spaceTerminated ? 1 : 0),\r\n    ];\r\n}\r\nconst CONTAINS_ESCAPE = /\\\\/;\r\nexport default function unesc(str) {\r\n    let needToProcess = CONTAINS_ESCAPE.test(str);\r\n    if (!needToProcess) {\r\n        return str;\r\n    }\r\n    let ret = \"\";\r\n    for (let i = 0; i < str.length; i++) {\r\n        if ((str[i] === \"\\\\\")) {\r\n            const gobbled = gobbleHex(str.slice(i + 1, i + 7));\r\n            if (gobbled !== undefined) {\r\n                ret += gobbled[0];\r\n                i += gobbled[1];\r\n                continue;\r\n            }\r\n            // Retain a pair of \\\\ if double escaped `\\\\\\\\`\r\n            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\r\n            if (str[i + 1] === \"\\\\\") {\r\n                ret += \"\\\\\";\r\n                i++;\r\n                continue;\r\n            }\r\n            // if \\\\ is at the end of the string retain it\r\n            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\r\n            if (str.length === i + 1) {\r\n                ret += str[i];\r\n            }\r\n            continue;\r\n        }\r\n        ret += str[i];\r\n    }\r\n    return ret;\r\n}\r\n", "export default function ensureObject(obj, ...props) {\r\n    while (props.length > 0) {\r\n        const prop = props.shift();\r\n        if (!obj[prop]) {\r\n            obj[prop] = {};\r\n        }\r\n        obj = obj[prop];\r\n    }\r\n}\r\n", "import { ensureObject } from \"../util\";\r\nlet cloneNode = function (obj, parent) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n    let cloned = new obj.constructor();\r\n    for (let i in obj) {\r\n        if (!obj.hasOwnProperty(i)) {\r\n            continue;\r\n        }\r\n        let value = obj[i];\r\n        let type = typeof value;\r\n        if (i === 'parent' && type === 'object') {\r\n            if (parent) {\r\n                cloned[i] = parent;\r\n            }\r\n        }\r\n        else if (value instanceof Array) {\r\n            cloned[i] = value.map(j => cloneNode(j, cloned));\r\n        }\r\n        else {\r\n            cloned[i] = cloneNode(value, cloned);\r\n        }\r\n    }\r\n    return cloned;\r\n};\r\nexport default class Node {\r\n    constructor(opts = {}) {\r\n        Object.assign(this, opts);\r\n        this.spaces = this.spaces || {};\r\n        this.spaces.before = this.spaces.before || '';\r\n        this.spaces.after = this.spaces.after || '';\r\n    }\r\n    remove() {\r\n        if (this.parent) {\r\n            this.parent.removeChild(this);\r\n        }\r\n        this.parent = undefined;\r\n        return this;\r\n    }\r\n    replaceWith() {\r\n        if (this.parent) {\r\n            for (let index in arguments) {\r\n                this.parent.insertBefore(this, arguments[index]);\r\n            }\r\n            this.remove();\r\n        }\r\n        return this;\r\n    }\r\n    next() {\r\n        return this.parent.at(this.parent.index(this) + 1);\r\n    }\r\n    prev() {\r\n        return this.parent.at(this.parent.index(this) - 1);\r\n    }\r\n    clone(overrides = {}) {\r\n        let cloned = cloneNode(this);\r\n        for (let name in overrides) {\r\n            cloned[name] = overrides[name];\r\n        }\r\n        return cloned;\r\n    }\r\n    /**\r\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\r\n     * This allows non standard syntax to be appended to an existing property\r\n     * by specifying the escaped value. By specifying the escaped value,\r\n     * illegal characters are allowed to be directly inserted into css output.\r\n     * @param {string} name the property to set\r\n     * @param {any} value the unescaped value of the property\r\n     * @param {string} valueEscaped optional. the escaped value of the property.\r\n     */\r\n    appendToPropertyAndEscape(name, value, valueEscaped) {\r\n        if (!this.raws) {\r\n            this.raws = {};\r\n        }\r\n        let originalValue = this[name];\r\n        let originalEscaped = this.raws[name];\r\n        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        if (originalEscaped || valueEscaped !== value) {\r\n            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\r\n        }\r\n        else {\r\n            delete this.raws[name]; // delete any escaped value that was created by the setter.\r\n        }\r\n    }\r\n    /**\r\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\r\n     * This allows the escaped value to be specified directly, allowing illegal\r\n     * characters to be directly inserted into css output.\r\n     * @param {string} name the property to set\r\n     * @param {any} value the unescaped value of the property\r\n     * @param {string} valueEscaped the escaped value of the property.\r\n     */\r\n    setPropertyAndEscape(name, value, valueEscaped) {\r\n        if (!this.raws) {\r\n            this.raws = {};\r\n        }\r\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        this.raws[name] = valueEscaped;\r\n    }\r\n    /**\r\n     * When you want a value to passed through to CSS directly. This method\r\n     * deletes the corresponding raw value causing the stringifier to fallback\r\n     * to the unescaped value.\r\n     * @param {string} name the property to set.\r\n     * @param {any} value The value that is both escaped and unescaped.\r\n     */\r\n    setPropertyWithoutEscape(name, value) {\r\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        if (this.raws) {\r\n            delete this.raws[name];\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @param {number} line The number (starting with 1)\r\n     * @param {number} column The column number (starting with 1)\r\n     */\r\n    isAtPosition(line, column) {\r\n        if (this.source && this.source.start && this.source.end) {\r\n            if (this.source.start.line > line) {\r\n                return false;\r\n            }\r\n            if (this.source.end.line < line) {\r\n                return false;\r\n            }\r\n            if (this.source.start.line === line && this.source.start.column > column) {\r\n                return false;\r\n            }\r\n            if (this.source.end.line === line && this.source.end.column < column) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return undefined;\r\n    }\r\n    stringifyProperty(name) {\r\n        return (this.raws && this.raws[name]) || this[name];\r\n    }\r\n    get rawSpaceBefore() {\r\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\r\n        if (rawSpace === undefined) {\r\n            rawSpace = this.spaces && this.spaces.before;\r\n        }\r\n        return rawSpace || \"\";\r\n    }\r\n    set rawSpaceBefore(raw) {\r\n        ensureObject(this, \"raws\", \"spaces\");\r\n        this.raws.spaces.before = raw;\r\n    }\r\n    get rawSpaceAfter() {\r\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\r\n        if (rawSpace === undefined) {\r\n            rawSpace = this.spaces.after;\r\n        }\r\n        return rawSpace || \"\";\r\n    }\r\n    set rawSpaceAfter(raw) {\r\n        ensureObject(this, \"raws\", \"spaces\");\r\n        this.raws.spaces.after = raw;\r\n    }\r\n    valueToString() {\r\n        return String(this.stringifyProperty(\"value\"));\r\n    }\r\n    toString() {\r\n        return [\r\n            this.rawSpaceBefore,\r\n            this.valueToString(),\r\n            this.rawSpaceAfter,\r\n        ].join('');\r\n    }\r\n}\r\n", "import cssesc from \"../../cssesc\";\r\nimport { ensureObject } from '../util';\r\nimport Node from './node';\r\nexport default class Namespace extends Node {\r\n    get namespace() {\r\n        return this._namespace;\r\n    }\r\n    set namespace(namespace) {\r\n        if (namespace === true || namespace === \"*\" || namespace === \"&\") {\r\n            this._namespace = namespace;\r\n            if (this.raws) {\r\n                delete this.raws.namespace;\r\n            }\r\n            return;\r\n        }\r\n        const escaped = cssesc(namespace, { isIdentifier: true });\r\n        this._namespace = namespace;\r\n        if (escaped !== namespace) {\r\n            ensureObject(this, \"raws\");\r\n            this.raws.namespace = escaped;\r\n        }\r\n        else if (this.raws) {\r\n            delete this.raws.namespace;\r\n        }\r\n    }\r\n    get ns() {\r\n        return this._namespace;\r\n    }\r\n    set ns(namespace) {\r\n        this.namespace = namespace;\r\n    }\r\n    get namespaceString() {\r\n        if (this.namespace) {\r\n            const ns = this.stringifyProperty(\"namespace\");\r\n            if (ns === true) {\r\n                return '';\r\n            }\r\n            else {\r\n                return ns;\r\n            }\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    qualifiedName(value) {\r\n        if (this.namespace) {\r\n            return `${this.namespaceString}|${value}`;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n    valueToString() {\r\n        return this.qualifiedName(super.valueToString());\r\n    }\r\n}\r\n;\r\n", "export const TAG = 'tag';\r\nexport const STRING = 'string';\r\nexport const SELECTOR = 'selector';\r\nexport const ROOT = 'root';\r\nexport const PSEUDO = 'pseudo';\r\nexport const NESTING = 'nesting';\r\nexport const ID = 'id';\r\nexport const COMMENT = 'comment';\r\nexport const COMBINATOR = 'combinator';\r\nexport const CLASS = 'class';\r\nexport const ATTRIBUTE = 'attribute';\r\nexport const UNIVERSAL = 'universal';\r\n", "import cssesc from \"../../cssesc\";\r\nimport unesc from \"../util/unesc\";\r\nimport Namespace from './namespace';\r\nimport { ATTRIBUTE } from './types';\r\nconst WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\r\nexport function unescapeValue(value) {\r\n    let deprecatedUsage = false;\r\n    let quoteMark = null;\r\n    let unescaped = value;\r\n    const m = unescaped.match(WRAPPED_IN_QUOTES);\r\n    if (m) {\r\n        quoteMark = m[1];\r\n        unescaped = m[2];\r\n    }\r\n    unescaped = unesc(unescaped);\r\n    if (unescaped !== value) {\r\n        deprecatedUsage = true;\r\n    }\r\n    return {\r\n        deprecatedUsage,\r\n        unescaped,\r\n        quoteMark,\r\n    };\r\n}\r\nfunction handleDeprecatedContructorOpts(opts) {\r\n    if (opts.quoteMark !== undefined) {\r\n        return opts;\r\n    }\r\n    if (opts.value === undefined) {\r\n        return opts;\r\n    }\r\n    warnOfDeprecatedConstructor();\r\n    const { quoteMark, unescaped } = unescapeValue(opts.value);\r\n    if (!opts.raws) {\r\n        opts.raws = {};\r\n    }\r\n    if (opts.raws.value === undefined) {\r\n        opts.raws.value = opts.value;\r\n    }\r\n    opts.value = unescaped;\r\n    opts.quoteMark = quoteMark;\r\n    return opts;\r\n}\r\nexport default class Attribute extends Namespace {\r\n    static NO_QUOTE = null;\r\n    static SINGLE_QUOTE = \"'\";\r\n    static DOUBLE_QUOTE = '\"';\r\n    constructor(opts = {}) {\r\n        super(handleDeprecatedContructorOpts(opts));\r\n        this.type = ATTRIBUTE;\r\n        this.raws = this.raws || {};\r\n        this._constructed = true;\r\n    }\r\n    /**\r\n     * Returns the Attribute's value quoted such that it would be legal to use\r\n     * in the value of a css file. The original value's quotation setting\r\n     * used for stringification is left unchanged. See `setValue(value, options)`\r\n     * if you want to control the quote settings of a new value for the attribute.\r\n     *\r\n     * You can also change the quotation used for the current value by setting quoteMark.\r\n     *\r\n     * Options:\r\n     *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\r\n     *     option is not set, the original value for quoteMark will be used. If\r\n     *     indeterminate, a double quote is used. The legal values are:\r\n     *     * `null` - the value will be unquoted and characters will be escaped as necessary.\r\n     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\r\n     *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\r\n     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\r\n     *     over the quoteMark option value.\r\n     *   * smart {boolean} - if true, will select a quote mark based on the value\r\n     *     and the other options specified here. See the `smartQuoteMark()`\r\n     *     method.\r\n     **/\r\n    getQuotedValue(options = {}) {\r\n        const quoteMark = this._determineQuoteMark(options);\r\n        const cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\r\n        const escaped = cssesc(this._value, cssescopts);\r\n        return escaped;\r\n    }\r\n    _determineQuoteMark(options) {\r\n        return (options.smart) ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\r\n    }\r\n    /**\r\n     * Set the unescaped value with the specified quotation options. The value\r\n     * provided must not include any wrapping quote marks -- those quotes will\r\n     * be interpreted as part of the value and escaped accordingly.\r\n     */\r\n    setValue(value, options = {}) {\r\n        this._value = value;\r\n        this._quoteMark = this._determineQuoteMark(options);\r\n        this._syncRawValue();\r\n    }\r\n    /**\r\n     * Intelligently select a quoteMark value based on the value's contents. If\r\n     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\r\n     * mark will be picked that minimizes the number of escapes.\r\n     *\r\n     * If there's no clear winner, the quote mark from these options is used,\r\n     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\r\n     * true). If the quoteMark is unspecified, a double quote is used.\r\n     *\r\n     * @param options This takes the quoteMark and preferCurrentQuoteMark options\r\n     * from the quoteValue method.\r\n     */\r\n    smartQuoteMark(options) {\r\n        const v = this.value;\r\n        const numSingleQuotes = v.replace(/[^']/g, '').length;\r\n        const numDoubleQuotes = v.replace(/[^\"]/g, '').length;\r\n        if (numSingleQuotes + numDoubleQuotes === 0) {\r\n            const escaped = cssesc(v, { isIdentifier: true });\r\n            if (escaped === v) {\r\n                return Attribute.NO_QUOTE;\r\n            }\r\n            else {\r\n                const pref = this.preferredQuoteMark(options);\r\n                if (pref === Attribute.NO_QUOTE) {\r\n                    // pick a quote mark that isn't none and see if it's smaller\r\n                    const quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\r\n                    const opts = CSSESC_QUOTE_OPTIONS[quote];\r\n                    const quoteValue = cssesc(v, opts);\r\n                    if (quoteValue.length < escaped.length) {\r\n                        return quote;\r\n                    }\r\n                }\r\n                return pref;\r\n            }\r\n        }\r\n        else if (numDoubleQuotes === numSingleQuotes) {\r\n            return this.preferredQuoteMark(options);\r\n        }\r\n        else if (numDoubleQuotes < numSingleQuotes) {\r\n            return Attribute.DOUBLE_QUOTE;\r\n        }\r\n        else {\r\n            return Attribute.SINGLE_QUOTE;\r\n        }\r\n    }\r\n    /**\r\n     * Selects the preferred quote mark based on the options and the current quote mark value.\r\n     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\r\n     * instead.\r\n     */\r\n    preferredQuoteMark(options) {\r\n        let quoteMark = (options.preferCurrentQuoteMark) ? this.quoteMark : options.quoteMark;\r\n        if (quoteMark === undefined) {\r\n            quoteMark = (options.preferCurrentQuoteMark) ? options.quoteMark : this.quoteMark;\r\n        }\r\n        if (quoteMark === undefined) {\r\n            quoteMark = Attribute.DOUBLE_QUOTE;\r\n        }\r\n        return quoteMark;\r\n    }\r\n    get quoted() {\r\n        const qm = this.quoteMark;\r\n        return qm === \"'\" || qm === '\"';\r\n    }\r\n    set quoted(value) {\r\n        warnOfDeprecatedQuotedAssignment();\r\n    }\r\n    /**\r\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\r\n     * returns `null` if the value is not quoted.\r\n     * returns `undefined` if the quotation state is unknown (this can happen when\r\n     * the attribute is constructed without specifying a quote mark.)\r\n     */\r\n    get quoteMark() {\r\n        return this._quoteMark;\r\n    }\r\n    /**\r\n     * Set the quote mark to be used by this attribute's value.\r\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\r\n     * value is updated accordingly.\r\n     *\r\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\r\n     */\r\n    set quoteMark(quoteMark) {\r\n        if (!this._constructed) {\r\n            this._quoteMark = quoteMark;\r\n            return;\r\n        }\r\n        if (this._quoteMark !== quoteMark) {\r\n            this._quoteMark = quoteMark;\r\n            this._syncRawValue();\r\n        }\r\n    }\r\n    _syncRawValue() {\r\n        const rawValue = cssesc(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\r\n        if (rawValue === this._value) {\r\n            if (this.raws) {\r\n                delete this.raws.value;\r\n            }\r\n        }\r\n        else {\r\n            this.raws.value = rawValue;\r\n        }\r\n    }\r\n    get qualifiedAttribute() {\r\n        return this.qualifiedName(this.raws.attribute || this.attribute);\r\n    }\r\n    get insensitiveFlag() {\r\n        return this.insensitive ? 'i' : '';\r\n    }\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    get insensitive() {\r\n        return this._insensitive;\r\n    }\r\n    /**\r\n     * Set the case insensitive flag.\r\n     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`\r\n     * of the attribute is updated accordingly.\r\n     *\r\n     * @param {true | false} insensitive true if the attribute should match case-insensitively.\r\n     */\r\n    set insensitive(insensitive) {\r\n        if (!insensitive) {\r\n            this._insensitive = false;\r\n            // \"i\" and \"I\" can be used in \"this.raws.insensitiveFlag\" to store the original notation.\r\n            // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.\r\n            if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {\r\n                this.raws.insensitiveFlag = undefined;\r\n            }\r\n        }\r\n        this._insensitive = insensitive;\r\n    }\r\n    /**\r\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\r\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\r\n     * is unescaped during parsing and any quote marks are removed.\r\n     *\r\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\r\n     * a deprecation warning is raised when the new value contains any characters that would\r\n     * require escaping (including if it contains wrapped quotes).\r\n     *\r\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\r\n     * how the new value is quoted.\r\n     */\r\n    set value(v) {\r\n        if (this._constructed) {\r\n            const { deprecatedUsage, unescaped, quoteMark, } = unescapeValue(v);\r\n            if (deprecatedUsage) {\r\n                warnOfDeprecatedValueAssignment();\r\n            }\r\n            if (unescaped === this._value && quoteMark === this._quoteMark) {\r\n                return;\r\n            }\r\n            this._value = unescaped;\r\n            this._quoteMark = quoteMark;\r\n            this._syncRawValue();\r\n        }\r\n        else {\r\n            this._value = v;\r\n        }\r\n    }\r\n    get attribute() {\r\n        return this._attribute;\r\n    }\r\n    set attribute(name) {\r\n        this._handleEscapes(\"attribute\", name);\r\n        this._attribute = name;\r\n    }\r\n    _handleEscapes(prop, value) {\r\n        if (this._constructed) {\r\n            const escaped = cssesc(value, { isIdentifier: true });\r\n            if (escaped !== value) {\r\n                this.raws[prop] = escaped;\r\n            }\r\n            else {\r\n                delete this.raws[prop];\r\n            }\r\n        }\r\n    }\r\n    _spacesFor(name) {\r\n        const attrSpaces = { before: '', after: '' };\r\n        const spaces = this.spaces[name] || {};\r\n        const rawSpaces = (this.raws.spaces && this.raws.spaces[name]) || {};\r\n        return Object.assign(attrSpaces, spaces, rawSpaces);\r\n    }\r\n    _stringFor(name, spaceName = name, concat = defaultAttrConcat) {\r\n        const attrSpaces = this._spacesFor(spaceName);\r\n        return concat(this.stringifyProperty(name), attrSpaces);\r\n    }\r\n    /**\r\n     * returns the offset of the attribute part specified relative to the\r\n     * start of the node of the output string.\r\n     *\r\n     * * \"ns\" - alias for \"namespace\"\r\n     * * \"namespace\" - the namespace if it exists.\r\n     * * \"attribute\" - the attribute name\r\n     * * \"attributeNS\" - the start of the attribute or its namespace\r\n     * * \"operator\" - the match operator of the attribute\r\n     * * \"value\" - The value (string or identifier)\r\n     * * \"insensitive\" - the case insensitivity flag;\r\n     * @param part One of the possible values inside an attribute.\r\n     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\r\n     */\r\n    offsetOf(name) {\r\n        let count = 1;\r\n        const attributeSpaces = this._spacesFor(\"attribute\");\r\n        count += attributeSpaces.before.length;\r\n        if (name === \"namespace\" || name === \"ns\") {\r\n            return (this.namespace) ? count : -1;\r\n        }\r\n        if (name === \"attributeNS\") {\r\n            return count;\r\n        }\r\n        count += this.namespaceString.length;\r\n        if (this.namespace) {\r\n            count += 1;\r\n        }\r\n        if (name === \"attribute\") {\r\n            return count;\r\n        }\r\n        count += this.stringifyProperty(\"attribute\").length;\r\n        count += attributeSpaces.after.length;\r\n        const operatorSpaces = this._spacesFor(\"operator\");\r\n        count += operatorSpaces.before.length;\r\n        const operator = this.stringifyProperty(\"operator\");\r\n        if (name === \"operator\") {\r\n            return operator ? count : -1;\r\n        }\r\n        count += operator.length;\r\n        count += operatorSpaces.after.length;\r\n        const valueSpaces = this._spacesFor(\"value\");\r\n        count += valueSpaces.before.length;\r\n        const value = this.stringifyProperty(\"value\");\r\n        if (name === \"value\") {\r\n            return value ? count : -1;\r\n        }\r\n        count += value.length;\r\n        count += valueSpaces.after.length;\r\n        const insensitiveSpaces = this._spacesFor(\"insensitive\");\r\n        count += insensitiveSpaces.before.length;\r\n        if (name === \"insensitive\") {\r\n            return (this.insensitive) ? count : -1;\r\n        }\r\n        return -1;\r\n    }\r\n    toString() {\r\n        const selector = [\r\n            this.rawSpaceBefore,\r\n            '[',\r\n        ];\r\n        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\r\n        if (this.operator && (this.value || this.value === '')) {\r\n            selector.push(this._stringFor('operator'));\r\n            selector.push(this._stringFor('value'));\r\n            selector.push(this._stringFor('insensitiveFlag', 'insensitive', (attrValue, attrSpaces) => {\r\n                if (attrValue.length > 0\r\n                    && !this.quoted\r\n                    && attrSpaces.before.length === 0\r\n                    && !(this.spaces.value && this.spaces.value.after)) {\r\n                    attrSpaces.before = \" \";\r\n                }\r\n                return defaultAttrConcat(attrValue, attrSpaces);\r\n            }));\r\n        }\r\n        selector.push(']');\r\n        selector.push(this.rawSpaceAfter);\r\n        return selector.join('');\r\n    }\r\n}\r\nconst CSSESC_QUOTE_OPTIONS = {\r\n    \"'\": { quotes: 'single', wrap: true },\r\n    '\"': { quotes: 'double', wrap: true },\r\n    [null]: { isIdentifier: true },\r\n};\r\nfunction defaultAttrConcat(attrValue, attrSpaces) {\r\n    return `${attrSpaces.before}${attrValue}${attrSpaces.after}`;\r\n}\r\n"],
  "mappings": "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",
  "names": ["merge", "cssesc"]
}
