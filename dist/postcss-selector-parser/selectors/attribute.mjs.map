{
  "version": 3,
  "sources": ["../../../src/cssesc/index.js", "../../../src/postcss-selector-parser/util/unesc.js", "../../../src/postcss-selector-parser/util/ensureObject.js", "../../../src/postcss-selector-parser/selectors/node.js", "../../../src/postcss-selector-parser/selectors/namespace.js", "../../../src/postcss-selector-parser/selectors/types.js", "../../../src/postcss-selector-parser/selectors/attribute.js"],
  "sourcesContent": ["\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst merge = (options, defaults) => {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tconst result = {};\n\tfor (const key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { \u2026 }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key)\n\t\t\t? options[key]\n\t\t\t: defaults[key];\n\t}\n\treturn result;\n};\n\nconst regexAnySingleEscape = /<%= anySingleEscape %>/;\nconst regexSingleEscape = /<%= singleEscapes %>/;\nconst regexAlwaysEscape = /['\"\\\\]/;\nconst regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n/*@__NO_SIDE_EFFECTS__*/\nconst cssesc = (string, options) => {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ? '\"' : '\\'';\n\tconst isIdentifier = options.isIdentifier;\n\n\tconst firstChar = string.charAt(0);\n\tlet output = '';\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst character = string.charAt(counter++);\n\t\tlet codePoint = character.charCodeAt();\n\t\tlet value;\n\t\t// If it\u2019s not a printable ASCII character\u2026\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It\u2019s a high surrogate, and there is a next character.\n\t\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It\u2019s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (\n\t\t\t\tcharacter == '\\\\' ||\n\t\t\t\t(\n\t\t\t\t\t!isIdentifier &&\n\t\t\t\t\t(\n\t\t\t\t\t\t(character == '\"' && quote == character) ||\n\t\t\t\t\t\t(character == '\\'' && quote == character)\n\t\t\t\t\t)\n\t\t\t\t) ||\n\t\t\t\t(isIdentifier && regexSingleEscape.test(character))\n\t\t\t) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they\u2019re redundant. Note that this is only possible if the escape\n\t// sequence isn\u2019t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, ($0, $1, $2) => {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It\u2019s not safe to remove the space, so don\u2019t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\nexport default cssesc;", "// Many thanks for this post which made this migration much easier.\n// https://mathiasbynens.be/notes/css-escapes\n\n/**\n * \n * @param {string} str \n * @returns {[string, number]|undefined}\n */\nfunction gobbleHex (str) {\n    const lower = str.toLowerCase();\n    let hex = '';\n    let spaceTerminated = false;\n    for (let i = 0; i < 6 && lower[i] !== undefined; i++) {\n        const code =  lower.charCodeAt(i);\n        // check to see if we are dealing with a valid hex char [a-f|0-9]\n        const valid = (code >= 97 && code <= 102) || (code >= 48 && code <= 57);\n        // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\n        spaceTerminated = code === 32;\n        if (!valid) {\n            break;\n        }\n        hex += lower[i];\n    }\n\n    if (hex.length === 0) {\n        return undefined;\n    }\n    const codePoint = parseInt(hex, 16);\n\n    const isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;\n    // Add special case for\n    // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\n    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\n    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\n        return ['\\uFFFD', hex.length + (spaceTerminated ? 1 : 0)];\n    }\n\n    return [\n        String.fromCodePoint(codePoint),\n        hex.length + (spaceTerminated ? 1 : 0),\n    ];\n}\n\nconst CONTAINS_ESCAPE = /\\\\/;\n\nexport default function unesc (str) {\n    let needToProcess = CONTAINS_ESCAPE.test(str);\n    if (!needToProcess) {\n        return str;\n    }\n    let ret = \"\";\n\n    for (let i = 0; i < str.length; i++) {\n        if ((str[i] === \"\\\\\")) {\n            const gobbled = gobbleHex(str.slice(i + 1, i + 7));\n            if (gobbled !== undefined) {\n                ret += gobbled[0];\n                i += gobbled[1];\n                continue;\n            }\n\n            // Retain a pair of \\\\ if double escaped `\\\\\\\\`\n            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\n            if (str[i + 1] === \"\\\\\") {\n                ret += \"\\\\\";\n                i++;\n                continue;\n            }\n\n            // if \\\\ is at the end of the string retain it\n            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\n            if (str.length === i + 1) {\n                ret += str[i];\n            }\n            continue;\n        }\n      \n        ret += str[i];\n    }\n\n    return ret;\n}\n", "export default function ensureObject (obj, ...props) {\n    while (props.length > 0) {\n        const prop = props.shift();\n\n        if (!obj[prop]) {\n            obj[prop] = {};\n        }\n\n        obj = obj[prop];\n    }\n}\n", "import {ensureObject} from \"../util\";\n\nlet cloneNode = function (obj, parent) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    let cloned = new obj.constructor();\n\n    for ( let i in obj ) {\n        if ( !obj.hasOwnProperty(i) ) {\n            continue;\n        }\n        let value = obj[i];\n        let type  = typeof value;\n\n        if ( i === 'parent' && type === 'object' ) {\n            if (parent) {\n                cloned[i] = parent;\n            }\n        } else if ( value instanceof Array ) {\n            cloned[i] = value.map( j => cloneNode(j, cloned) );\n        } else {\n            cloned[i] = cloneNode(value, cloned);\n        }\n    }\n\n    return cloned;\n};\n\nexport default class Node {\n    constructor (opts = {}) {\n        Object.assign(this, opts);\n        this.spaces = this.spaces || {};\n        this.spaces.before = this.spaces.before || '';\n        this.spaces.after = this.spaces.after || '';\n    }\n\n    remove () {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n\n    replaceWith () {\n        if (this.parent) {\n            for (let index in arguments) {\n                this.parent.insertBefore(this, arguments[index]);\n            }\n            this.remove();\n        }\n        return this;\n    }\n\n    next () {\n        return this.parent.at(this.parent.index(this) + 1);\n    }\n\n    prev () {\n        return this.parent.at(this.parent.index(this) - 1);\n    }\n\n    clone (overrides = {}) {\n        let cloned = cloneNode(this);\n        for (let name in overrides) {\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows non standard syntax to be appended to an existing property\n     * by specifying the escaped value. By specifying the escaped value,\n     * illegal characters are allowed to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped optional. the escaped value of the property.\n     */\n    appendToPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        let originalValue = this[name];\n        let originalEscaped = this.raws[name];\n        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (originalEscaped || valueEscaped !== value) {\n            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\n        } else {\n            delete this.raws[name]; // delete any escaped value that was created by the setter.\n        }\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows the escaped value to be specified directly, allowing illegal\n     * characters to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped the escaped value of the property.\n     */\n    setPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        this.raws[name] = valueEscaped;\n    }\n\n    /**\n     * When you want a value to passed through to CSS directly. This method\n     * deletes the corresponding raw value causing the stringifier to fallback\n     * to the unescaped value.\n     * @param {string} name the property to set.\n     * @param {any} value The value that is both escaped and unescaped.\n     */\n    setPropertyWithoutEscape (name, value) {\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (this.raws) {\n            delete this.raws[name];\n        }\n    }\n\n    /**\n     *\n     * @param {number} line The number (starting with 1)\n     * @param {number} column The column number (starting with 1)\n     */\n    isAtPosition (line, column) {\n        if (this.source && this.source.start && this.source.end) {\n            if (this.source.start.line > line) {\n                return false;\n            }\n            if (this.source.end.line < line) {\n                return false;\n            }\n            if (this.source.start.line === line && this.source.start.column > column) {\n                return false;\n            }\n            if (this.source.end.line === line && this.source.end.column < column) {\n                return false;\n            }\n            return true;\n        }\n        return undefined;\n    }\n\n    stringifyProperty (name) {\n        return (this.raws && this.raws[name]) || this[name];\n    }\n\n    get rawSpaceBefore () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces && this.spaces.before;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceBefore (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.before = raw;\n    }\n\n    get rawSpaceAfter () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces.after;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceAfter (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.after = raw;\n    }\n\n    valueToString () {\n        return String(this.stringifyProperty(\"value\"));\n    }\n\n    toString () {\n        return [\n            this.rawSpaceBefore,\n            this.valueToString(),\n            this.rawSpaceAfter,\n        ].join('');\n    }\n}\n", "import cssesc from \"../../cssesc\";\nimport { ensureObject } from '../util';\nimport Node from './node';\n\nexport default class Namespace extends Node {\n    get namespace () {\n        return this._namespace;\n    }\n    set namespace (namespace) {\n        if (namespace === true || namespace === \"*\" || namespace === \"&\") {\n            this._namespace = namespace;\n            if (this.raws) {\n                delete this.raws.namespace;\n            }\n            return;\n        }\n\n        const escaped = cssesc(namespace, {isIdentifier: true});\n        this._namespace = namespace;\n        if (escaped !== namespace) {\n            ensureObject(this, \"raws\");\n            this.raws.namespace = escaped;\n        } else if (this.raws) {\n            delete this.raws.namespace;\n        }\n    }\n    get ns () {\n        return this._namespace;\n    }\n    set ns (namespace) {\n        this.namespace = namespace;\n    }\n\n    get namespaceString () {\n        if (this.namespace) {\n            const ns = this.stringifyProperty(\"namespace\");\n            if (ns === true) {\n                return '';\n            } else {\n                return ns;\n            }\n        } else {\n            return '';\n        }\n    }\n\n    qualifiedName (value) {\n        if (this.namespace) {\n            return `${this.namespaceString}|${value}`;\n        } else {\n            return value;\n        }\n    }\n\n    valueToString () {\n        return this.qualifiedName(super.valueToString());\n    }\n};\n", "export const TAG = 'tag';\nexport const STRING = 'string';\nexport const SELECTOR = 'selector';\nexport const ROOT = 'root';\nexport const PSEUDO = 'pseudo';\nexport const NESTING = 'nesting';\nexport const ID = 'id';\nexport const COMMENT = 'comment';\nexport const COMBINATOR = 'combinator';\nexport const CLASS = 'class';\nexport const ATTRIBUTE = 'attribute';\nexport const UNIVERSAL = 'universal';\n", "import cssesc from \"../../cssesc\";\nimport unesc from \"../util/unesc\";\nimport Namespace from './namespace';\nimport { ATTRIBUTE } from './types';\n\nconst WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\n\nexport function unescapeValue (value) {\n    let deprecatedUsage = false;\n    let quoteMark = null;\n    let unescaped = value;\n    const m = unescaped.match(WRAPPED_IN_QUOTES);\n    if (m) {\n        quoteMark = m[1];\n        unescaped = m[2];\n    }\n    unescaped = unesc(unescaped);\n    if (unescaped !== value) {\n        deprecatedUsage = true;\n    }\n    return {\n        deprecatedUsage,\n        unescaped,\n        quoteMark,\n    };\n}\n\nfunction handleDeprecatedContructorOpts (opts) {\n    if (opts.quoteMark !== undefined) {\n        return opts;\n    }\n    if (opts.value === undefined) {\n        return opts;\n    }\n    warnOfDeprecatedConstructor();\n    const {quoteMark, unescaped} = unescapeValue(opts.value);\n    if (!opts.raws) {\n        opts.raws = {};\n    }\n    if (opts.raws.value === undefined) {\n        opts.raws.value = opts.value;\n    }\n    opts.value = unescaped;\n    opts.quoteMark = quoteMark;\n    return opts;\n}\n\nexport default class Attribute extends Namespace {\n    static NO_QUOTE = null;\n    static SINGLE_QUOTE = \"'\";\n    static DOUBLE_QUOTE = '\"';\n    constructor (opts = {}) {\n        super(handleDeprecatedContructorOpts(opts));\n        this.type = ATTRIBUTE;\n        this.raws = this.raws || {};\n        this._constructed = true;\n    }\n\n    /**\n     * Returns the Attribute's value quoted such that it would be legal to use\n     * in the value of a css file. The original value's quotation setting\n     * used for stringification is left unchanged. See `setValue(value, options)`\n     * if you want to control the quote settings of a new value for the attribute.\n     *\n     * You can also change the quotation used for the current value by setting quoteMark.\n     *\n     * Options:\n     *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n     *     option is not set, the original value for quoteMark will be used. If\n     *     indeterminate, a double quote is used. The legal values are:\n     *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n     *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n     *     over the quoteMark option value.\n     *   * smart {boolean} - if true, will select a quote mark based on the value\n     *     and the other options specified here. See the `smartQuoteMark()`\n     *     method.\n     **/\n    getQuotedValue (options = {}) {\n        const quoteMark = this._determineQuoteMark(options);\n        const cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n        const escaped = cssesc(this._value, cssescopts);\n        return escaped;\n    }\n\n    _determineQuoteMark (options) {\n        return (options.smart) ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n    }\n\n    /**\n     * Set the unescaped value with the specified quotation options. The value\n     * provided must not include any wrapping quote marks -- those quotes will\n     * be interpreted as part of the value and escaped accordingly.\n     */\n    setValue (value, options = {}) {\n        this._value = value;\n        this._quoteMark = this._determineQuoteMark(options);\n        this._syncRawValue();\n    }\n\n    /**\n     * Intelligently select a quoteMark value based on the value's contents. If\n     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n     * mark will be picked that minimizes the number of escapes.\n     *\n     * If there's no clear winner, the quote mark from these options is used,\n     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n     * true). If the quoteMark is unspecified, a double quote is used.\n     *\n     * @param options This takes the quoteMark and preferCurrentQuoteMark options\n     * from the quoteValue method.\n     */\n    smartQuoteMark (options) {\n        const v = this.value;\n        const numSingleQuotes = v.replace(/[^']/g, '').length;\n        const numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n        if (numSingleQuotes + numDoubleQuotes === 0) {\n            const escaped = cssesc(v, {isIdentifier: true});\n            if (escaped === v) {\n                return Attribute.NO_QUOTE;\n            } else {\n                const pref = this.preferredQuoteMark(options);\n                if (pref === Attribute.NO_QUOTE) {\n                    // pick a quote mark that isn't none and see if it's smaller\n                    const quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n                    const opts = CSSESC_QUOTE_OPTIONS[quote];\n                    const quoteValue = cssesc(v, opts);\n                    if (quoteValue.length < escaped.length) {\n                        return quote;\n                    }\n                }\n                return pref;\n            }\n        } else if (numDoubleQuotes === numSingleQuotes) {\n            return this.preferredQuoteMark(options);\n        } else if ( numDoubleQuotes < numSingleQuotes) {\n            return Attribute.DOUBLE_QUOTE;\n        } else {\n            return Attribute.SINGLE_QUOTE;\n        }\n    }\n\n    /**\n     * Selects the preferred quote mark based on the options and the current quote mark value.\n     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n     * instead.\n     */\n    preferredQuoteMark (options) {\n        let quoteMark = (options.preferCurrentQuoteMark) ? this.quoteMark : options.quoteMark;\n\n        if (quoteMark === undefined) {\n            quoteMark = (options.preferCurrentQuoteMark) ? options.quoteMark : this.quoteMark;\n        }\n\n        if (quoteMark === undefined) {\n            quoteMark = Attribute.DOUBLE_QUOTE;\n        }\n\n        return quoteMark;\n    }\n\n    get quoted () {\n        const qm = this.quoteMark;\n        return qm === \"'\" || qm === '\"';\n    }\n\n    set quoted (value) {\n        warnOfDeprecatedQuotedAssignment();\n    }\n\n    /**\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n     * returns `null` if the value is not quoted.\n     * returns `undefined` if the quotation state is unknown (this can happen when\n     * the attribute is constructed without specifying a quote mark.)\n     */\n    get quoteMark () {\n        return this._quoteMark;\n    }\n\n    /**\n     * Set the quote mark to be used by this attribute's value.\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n     * value is updated accordingly.\n     *\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n     */\n    set quoteMark (quoteMark) {\n        if (!this._constructed) {\n            this._quoteMark = quoteMark;\n            return;\n        }\n        if (this._quoteMark !== quoteMark) {\n            this._quoteMark = quoteMark;\n            this._syncRawValue();\n        }\n    }\n\n    _syncRawValue () {\n        const rawValue = cssesc(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n        if (rawValue === this._value) {\n            if (this.raws) {\n                delete this.raws.value;\n            }\n        } else {\n            this.raws.value = rawValue;\n        }\n    }\n\n    get qualifiedAttribute () {\n        return this.qualifiedName(this.raws.attribute || this.attribute);\n    }\n\n    get insensitiveFlag () {\n        return this.insensitive ? 'i' : '';\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    get insensitive () {\n        return this._insensitive;\n    }\n\n    /**\n     * Set the case insensitive flag.\n     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`\n     * of the attribute is updated accordingly.\n     *\n     * @param {true | false} insensitive true if the attribute should match case-insensitively.\n     */\n    set insensitive (insensitive) {\n        if (!insensitive) {\n            this._insensitive = false;\n\n            // \"i\" and \"I\" can be used in \"this.raws.insensitiveFlag\" to store the original notation.\n            // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.\n            if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {\n                this.raws.insensitiveFlag = undefined;\n            }\n        }\n\n        this._insensitive = insensitive;\n    }\n\n    /**\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n     * is unescaped during parsing and any quote marks are removed.\n     *\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n     * a deprecation warning is raised when the new value contains any characters that would\n     * require escaping (including if it contains wrapped quotes).\n     *\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n     * how the new value is quoted.\n     */\n    set value (v) {\n        if (this._constructed) {\n            const {\n                deprecatedUsage,\n                unescaped,\n                quoteMark,\n            } = unescapeValue(v);\n            if (deprecatedUsage) {\n                warnOfDeprecatedValueAssignment();\n            }\n            if (unescaped === this._value && quoteMark === this._quoteMark) {\n                return;\n            }\n            this._value = unescaped;\n            this._quoteMark = quoteMark;\n            this._syncRawValue();\n        } else {\n            this._value = v;\n        }\n    }\n\n    get attribute () {\n        return this._attribute;\n    }\n\n    set attribute (name) {\n        this._handleEscapes(\"attribute\", name);\n        this._attribute = name;\n    }\n\n    _handleEscapes (prop, value) {\n        if (this._constructed) {\n            const escaped = cssesc(value, {isIdentifier: true});\n            if (escaped !== value) {\n                this.raws[prop] = escaped;\n            } else {\n                delete this.raws[prop];\n            }\n        }\n    }\n\n    _spacesFor (name) {\n        const attrSpaces = {before: '', after: ''};\n        const spaces = this.spaces[name] || {};\n        const rawSpaces = (this.raws.spaces && this.raws.spaces[name]) || {};\n        return Object.assign(attrSpaces, spaces, rawSpaces);\n    }\n\n    _stringFor (name, spaceName = name, concat = defaultAttrConcat) {\n        const attrSpaces = this._spacesFor(spaceName);\n        return concat(this.stringifyProperty(name), attrSpaces);\n    }\n\n    /**\n     * returns the offset of the attribute part specified relative to the\n     * start of the node of the output string.\n     *\n     * * \"ns\" - alias for \"namespace\"\n     * * \"namespace\" - the namespace if it exists.\n     * * \"attribute\" - the attribute name\n     * * \"attributeNS\" - the start of the attribute or its namespace\n     * * \"operator\" - the match operator of the attribute\n     * * \"value\" - The value (string or identifier)\n     * * \"insensitive\" - the case insensitivity flag;\n     * @param part One of the possible values inside an attribute.\n     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n     */\n    offsetOf (name) {\n        let count = 1;\n        const attributeSpaces = this._spacesFor(\"attribute\");\n        count += attributeSpaces.before.length;\n        if (name === \"namespace\" || name === \"ns\") {\n            return (this.namespace) ? count : -1;\n        }\n        if (name === \"attributeNS\") {\n            return count;\n        }\n\n        count += this.namespaceString.length;\n        if (this.namespace) {\n            count += 1;\n        }\n        if (name === \"attribute\") {\n            return count;\n        }\n\n        count += this.stringifyProperty(\"attribute\").length;\n        count += attributeSpaces.after.length;\n        const operatorSpaces = this._spacesFor(\"operator\");\n        count += operatorSpaces.before.length;\n        const operator = this.stringifyProperty(\"operator\");\n        if (name === \"operator\") {\n            return operator ? count : -1;\n        }\n\n        count += operator.length;\n        count += operatorSpaces.after.length;\n        const valueSpaces = this._spacesFor(\"value\");\n        count += valueSpaces.before.length;\n        const value = this.stringifyProperty(\"value\");\n        if (name === \"value\") {\n            return value ? count : -1;\n        }\n\n        count += value.length;\n        count += valueSpaces.after.length;\n        const insensitiveSpaces = this._spacesFor(\"insensitive\");\n        count += insensitiveSpaces.before.length;\n        if (name === \"insensitive\") {\n            return (this.insensitive) ? count : -1;\n        }\n        return -1;\n    }\n\n    toString () {\n        const selector = [\n            this.rawSpaceBefore,\n            '[',\n        ];\n\n        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n        if (this.operator && (this.value || this.value === '')) {\n            selector.push(this._stringFor('operator'));\n            selector.push(this._stringFor('value'));\n            selector.push(this._stringFor('insensitiveFlag', 'insensitive', (attrValue, attrSpaces) => {\n                if (attrValue.length > 0\n                    && !this.quoted\n                    && attrSpaces.before.length === 0\n                    && !(this.spaces.value && this.spaces.value.after)) {\n\n                    attrSpaces.before = \" \";\n                }\n                return defaultAttrConcat(attrValue, attrSpaces);\n            }));\n        }\n\n        selector.push(']');\n        selector.push(this.rawSpaceAfter);\n        return selector.join('');\n    }\n}\n\nconst CSSESC_QUOTE_OPTIONS = {\n    \"'\": {quotes: 'single', wrap: true},\n    '\"': {quotes: 'double', wrap: true},\n    [null]: {isIdentifier: true},\n};\n\nfunction defaultAttrConcat (attrValue, attrSpaces) {\n    return `${attrSpaces.before}${attrValue}${attrSpaces.after}`;\n}\n"],
  "mappings": "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",
  "names": []
}
