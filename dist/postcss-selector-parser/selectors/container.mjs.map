{
  "version": 3,
  "sources": ["../../../src/postcss-selector-parser/util/ensureObject.js", "../../../src/postcss-selector-parser/selectors/node.js", "../../../src/postcss-selector-parser/selectors/types.js", "../../../src/postcss-selector-parser/selectors/container.js"],
  "sourcesContent": ["export default function ensureObject (obj, ...props) {\n    while (props.length > 0) {\n        const prop = props.shift();\n\n        if (!obj[prop]) {\n            obj[prop] = {};\n        }\n\n        obj = obj[prop];\n    }\n}\n", "import {ensureObject} from \"../util\";\n\nlet cloneNode = function (obj, parent) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    let cloned = new obj.constructor();\n\n    for ( let i in obj ) {\n        if ( !obj.hasOwnProperty(i) ) {\n            continue;\n        }\n        let value = obj[i];\n        let type  = typeof value;\n\n        if ( i === 'parent' && type === 'object' ) {\n            if (parent) {\n                cloned[i] = parent;\n            }\n        } else if ( value instanceof Array ) {\n            cloned[i] = value.map( j => cloneNode(j, cloned) );\n        } else {\n            cloned[i] = cloneNode(value, cloned);\n        }\n    }\n\n    return cloned;\n};\n\nexport default class Node {\n    constructor (opts = {}) {\n        Object.assign(this, opts);\n        this.spaces = this.spaces || {};\n        this.spaces.before = this.spaces.before || '';\n        this.spaces.after = this.spaces.after || '';\n    }\n\n    remove () {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n\n    replaceWith () {\n        if (this.parent) {\n            for (let index in arguments) {\n                this.parent.insertBefore(this, arguments[index]);\n            }\n            this.remove();\n        }\n        return this;\n    }\n\n    next () {\n        return this.parent.at(this.parent.index(this) + 1);\n    }\n\n    prev () {\n        return this.parent.at(this.parent.index(this) - 1);\n    }\n\n    clone (overrides = {}) {\n        let cloned = cloneNode(this);\n        for (let name in overrides) {\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows non standard syntax to be appended to an existing property\n     * by specifying the escaped value. By specifying the escaped value,\n     * illegal characters are allowed to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped optional. the escaped value of the property.\n     */\n    appendToPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        let originalValue = this[name];\n        let originalEscaped = this.raws[name];\n        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (originalEscaped || valueEscaped !== value) {\n            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\n        } else {\n            delete this.raws[name]; // delete any escaped value that was created by the setter.\n        }\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows the escaped value to be specified directly, allowing illegal\n     * characters to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped the escaped value of the property.\n     */\n    setPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        this.raws[name] = valueEscaped;\n    }\n\n    /**\n     * When you want a value to passed through to CSS directly. This method\n     * deletes the corresponding raw value causing the stringifier to fallback\n     * to the unescaped value.\n     * @param {string} name the property to set.\n     * @param {any} value The value that is both escaped and unescaped.\n     */\n    setPropertyWithoutEscape (name, value) {\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (this.raws) {\n            delete this.raws[name];\n        }\n    }\n\n    /**\n     *\n     * @param {number} line The number (starting with 1)\n     * @param {number} column The column number (starting with 1)\n     */\n    isAtPosition (line, column) {\n        if (this.source && this.source.start && this.source.end) {\n            if (this.source.start.line > line) {\n                return false;\n            }\n            if (this.source.end.line < line) {\n                return false;\n            }\n            if (this.source.start.line === line && this.source.start.column > column) {\n                return false;\n            }\n            if (this.source.end.line === line && this.source.end.column < column) {\n                return false;\n            }\n            return true;\n        }\n        return undefined;\n    }\n\n    stringifyProperty (name) {\n        return (this.raws && this.raws[name]) || this[name];\n    }\n\n    get rawSpaceBefore () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces && this.spaces.before;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceBefore (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.before = raw;\n    }\n\n    get rawSpaceAfter () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces.after;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceAfter (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.after = raw;\n    }\n\n    valueToString () {\n        return String(this.stringifyProperty(\"value\"));\n    }\n\n    toString () {\n        return [\n            this.rawSpaceBefore,\n            this.valueToString(),\n            this.rawSpaceAfter,\n        ].join('');\n    }\n}\n", "export const TAG = 'tag';\nexport const STRING = 'string';\nexport const SELECTOR = 'selector';\nexport const ROOT = 'root';\nexport const PSEUDO = 'pseudo';\nexport const NESTING = 'nesting';\nexport const ID = 'id';\nexport const COMMENT = 'comment';\nexport const COMBINATOR = 'combinator';\nexport const CLASS = 'class';\nexport const ATTRIBUTE = 'attribute';\nexport const UNIVERSAL = 'universal';\n", "import Node from './node';\nimport * as types from './types';\n\nexport default class Container extends Node {\n    constructor (opts) {\n        super(opts);\n        if (!this.nodes) {\n            this.nodes = [];\n        }\n    }\n\n    append (selector) {\n        selector.parent = this;\n        this.nodes.push(selector);\n        return this;\n    }\n\n    prepend (selector) {\n        selector.parent = this;\n        this.nodes.unshift(selector);\n        for ( let id in this.indexes ) {\n            this.indexes[id]++;\n        }\n        return this;\n    }\n\n    at (index) {\n        return this.nodes[index];\n    }\n\n    index (child) {\n        if (typeof child === 'number') {\n            return child;\n        }\n        return this.nodes.indexOf(child);\n    }\n\n    get first () {\n        return this.at(0);\n    }\n\n    get last () {\n        return this.at(this.length - 1);\n    }\n\n    get length () {\n        return this.nodes.length;\n    }\n\n    removeChild (child) {\n        child = this.index(child);\n        this.at(child).parent = undefined;\n        this.nodes.splice(child, 1);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= child ) {\n                this.indexes[id] = index - 1;\n            }\n        }\n\n        return this;\n    }\n\n    removeAll () {\n        for (let node of this.nodes) {\n            node.parent = undefined;\n        }\n        this.nodes = [];\n        return this;\n    }\n\n    empty () {\n        return this.removeAll();\n    }\n\n    insertAfter (oldNode, newNode) {\n        newNode.parent = this;\n        let oldIndex = this.index(oldNode);\n        this.nodes.splice(oldIndex + 1, 0, newNode);\n\n        newNode.parent = this;\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( oldIndex < index ) {\n                this.indexes[id] = index + 1;\n            }\n        }\n\n        return this;\n    }\n\n    insertBefore (oldNode, newNode) {\n        newNode.parent = this;\n        let oldIndex = this.index(oldNode);\n        this.nodes.splice(oldIndex, 0, newNode);\n\n        newNode.parent = this;\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= oldIndex ) {\n                this.indexes[id] = index + 1;\n            }\n        }\n\n        return this;\n    }\n\n    _findChildAtPosition (line, col) {\n        let found = undefined;\n        this.each(node => {\n            if (node.atPosition) {\n                let foundChild = node.atPosition(line, col);\n                if (foundChild) {\n                    found = foundChild;\n                    return false;\n                }\n            } else if (node.isAtPosition(line, col)) {\n                found = node;\n                return false;\n            }\n        });\n        return found;\n    }\n\n    /**\n     * Return the most specific node at the line and column number given.\n     * The source location is based on the original parsed location, locations aren't\n     * updated as selector nodes are mutated.\n     * \n     * Note that this location is relative to the location of the first character\n     * of the selector, and not the location of the selector in the overall document\n     * when used in conjunction with postcss.\n     *\n     * If not found, returns undefined.\n     * @param {number} line The line number of the node to find. (1-based index)\n     * @param {number} col  The column number of the node to find. (1-based index)\n     */\n    atPosition (line, col) {\n        if (this.isAtPosition(line, col)) {\n            return this._findChildAtPosition(line, col) || this;\n        } else {\n            return undefined;\n        }\n    }\n\n    _inferEndPosition () {\n        if (this.last && this.last.source && this.last.source.end) {\n            this.source = this.source || {};\n            this.source.end = this.source.end || {};\n            Object.assign(this.source.end, this.last.source.end);\n        }\n    }\n\n    each (callback) {\n        if (!this.lastEach) {\n            this.lastEach = 0;\n        }\n        if (!this.indexes) {\n            this.indexes = {};\n        }\n\n        this.lastEach ++;\n        let id = this.lastEach;\n        this.indexes[id] = 0;\n\n        if (!this.length) {\n            return undefined;\n        }\n\n        let index, result;\n        while (this.indexes[id] < this.length) {\n            index = this.indexes[id];\n            result = callback(this.at(index), index);\n            if (result === false) {\n                break;\n            }\n\n            this.indexes[id] += 1;\n        }\n\n        delete this.indexes[id];\n\n        if (result === false) {\n            return false;\n        }\n    }\n\n    walk (callback) {\n        return this.each((node, i) => {\n            let result = callback(node, i);\n\n            if (result !== false && node.length) {\n                result = node.walk(callback);\n            }\n\n            if (result === false) {\n                return false;\n            }\n        });\n    }\n\n    walkAttributes (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.ATTRIBUTE) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkClasses (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.CLASS) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkCombinators (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.COMBINATOR) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkComments (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.COMMENT) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkIds (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.ID) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkNesting (callback) {\n        return this.walk(selector => {\n            if (selector.type === types.NESTING) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkPseudos (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.PSEUDO) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkTags (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.TAG) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkUniversals (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.UNIVERSAL) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    split (callback) {\n        let current = [];\n        return this.reduce((memo, node, index) => {\n            let split = callback.call(this, node);\n            current.push(node);\n            if (split) {\n                memo.push(current);\n                current = [];\n            } else if (index === this.length - 1) {\n                memo.push(current);\n            }\n            return memo;\n        }, []);\n    }\n\n    map (callback) {\n        return this.nodes.map(callback);\n    }\n\n    reduce (callback, memo) {\n        return this.nodes.reduce(callback, memo);\n    }\n\n    every (callback) {\n        return this.nodes.every(callback);\n    }\n\n    some (callback) {\n        return this.nodes.some(callback);\n    }\n\n    filter (callback) {\n        return this.nodes.filter(callback);\n    }\n\n    sort (callback) {\n        return this.nodes.sort(callback);\n    }\n\n    toString () {\n        return this.map(String).join('');\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
