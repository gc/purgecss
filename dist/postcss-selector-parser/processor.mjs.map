{
  "version": 3,
  "sources": ["../../src/postcss-selector-parser/util/unesc.js", "../../src/postcss-selector-parser/util/getProp.js", "../../src/postcss-selector-parser/util/ensureObject.js", "../../src/postcss-selector-parser/selectors/node.js", "../../src/postcss-selector-parser/selectors/types.js", "../../src/postcss-selector-parser/selectors/container.js", "../../src/postcss-selector-parser/selectors/root.js", "../../src/postcss-selector-parser/selectors/selector.js", "../../src/cssesc/index.js", "../../src/postcss-selector-parser/selectors/className.js", "../../src/postcss-selector-parser/selectors/comment.js", "../../src/postcss-selector-parser/selectors/id.js", "../../src/postcss-selector-parser/selectors/namespace.js", "../../src/postcss-selector-parser/selectors/tag.js", "../../src/postcss-selector-parser/selectors/string.js", "../../src/postcss-selector-parser/selectors/pseudo.js", "../../src/postcss-selector-parser/selectors/attribute.js", "../../src/postcss-selector-parser/selectors/universal.js", "../../src/postcss-selector-parser/selectors/combinator.js", "../../src/postcss-selector-parser/selectors/nesting.js", "../../src/postcss-selector-parser/sortAscending.js", "../../src/postcss-selector-parser/tokenTypes.js", "../../src/postcss-selector-parser/tokenize.js", "../../src/postcss-selector-parser/parser.js", "../../src/postcss-selector-parser/processor.js"],
  "sourcesContent": ["// Many thanks for this post which made this migration much easier.\n// https://mathiasbynens.be/notes/css-escapes\n\n/**\n * \n * @param {string} str \n * @returns {[string, number]|undefined}\n */\nfunction gobbleHex (str) {\n    const lower = str.toLowerCase();\n    let hex = '';\n    let spaceTerminated = false;\n    for (let i = 0; i < 6 && lower[i] !== undefined; i++) {\n        const code =  lower.charCodeAt(i);\n        // check to see if we are dealing with a valid hex char [a-f|0-9]\n        const valid = (code >= 97 && code <= 102) || (code >= 48 && code <= 57);\n        // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\n        spaceTerminated = code === 32;\n        if (!valid) {\n            break;\n        }\n        hex += lower[i];\n    }\n\n    if (hex.length === 0) {\n        return undefined;\n    }\n    const codePoint = parseInt(hex, 16);\n\n    const isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;\n    // Add special case for\n    // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\n    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\n    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\n        return ['\\uFFFD', hex.length + (spaceTerminated ? 1 : 0)];\n    }\n\n    return [\n        String.fromCodePoint(codePoint),\n        hex.length + (spaceTerminated ? 1 : 0),\n    ];\n}\n\nconst CONTAINS_ESCAPE = /\\\\/;\n\nexport default function unesc (str) {\n    let needToProcess = CONTAINS_ESCAPE.test(str);\n    if (!needToProcess) {\n        return str;\n    }\n    let ret = \"\";\n\n    for (let i = 0; i < str.length; i++) {\n        if ((str[i] === \"\\\\\")) {\n            const gobbled = gobbleHex(str.slice(i + 1, i + 7));\n            if (gobbled !== undefined) {\n                ret += gobbled[0];\n                i += gobbled[1];\n                continue;\n            }\n\n            // Retain a pair of \\\\ if double escaped `\\\\\\\\`\n            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\n            if (str[i + 1] === \"\\\\\") {\n                ret += \"\\\\\";\n                i++;\n                continue;\n            }\n\n            // if \\\\ is at the end of the string retain it\n            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\n            if (str.length === i + 1) {\n                ret += str[i];\n            }\n            continue;\n        }\n      \n        ret += str[i];\n    }\n\n    return ret;\n}\n", "export default function getProp (obj, ...props) {\n    while (props.length > 0) {\n        const prop = props.shift();\n\n        if (!obj[prop]) {\n            return undefined;\n        }\n\n        obj = obj[prop];\n    }\n\n    return obj;\n}\n", "export default function ensureObject (obj, ...props) {\n    while (props.length > 0) {\n        const prop = props.shift();\n\n        if (!obj[prop]) {\n            obj[prop] = {};\n        }\n\n        obj = obj[prop];\n    }\n}\n", "import {ensureObject} from \"../util\";\n\nlet cloneNode = function (obj, parent) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    let cloned = new obj.constructor();\n\n    for ( let i in obj ) {\n        if ( !obj.hasOwnProperty(i) ) {\n            continue;\n        }\n        let value = obj[i];\n        let type  = typeof value;\n\n        if ( i === 'parent' && type === 'object' ) {\n            if (parent) {\n                cloned[i] = parent;\n            }\n        } else if ( value instanceof Array ) {\n            cloned[i] = value.map( j => cloneNode(j, cloned) );\n        } else {\n            cloned[i] = cloneNode(value, cloned);\n        }\n    }\n\n    return cloned;\n};\n\nexport default class Node {\n    constructor (opts = {}) {\n        Object.assign(this, opts);\n        this.spaces = this.spaces || {};\n        this.spaces.before = this.spaces.before || '';\n        this.spaces.after = this.spaces.after || '';\n    }\n\n    remove () {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n\n    replaceWith () {\n        if (this.parent) {\n            for (let index in arguments) {\n                this.parent.insertBefore(this, arguments[index]);\n            }\n            this.remove();\n        }\n        return this;\n    }\n\n    next () {\n        return this.parent.at(this.parent.index(this) + 1);\n    }\n\n    prev () {\n        return this.parent.at(this.parent.index(this) - 1);\n    }\n\n    clone (overrides = {}) {\n        let cloned = cloneNode(this);\n        for (let name in overrides) {\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows non standard syntax to be appended to an existing property\n     * by specifying the escaped value. By specifying the escaped value,\n     * illegal characters are allowed to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped optional. the escaped value of the property.\n     */\n    appendToPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        let originalValue = this[name];\n        let originalEscaped = this.raws[name];\n        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (originalEscaped || valueEscaped !== value) {\n            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\n        } else {\n            delete this.raws[name]; // delete any escaped value that was created by the setter.\n        }\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows the escaped value to be specified directly, allowing illegal\n     * characters to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped the escaped value of the property.\n     */\n    setPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        this.raws[name] = valueEscaped;\n    }\n\n    /**\n     * When you want a value to passed through to CSS directly. This method\n     * deletes the corresponding raw value causing the stringifier to fallback\n     * to the unescaped value.\n     * @param {string} name the property to set.\n     * @param {any} value The value that is both escaped and unescaped.\n     */\n    setPropertyWithoutEscape (name, value) {\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (this.raws) {\n            delete this.raws[name];\n        }\n    }\n\n    /**\n     *\n     * @param {number} line The number (starting with 1)\n     * @param {number} column The column number (starting with 1)\n     */\n    isAtPosition (line, column) {\n        if (this.source && this.source.start && this.source.end) {\n            if (this.source.start.line > line) {\n                return false;\n            }\n            if (this.source.end.line < line) {\n                return false;\n            }\n            if (this.source.start.line === line && this.source.start.column > column) {\n                return false;\n            }\n            if (this.source.end.line === line && this.source.end.column < column) {\n                return false;\n            }\n            return true;\n        }\n        return undefined;\n    }\n\n    stringifyProperty (name) {\n        return (this.raws && this.raws[name]) || this[name];\n    }\n\n    get rawSpaceBefore () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces && this.spaces.before;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceBefore (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.before = raw;\n    }\n\n    get rawSpaceAfter () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces.after;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceAfter (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.after = raw;\n    }\n\n    valueToString () {\n        return String(this.stringifyProperty(\"value\"));\n    }\n\n    toString () {\n        return [\n            this.rawSpaceBefore,\n            this.valueToString(),\n            this.rawSpaceAfter,\n        ].join('');\n    }\n}\n", "export const TAG = 'tag';\nexport const STRING = 'string';\nexport const SELECTOR = 'selector';\nexport const ROOT = 'root';\nexport const PSEUDO = 'pseudo';\nexport const NESTING = 'nesting';\nexport const ID = 'id';\nexport const COMMENT = 'comment';\nexport const COMBINATOR = 'combinator';\nexport const CLASS = 'class';\nexport const ATTRIBUTE = 'attribute';\nexport const UNIVERSAL = 'universal';\n", "import Node from './node';\nimport * as types from './types';\n\nexport default class Container extends Node {\n    constructor (opts) {\n        super(opts);\n        if (!this.nodes) {\n            this.nodes = [];\n        }\n    }\n\n    append (selector) {\n        selector.parent = this;\n        this.nodes.push(selector);\n        return this;\n    }\n\n    prepend (selector) {\n        selector.parent = this;\n        this.nodes.unshift(selector);\n        for ( let id in this.indexes ) {\n            this.indexes[id]++;\n        }\n        return this;\n    }\n\n    at (index) {\n        return this.nodes[index];\n    }\n\n    index (child) {\n        if (typeof child === 'number') {\n            return child;\n        }\n        return this.nodes.indexOf(child);\n    }\n\n    get first () {\n        return this.at(0);\n    }\n\n    get last () {\n        return this.at(this.length - 1);\n    }\n\n    get length () {\n        return this.nodes.length;\n    }\n\n    removeChild (child) {\n        child = this.index(child);\n        this.at(child).parent = undefined;\n        this.nodes.splice(child, 1);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= child ) {\n                this.indexes[id] = index - 1;\n            }\n        }\n\n        return this;\n    }\n\n    removeAll () {\n        for (let node of this.nodes) {\n            node.parent = undefined;\n        }\n        this.nodes = [];\n        return this;\n    }\n\n    empty () {\n        return this.removeAll();\n    }\n\n    insertAfter (oldNode, newNode) {\n        newNode.parent = this;\n        let oldIndex = this.index(oldNode);\n        this.nodes.splice(oldIndex + 1, 0, newNode);\n\n        newNode.parent = this;\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( oldIndex < index ) {\n                this.indexes[id] = index + 1;\n            }\n        }\n\n        return this;\n    }\n\n    insertBefore (oldNode, newNode) {\n        newNode.parent = this;\n        let oldIndex = this.index(oldNode);\n        this.nodes.splice(oldIndex, 0, newNode);\n\n        newNode.parent = this;\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= oldIndex ) {\n                this.indexes[id] = index + 1;\n            }\n        }\n\n        return this;\n    }\n\n    _findChildAtPosition (line, col) {\n        let found = undefined;\n        this.each(node => {\n            if (node.atPosition) {\n                let foundChild = node.atPosition(line, col);\n                if (foundChild) {\n                    found = foundChild;\n                    return false;\n                }\n            } else if (node.isAtPosition(line, col)) {\n                found = node;\n                return false;\n            }\n        });\n        return found;\n    }\n\n    /**\n     * Return the most specific node at the line and column number given.\n     * The source location is based on the original parsed location, locations aren't\n     * updated as selector nodes are mutated.\n     * \n     * Note that this location is relative to the location of the first character\n     * of the selector, and not the location of the selector in the overall document\n     * when used in conjunction with postcss.\n     *\n     * If not found, returns undefined.\n     * @param {number} line The line number of the node to find. (1-based index)\n     * @param {number} col  The column number of the node to find. (1-based index)\n     */\n    atPosition (line, col) {\n        if (this.isAtPosition(line, col)) {\n            return this._findChildAtPosition(line, col) || this;\n        } else {\n            return undefined;\n        }\n    }\n\n    _inferEndPosition () {\n        if (this.last && this.last.source && this.last.source.end) {\n            this.source = this.source || {};\n            this.source.end = this.source.end || {};\n            Object.assign(this.source.end, this.last.source.end);\n        }\n    }\n\n    each (callback) {\n        if (!this.lastEach) {\n            this.lastEach = 0;\n        }\n        if (!this.indexes) {\n            this.indexes = {};\n        }\n\n        this.lastEach ++;\n        let id = this.lastEach;\n        this.indexes[id] = 0;\n\n        if (!this.length) {\n            return undefined;\n        }\n\n        let index, result;\n        while (this.indexes[id] < this.length) {\n            index = this.indexes[id];\n            result = callback(this.at(index), index);\n            if (result === false) {\n                break;\n            }\n\n            this.indexes[id] += 1;\n        }\n\n        delete this.indexes[id];\n\n        if (result === false) {\n            return false;\n        }\n    }\n\n    walk (callback) {\n        return this.each((node, i) => {\n            let result = callback(node, i);\n\n            if (result !== false && node.length) {\n                result = node.walk(callback);\n            }\n\n            if (result === false) {\n                return false;\n            }\n        });\n    }\n\n    walkAttributes (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.ATTRIBUTE) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkClasses (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.CLASS) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkCombinators (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.COMBINATOR) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkComments (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.COMMENT) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkIds (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.ID) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkNesting (callback) {\n        return this.walk(selector => {\n            if (selector.type === types.NESTING) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkPseudos (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.PSEUDO) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkTags (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.TAG) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkUniversals (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.UNIVERSAL) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    split (callback) {\n        let current = [];\n        return this.reduce((memo, node, index) => {\n            let split = callback.call(this, node);\n            current.push(node);\n            if (split) {\n                memo.push(current);\n                current = [];\n            } else if (index === this.length - 1) {\n                memo.push(current);\n            }\n            return memo;\n        }, []);\n    }\n\n    map (callback) {\n        return this.nodes.map(callback);\n    }\n\n    reduce (callback, memo) {\n        return this.nodes.reduce(callback, memo);\n    }\n\n    every (callback) {\n        return this.nodes.every(callback);\n    }\n\n    some (callback) {\n        return this.nodes.some(callback);\n    }\n\n    filter (callback) {\n        return this.nodes.filter(callback);\n    }\n\n    sort (callback) {\n        return this.nodes.sort(callback);\n    }\n\n    toString () {\n        return this.map(String).join('');\n    }\n}\n", "import Container from './container';\nimport {ROOT} from './types';\n\nexport default class Root extends Container {\n    constructor (opts) {\n        super(opts);\n        this.type = ROOT;\n    }\n\n    toString () {\n        let str = this.reduce((memo, selector) => {\n            memo.push(String(selector));\n            return memo;\n        }, []).join(',');\n        return this.trailingComma ? str + ',' : str;\n    }\n\n    error (message, options) {\n        if (this._error) {\n            return this._error(message, options);\n        } else {\n            return new Error(message);\n        }\n    }\n\n    set errorGenerator (handler) {\n        this._error = handler;\n    }\n}\n", "import Container from './container';\nimport {SELECTOR} from './types';\n\nexport default class Selector extends Container {\n    constructor (opts) {\n        super(opts);\n        this.type = SELECTOR;\n    }\n}\n", "\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst merge = (options, defaults) => {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tconst result = {};\n\tfor (const key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { \u2026 }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key)\n\t\t\t? options[key]\n\t\t\t: defaults[key];\n\t}\n\treturn result;\n};\n\nconst regexAnySingleEscape = /<%= anySingleEscape %>/;\nconst regexSingleEscape = /<%= singleEscapes %>/;\nconst regexAlwaysEscape = /['\"\\\\]/;\nconst regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n/*@__NO_SIDE_EFFECTS__*/\nconst cssesc = (string, options) => {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ? '\"' : '\\'';\n\tconst isIdentifier = options.isIdentifier;\n\n\tconst firstChar = string.charAt(0);\n\tlet output = '';\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst character = string.charAt(counter++);\n\t\tlet codePoint = character.charCodeAt();\n\t\tlet value;\n\t\t// If it\u2019s not a printable ASCII character\u2026\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It\u2019s a high surrogate, and there is a next character.\n\t\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It\u2019s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (\n\t\t\t\tcharacter == '\\\\' ||\n\t\t\t\t(\n\t\t\t\t\t!isIdentifier &&\n\t\t\t\t\t(\n\t\t\t\t\t\t(character == '\"' && quote == character) ||\n\t\t\t\t\t\t(character == '\\'' && quote == character)\n\t\t\t\t\t)\n\t\t\t\t) ||\n\t\t\t\t(isIdentifier && regexSingleEscape.test(character))\n\t\t\t) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they\u2019re redundant. Note that this is only possible if the escape\n\t// sequence isn\u2019t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, ($0, $1, $2) => {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It\u2019s not safe to remove the space, so don\u2019t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\nexport default cssesc;", "import cssesc from \"../../cssesc\";\nimport { ensureObject } from '../util';\nimport Node from './node';\nimport { CLASS } from './types';\n\nexport default class ClassName extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = CLASS;\n        this._constructed = true;\n    }\n\n    set value (v) {\n        if (this._constructed) {\n            const escaped = cssesc(v, {isIdentifier: true});\n            if (escaped !== v) {\n                ensureObject(this, \"raws\");\n                this.raws.value = escaped;\n            } else if (this.raws) {\n                delete this.raws.value;\n            }\n        }\n        this._value = v;\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    valueToString () {\n        return '.' + super.valueToString();\n    }\n}\n", "import Node from './node';\nimport {COMMENT} from './types';\n\nexport default class Comment extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = COMMENT;\n    }\n}\n", "import Node from './node';\nimport {ID as IDType} from './types';\n\nexport default class ID extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = IDType;\n    }\n\n    valueToString () {\n        return '#' + super.valueToString();\n    }\n}\n", "import cssesc from \"../../cssesc\";\nimport { ensureObject } from '../util';\nimport Node from './node';\n\nexport default class Namespace extends Node {\n    get namespace () {\n        return this._namespace;\n    }\n    set namespace (namespace) {\n        if (namespace === true || namespace === \"*\" || namespace === \"&\") {\n            this._namespace = namespace;\n            if (this.raws) {\n                delete this.raws.namespace;\n            }\n            return;\n        }\n\n        const escaped = cssesc(namespace, {isIdentifier: true});\n        this._namespace = namespace;\n        if (escaped !== namespace) {\n            ensureObject(this, \"raws\");\n            this.raws.namespace = escaped;\n        } else if (this.raws) {\n            delete this.raws.namespace;\n        }\n    }\n    get ns () {\n        return this._namespace;\n    }\n    set ns (namespace) {\n        this.namespace = namespace;\n    }\n\n    get namespaceString () {\n        if (this.namespace) {\n            const ns = this.stringifyProperty(\"namespace\");\n            if (ns === true) {\n                return '';\n            } else {\n                return ns;\n            }\n        } else {\n            return '';\n        }\n    }\n\n    qualifiedName (value) {\n        if (this.namespace) {\n            return `${this.namespaceString}|${value}`;\n        } else {\n            return value;\n        }\n    }\n\n    valueToString () {\n        return this.qualifiedName(super.valueToString());\n    }\n};\n", "import Namespace from './namespace';\nimport {TAG} from './types';\n\nexport default class Tag extends Namespace {\n    constructor (opts) {\n        super(opts);\n        this.type = TAG;\n    }\n}\n", "import Node from './node';\nimport {STRING} from './types';\n\nexport default class String extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = STRING;\n    }\n}\n", "import Container from './container';\nimport {PSEUDO} from './types';\n\nexport default class Pseudo extends Container {\n    constructor (opts) {\n        super(opts);\n        this.type = PSEUDO;\n    }\n\n    toString () {\n        let params = this.length ? '(' + this.map(String).join(',') + ')' : '';\n        return [\n            this.rawSpaceBefore,\n            this.stringifyProperty(\"value\"),\n            params,\n            this.rawSpaceAfter,\n        ].join('');\n    }\n}\n", "import cssesc from \"../../cssesc\";\nimport unesc from \"../util/unesc\";\nimport Namespace from './namespace';\nimport { ATTRIBUTE } from './types';\n\nconst WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\n\nexport function unescapeValue (value) {\n    let deprecatedUsage = false;\n    let quoteMark = null;\n    let unescaped = value;\n    const m = unescaped.match(WRAPPED_IN_QUOTES);\n    if (m) {\n        quoteMark = m[1];\n        unescaped = m[2];\n    }\n    unescaped = unesc(unescaped);\n    if (unescaped !== value) {\n        deprecatedUsage = true;\n    }\n    return {\n        deprecatedUsage,\n        unescaped,\n        quoteMark,\n    };\n}\n\nfunction handleDeprecatedContructorOpts (opts) {\n    if (opts.quoteMark !== undefined) {\n        return opts;\n    }\n    if (opts.value === undefined) {\n        return opts;\n    }\n    warnOfDeprecatedConstructor();\n    const {quoteMark, unescaped} = unescapeValue(opts.value);\n    if (!opts.raws) {\n        opts.raws = {};\n    }\n    if (opts.raws.value === undefined) {\n        opts.raws.value = opts.value;\n    }\n    opts.value = unescaped;\n    opts.quoteMark = quoteMark;\n    return opts;\n}\n\nexport default class Attribute extends Namespace {\n    static NO_QUOTE = null;\n    static SINGLE_QUOTE = \"'\";\n    static DOUBLE_QUOTE = '\"';\n    constructor (opts = {}) {\n        super(handleDeprecatedContructorOpts(opts));\n        this.type = ATTRIBUTE;\n        this.raws = this.raws || {};\n        this._constructed = true;\n    }\n\n    /**\n     * Returns the Attribute's value quoted such that it would be legal to use\n     * in the value of a css file. The original value's quotation setting\n     * used for stringification is left unchanged. See `setValue(value, options)`\n     * if you want to control the quote settings of a new value for the attribute.\n     *\n     * You can also change the quotation used for the current value by setting quoteMark.\n     *\n     * Options:\n     *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n     *     option is not set, the original value for quoteMark will be used. If\n     *     indeterminate, a double quote is used. The legal values are:\n     *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n     *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n     *     over the quoteMark option value.\n     *   * smart {boolean} - if true, will select a quote mark based on the value\n     *     and the other options specified here. See the `smartQuoteMark()`\n     *     method.\n     **/\n    getQuotedValue (options = {}) {\n        const quoteMark = this._determineQuoteMark(options);\n        const cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n        const escaped = cssesc(this._value, cssescopts);\n        return escaped;\n    }\n\n    _determineQuoteMark (options) {\n        return (options.smart) ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n    }\n\n    /**\n     * Set the unescaped value with the specified quotation options. The value\n     * provided must not include any wrapping quote marks -- those quotes will\n     * be interpreted as part of the value and escaped accordingly.\n     */\n    setValue (value, options = {}) {\n        this._value = value;\n        this._quoteMark = this._determineQuoteMark(options);\n        this._syncRawValue();\n    }\n\n    /**\n     * Intelligently select a quoteMark value based on the value's contents. If\n     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n     * mark will be picked that minimizes the number of escapes.\n     *\n     * If there's no clear winner, the quote mark from these options is used,\n     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n     * true). If the quoteMark is unspecified, a double quote is used.\n     *\n     * @param options This takes the quoteMark and preferCurrentQuoteMark options\n     * from the quoteValue method.\n     */\n    smartQuoteMark (options) {\n        const v = this.value;\n        const numSingleQuotes = v.replace(/[^']/g, '').length;\n        const numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n        if (numSingleQuotes + numDoubleQuotes === 0) {\n            const escaped = cssesc(v, {isIdentifier: true});\n            if (escaped === v) {\n                return Attribute.NO_QUOTE;\n            } else {\n                const pref = this.preferredQuoteMark(options);\n                if (pref === Attribute.NO_QUOTE) {\n                    // pick a quote mark that isn't none and see if it's smaller\n                    const quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n                    const opts = CSSESC_QUOTE_OPTIONS[quote];\n                    const quoteValue = cssesc(v, opts);\n                    if (quoteValue.length < escaped.length) {\n                        return quote;\n                    }\n                }\n                return pref;\n            }\n        } else if (numDoubleQuotes === numSingleQuotes) {\n            return this.preferredQuoteMark(options);\n        } else if ( numDoubleQuotes < numSingleQuotes) {\n            return Attribute.DOUBLE_QUOTE;\n        } else {\n            return Attribute.SINGLE_QUOTE;\n        }\n    }\n\n    /**\n     * Selects the preferred quote mark based on the options and the current quote mark value.\n     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n     * instead.\n     */\n    preferredQuoteMark (options) {\n        let quoteMark = (options.preferCurrentQuoteMark) ? this.quoteMark : options.quoteMark;\n\n        if (quoteMark === undefined) {\n            quoteMark = (options.preferCurrentQuoteMark) ? options.quoteMark : this.quoteMark;\n        }\n\n        if (quoteMark === undefined) {\n            quoteMark = Attribute.DOUBLE_QUOTE;\n        }\n\n        return quoteMark;\n    }\n\n    get quoted () {\n        const qm = this.quoteMark;\n        return qm === \"'\" || qm === '\"';\n    }\n\n    set quoted (value) {\n        warnOfDeprecatedQuotedAssignment();\n    }\n\n    /**\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n     * returns `null` if the value is not quoted.\n     * returns `undefined` if the quotation state is unknown (this can happen when\n     * the attribute is constructed without specifying a quote mark.)\n     */\n    get quoteMark () {\n        return this._quoteMark;\n    }\n\n    /**\n     * Set the quote mark to be used by this attribute's value.\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n     * value is updated accordingly.\n     *\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n     */\n    set quoteMark (quoteMark) {\n        if (!this._constructed) {\n            this._quoteMark = quoteMark;\n            return;\n        }\n        if (this._quoteMark !== quoteMark) {\n            this._quoteMark = quoteMark;\n            this._syncRawValue();\n        }\n    }\n\n    _syncRawValue () {\n        const rawValue = cssesc(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n        if (rawValue === this._value) {\n            if (this.raws) {\n                delete this.raws.value;\n            }\n        } else {\n            this.raws.value = rawValue;\n        }\n    }\n\n    get qualifiedAttribute () {\n        return this.qualifiedName(this.raws.attribute || this.attribute);\n    }\n\n    get insensitiveFlag () {\n        return this.insensitive ? 'i' : '';\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    get insensitive () {\n        return this._insensitive;\n    }\n\n    /**\n     * Set the case insensitive flag.\n     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`\n     * of the attribute is updated accordingly.\n     *\n     * @param {true | false} insensitive true if the attribute should match case-insensitively.\n     */\n    set insensitive (insensitive) {\n        if (!insensitive) {\n            this._insensitive = false;\n\n            // \"i\" and \"I\" can be used in \"this.raws.insensitiveFlag\" to store the original notation.\n            // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.\n            if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {\n                this.raws.insensitiveFlag = undefined;\n            }\n        }\n\n        this._insensitive = insensitive;\n    }\n\n    /**\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n     * is unescaped during parsing and any quote marks are removed.\n     *\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n     * a deprecation warning is raised when the new value contains any characters that would\n     * require escaping (including if it contains wrapped quotes).\n     *\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n     * how the new value is quoted.\n     */\n    set value (v) {\n        if (this._constructed) {\n            const {\n                deprecatedUsage,\n                unescaped,\n                quoteMark,\n            } = unescapeValue(v);\n            if (deprecatedUsage) {\n                warnOfDeprecatedValueAssignment();\n            }\n            if (unescaped === this._value && quoteMark === this._quoteMark) {\n                return;\n            }\n            this._value = unescaped;\n            this._quoteMark = quoteMark;\n            this._syncRawValue();\n        } else {\n            this._value = v;\n        }\n    }\n\n    get attribute () {\n        return this._attribute;\n    }\n\n    set attribute (name) {\n        this._handleEscapes(\"attribute\", name);\n        this._attribute = name;\n    }\n\n    _handleEscapes (prop, value) {\n        if (this._constructed) {\n            const escaped = cssesc(value, {isIdentifier: true});\n            if (escaped !== value) {\n                this.raws[prop] = escaped;\n            } else {\n                delete this.raws[prop];\n            }\n        }\n    }\n\n    _spacesFor (name) {\n        const attrSpaces = {before: '', after: ''};\n        const spaces = this.spaces[name] || {};\n        const rawSpaces = (this.raws.spaces && this.raws.spaces[name]) || {};\n        return Object.assign(attrSpaces, spaces, rawSpaces);\n    }\n\n    _stringFor (name, spaceName = name, concat = defaultAttrConcat) {\n        const attrSpaces = this._spacesFor(spaceName);\n        return concat(this.stringifyProperty(name), attrSpaces);\n    }\n\n    /**\n     * returns the offset of the attribute part specified relative to the\n     * start of the node of the output string.\n     *\n     * * \"ns\" - alias for \"namespace\"\n     * * \"namespace\" - the namespace if it exists.\n     * * \"attribute\" - the attribute name\n     * * \"attributeNS\" - the start of the attribute or its namespace\n     * * \"operator\" - the match operator of the attribute\n     * * \"value\" - The value (string or identifier)\n     * * \"insensitive\" - the case insensitivity flag;\n     * @param part One of the possible values inside an attribute.\n     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n     */\n    offsetOf (name) {\n        let count = 1;\n        const attributeSpaces = this._spacesFor(\"attribute\");\n        count += attributeSpaces.before.length;\n        if (name === \"namespace\" || name === \"ns\") {\n            return (this.namespace) ? count : -1;\n        }\n        if (name === \"attributeNS\") {\n            return count;\n        }\n\n        count += this.namespaceString.length;\n        if (this.namespace) {\n            count += 1;\n        }\n        if (name === \"attribute\") {\n            return count;\n        }\n\n        count += this.stringifyProperty(\"attribute\").length;\n        count += attributeSpaces.after.length;\n        const operatorSpaces = this._spacesFor(\"operator\");\n        count += operatorSpaces.before.length;\n        const operator = this.stringifyProperty(\"operator\");\n        if (name === \"operator\") {\n            return operator ? count : -1;\n        }\n\n        count += operator.length;\n        count += operatorSpaces.after.length;\n        const valueSpaces = this._spacesFor(\"value\");\n        count += valueSpaces.before.length;\n        const value = this.stringifyProperty(\"value\");\n        if (name === \"value\") {\n            return value ? count : -1;\n        }\n\n        count += value.length;\n        count += valueSpaces.after.length;\n        const insensitiveSpaces = this._spacesFor(\"insensitive\");\n        count += insensitiveSpaces.before.length;\n        if (name === \"insensitive\") {\n            return (this.insensitive) ? count : -1;\n        }\n        return -1;\n    }\n\n    toString () {\n        const selector = [\n            this.rawSpaceBefore,\n            '[',\n        ];\n\n        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n        if (this.operator && (this.value || this.value === '')) {\n            selector.push(this._stringFor('operator'));\n            selector.push(this._stringFor('value'));\n            selector.push(this._stringFor('insensitiveFlag', 'insensitive', (attrValue, attrSpaces) => {\n                if (attrValue.length > 0\n                    && !this.quoted\n                    && attrSpaces.before.length === 0\n                    && !(this.spaces.value && this.spaces.value.after)) {\n\n                    attrSpaces.before = \" \";\n                }\n                return defaultAttrConcat(attrValue, attrSpaces);\n            }));\n        }\n\n        selector.push(']');\n        selector.push(this.rawSpaceAfter);\n        return selector.join('');\n    }\n}\n\nconst CSSESC_QUOTE_OPTIONS = {\n    \"'\": {quotes: 'single', wrap: true},\n    '\"': {quotes: 'double', wrap: true},\n    [null]: {isIdentifier: true},\n};\n\nfunction defaultAttrConcat (attrValue, attrSpaces) {\n    return `${attrSpaces.before}${attrValue}${attrSpaces.after}`;\n}\n", "import Namespace from './namespace';\nimport {UNIVERSAL} from './types';\n\nexport default class Universal extends Namespace {\n    constructor (opts) {\n        super(opts);\n        this.type = UNIVERSAL;\n        this.value = '*';\n    }\n}\n", "import Node from './node';\nimport {COMBINATOR} from './types';\n\nexport default class Combinator extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = COMBINATOR;\n    }\n}\n", "import Node from './node';\nimport {NESTING} from './types';\n\nexport default class Nesting extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = NESTING;\n        this.value = '&';\n    }\n}\n", "export default function sortAscending (list) {\n    return list.sort((a, b) => a - b);\n};\n", "export const ampersand        = 38; // `&`.charCodeAt(0);\nexport const asterisk         = 42; // `*`.charCodeAt(0);\nexport const at               = 64; // `@`.charCodeAt(0);\nexport const comma            = 44; // `,`.charCodeAt(0);\nexport const colon            = 58; // `:`.charCodeAt(0);\nexport const semicolon        = 59; // `;`.charCodeAt(0);\nexport const openParenthesis  = 40; // `(`.charCodeAt(0);\nexport const closeParenthesis = 41; // `)`.charCodeAt(0);\nexport const openSquare       = 91; // `[`.charCodeAt(0);\nexport const closeSquare      = 93; // `]`.charCodeAt(0);\nexport const dollar           = 36; // `$`.charCodeAt(0);\nexport const tilde            = 126; // `~`.charCodeAt(0);\nexport const caret            = 94; // `^`.charCodeAt(0);\nexport const plus             = 43; // `+`.charCodeAt(0);\nexport const equals           = 61; // `=`.charCodeAt(0);\nexport const pipe             = 124; // `|`.charCodeAt(0);\nexport const greaterThan      = 62; // `>`.charCodeAt(0);\nexport const space            = 32; // ` `.charCodeAt(0);\nexport const singleQuote      = 39; // `'`.charCodeAt(0);\nexport const doubleQuote      = 34; // `\"`.charCodeAt(0);\nexport const slash            = 47; // `/`.charCodeAt(0);\nexport const bang             = 33; // `!`.charCodeAt(0);\n\nexport const backslash        = 92; // '\\\\'.charCodeAt(0);\nexport const cr               = 13; // '\\r'.charCodeAt(0);\nexport const feed             = 12; // '\\f'.charCodeAt(0);\nexport const newline          = 10; // '\\n'.charCodeAt(0);\nexport const tab              = 9; // '\\t'.charCodeAt(0);\n\n// Expose aliases primarily for readability.\nexport const str              = singleQuote;\n\n// No good single character representation!\nexport const comment          = -1;\nexport const word             = -2;\nexport const combinator       = -3;\n", "import * as t from './tokenTypes';\n\nconst unescapable = {\n    [t.tab]: true,\n    [t.newline]: true,\n    [t.cr]: true,\n    [t.feed]: true,\n};\nconst wordDelimiters = {\n    [t.space]: true,\n    [t.tab]: true,\n    [t.newline]: true,\n    [t.cr]: true,\n    [t.feed]: true,\n\n    [t.ampersand]: true,\n    [t.asterisk]: true,\n    [t.bang]: true,\n    [t.comma]: true,\n    [t.colon]: true,\n    [t.semicolon]: true,\n    [t.openParenthesis]: true,\n    [t.closeParenthesis]: true,\n    [t.openSquare]: true,\n    [t.closeSquare]: true,\n    [t.singleQuote]: true,\n    [t.doubleQuote]: true,\n    [t.plus]: true,\n    [t.pipe]: true,\n    [t.tilde]: true,\n    [t.greaterThan]: true,\n    [t.equals]: true,\n    [t.dollar]: true,\n    [t.caret]: true,\n    [t.slash]: true,\n};\n\n\nconst hex = {};\nconst hexChars = \"0123456789abcdefABCDEF\";\nfor (let i = 0; i < hexChars.length; i++) {\n    hex[hexChars.charCodeAt(i)] = true;\n}\n\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\nfunction consumeWord (css, start) {\n    let next = start;\n    let code;\n    do {\n        code = css.charCodeAt(next);\n        if (wordDelimiters[code]) {\n            return next - 1;\n        } else if (code === t.backslash) {\n            next = consumeEscape(css, next) + 1;\n        } else {\n            // All other characters are part of the word\n            next++;\n        }\n    } while (next < css.length);\n    return next - 1;\n}\n\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\nfunction consumeEscape (css, start) {\n    let next = start;\n    let code = css.charCodeAt(next + 1);\n    if (unescapable[code]) {\n        // just consume the escape char\n    } else if (hex[code]) {\n        let hexDigits = 0;\n        // consume up to 6 hex chars\n        do {\n            next++;\n            hexDigits++;\n            code = css.charCodeAt(next + 1);\n        } while (hex[code] && hexDigits < 6);\n        // if fewer than 6 hex chars, a trailing space ends the escape\n        if (hexDigits < 6 && code === t.space) {\n            next++;\n        }\n    } else {\n        // the next char is part of the current word\n        next++;\n    }\n    return next;\n}\n\nexport const FIELDS = {\n    TYPE: 0,\n    START_LINE: 1,\n    START_COL: 2,\n    END_LINE: 3,\n    END_COL: 4,\n    START_POS: 5,\n    END_POS: 6,\n};\n\nexport default function tokenize (input) {\n    const tokens   = [];\n    let css        = input.css.valueOf();\n    let {length}   = css;\n    let offset     = -1;\n    let line       =  1;\n    let start      =  0;\n    let end        =  0;\n\n    let code,\n        content,\n        endColumn,\n        endLine,\n        escaped,\n        escapePos,\n        last,\n        lines,\n        next,\n        nextLine,\n        nextOffset,\n        quote,\n        tokenType;\n\n    function unclosed (what, fix) {\n        if ( input.safe ) { // fyi: this is never set to true.\n            css += fix;\n            next = css.length - 1;\n        } else {\n            throw input.error('Unclosed ' + what, line, start - offset, start);\n        }\n    }\n\n    while ( start < length ) {\n        code = css.charCodeAt(start);\n\n        if ( code === t.newline ) {\n            offset = start;\n            line  += 1;\n        }\n\n        switch ( code ) {\n        case t.space:\n        case t.tab:\n        case t.newline:\n        case t.cr:\n        case t.feed:\n            next = start;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n                if ( code === t.newline ) {\n                    offset = next;\n                    line  += 1;\n                }\n            } while (\n                code === t.space   ||\n                code === t.newline ||\n                code === t.tab     ||\n                code === t.cr      ||\n                code === t.feed\n            );\n\n            tokenType = t.space;\n            endLine = line;\n            endColumn = next - offset - 1;\n            end = next;\n            break;\n\n        case t.plus:\n        case t.greaterThan:\n        case t.tilde:\n        case t.pipe:\n            next = start;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n            } while (\n                code === t.plus        ||\n                code === t.greaterThan ||\n                code === t.tilde       ||\n                code === t.pipe\n            );\n\n            tokenType = t.combinator;\n            endLine = line;\n            endColumn = start - offset;\n            end = next;\n            break;\n\n        // Consume these characters as single tokens.\n        case t.asterisk:\n        case t.ampersand:\n        case t.bang:\n        case t.comma:\n        case t.equals:\n        case t.dollar:\n        case t.caret:\n        case t.openSquare:\n        case t.closeSquare:\n        case t.colon:\n        case t.semicolon:\n        case t.openParenthesis:\n        case t.closeParenthesis:\n            next = start;\n            tokenType = code;\n            endLine = line;\n            endColumn = start - offset;\n            end = next + 1;\n            break;\n\n        case t.singleQuote:\n        case t.doubleQuote:\n            quote = code === t.singleQuote ? \"'\" : '\"';\n            next  = start;\n            do {\n                escaped = false;\n                next    = css.indexOf(quote, next + 1);\n                if ( next === -1 ) {\n                    unclosed('quote', quote);\n                }\n                escapePos = next;\n                while ( css.charCodeAt(escapePos - 1) === t.backslash ) {\n                    escapePos -= 1;\n                    escaped = !escaped;\n                }\n            } while ( escaped );\n\n            tokenType = t.str;\n            endLine = line;\n            endColumn = start - offset;\n            end = next + 1;\n            break;\n\n        default:\n            if ( code === t.slash && css.charCodeAt(start + 1) === t.asterisk ) {\n                next = css.indexOf('*/', start + 2) + 1;\n                if ( next === 0 ) {\n                    unclosed('comment', '*/');\n                }\n\n                content = css.slice(start, next + 1);\n                lines   = content.split('\\n');\n                last    = lines.length - 1;\n\n                if ( last > 0 ) {\n                    nextLine   = line + last;\n                    nextOffset = next - lines[last].length;\n                } else {\n                    nextLine   = line;\n                    nextOffset = offset;\n                }\n\n                tokenType = t.comment;\n                line   = nextLine;\n                endLine = nextLine;\n                endColumn = next - nextOffset;\n            } else if (code === t.slash) {\n                next = start;\n                tokenType = code;\n                endLine = line;\n                endColumn = start - offset;\n                end = next + 1;\n            } else {\n                next = consumeWord(css, start);\n                tokenType = t.word;\n                endLine = line;\n                endColumn = next - offset;\n            }\n\n            end = next + 1;\n            break;\n        }\n\n        // Ensure that the token structure remains consistent\n        tokens.push([\n            tokenType,              // [0] Token type\n            line,                   // [1] Starting line\n            start - offset,         // [2] Starting column\n            endLine,                // [3] Ending line\n            endColumn,              // [4] Ending column\n            start,                  // [5] Start position / Source index\n            end,                    // [6] End position\n        ]);\n\n        // Reset offset for the next token\n        if (nextOffset) {\n            offset = nextOffset;\n            nextOffset = null;\n        }\n\n        start = end;\n    }\n\n    return tokens;\n}\n", "import Root from './selectors/root';\nimport Selector from './selectors/selector';\nimport ClassName from './selectors/className';\nimport Comment from './selectors/comment';\nimport ID from './selectors/id';\nimport Tag from './selectors/tag';\nimport Str from './selectors/string';\nimport Pseudo from './selectors/pseudo';\nimport Attribute, {unescapeValue} from './selectors/attribute';\nimport Universal from './selectors/universal';\nimport Combinator from './selectors/combinator';\nimport Nesting from './selectors/nesting';\n\nimport sortAsc from './sortAscending';\nimport tokenize, {FIELDS as TOKEN} from './tokenize';\n\nimport * as tokens from './tokenTypes';\nimport * as types from './selectors/types';\nimport {unesc, getProp, ensureObject} from './util';\n\nconst WHITESPACE_TOKENS = {\n    [tokens.space]: true,\n    [tokens.cr]: true,\n    [tokens.feed]: true,\n    [tokens.newline]: true,\n    [tokens.tab]: true,\n};\n\nconst WHITESPACE_EQUIV_TOKENS = {\n    ...WHITESPACE_TOKENS,\n    [tokens.comment]: true,\n};\n\nfunction tokenStart (token) {\n    return {\n        line: token[TOKEN.START_LINE],\n        column: token[TOKEN.START_COL],\n    };\n}\n\nfunction tokenEnd (token) {\n    return {\n        line: token[TOKEN.END_LINE],\n        column: token[TOKEN.END_COL],\n    };\n}\n\n\nfunction getSource (startLine, startColumn, endLine, endColumn) {\n    return {\n        start: {\n            line: startLine,\n            column: startColumn,\n        },\n        end: {\n            line: endLine,\n            column: endColumn,\n        },\n    };\n}\n\nfunction getTokenSource (token) {\n    return getSource(\n        token[TOKEN.START_LINE],\n        token[TOKEN.START_COL],\n        token[TOKEN.END_LINE],\n        token[TOKEN.END_COL]\n    );\n}\n\nfunction getTokenSourceSpan (startToken, endToken) {\n    if (!startToken) {\n        return undefined;\n    }\n    return getSource(\n        startToken[TOKEN.START_LINE],\n        startToken[TOKEN.START_COL],\n        endToken[TOKEN.END_LINE],\n        endToken[TOKEN.END_COL]\n    );\n}\n\nfunction unescapeProp (node, prop) {\n    let value = node[prop];\n    if (typeof value !== \"string\") {\n        return;\n    }\n    if (value.indexOf(\"\\\\\") !== -1) {\n        ensureObject(node, 'raws');\n        node[prop] = unesc(value);\n        if (node.raws[prop] === undefined) {\n            node.raws[prop] = value;\n        }\n    }\n    return node;\n}\n\nfunction indexesOf (array, item) {\n    let i = -1;\n    const indexes = [];\n\n    while ((i = array.indexOf(item, i + 1)) !== -1) {\n        indexes.push(i);\n    }\n\n    return indexes;\n}\n\nfunction uniqs () {\n    const list = Array.prototype.concat.apply([], arguments);\n\n    return list.filter((item, i) => i === list.indexOf(item));\n}\n\nexport default class Parser {\n    constructor (rule, options = {}) {\n        this.rule = rule;\n        this.options = Object.assign({lossy: false, safe: false}, options);\n        this.position = 0;\n\n        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\n        this.tokens = tokenize({\n            css: this.css,\n            error: this._errorGenerator(),\n            safe: this.options.safe,\n        });\n\n        let rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n        this.root = new Root({source: rootSource});\n        this.root.errorGenerator = this._errorGenerator();\n\n\n        const selector = new Selector({\n            source: {start: {line: 1, column: 1}},\n            sourceIndex: 0,\n        });\n        this.root.append(selector);\n        this.current = selector;\n\n        this.loop();\n    }\n\n    _errorGenerator () {\n        return (message, errorOptions) => {\n            if (typeof this.rule === 'string') {\n                return new Error(message);\n            }\n            return this.rule.error(message, errorOptions);\n        };\n    }\n\n    attribute () {\n        const attr = [];\n        const startingToken = this.currToken;\n        this.position ++;\n        while (\n            this.position < this.tokens.length &&\n            this.currToken[TOKEN.TYPE] !== tokens.closeSquare\n        ) {\n            attr.push(this.currToken);\n            this.position ++;\n        }\n        if (this.currToken[TOKEN.TYPE] !== tokens.closeSquare) {\n            return this.expected('closing square bracket', this.currToken[TOKEN.START_POS]);\n        }\n\n        const len = attr.length;\n        const node = {\n            source: getSource(\n                startingToken[1],\n                startingToken[2],\n                this.currToken[3],\n                this.currToken[4]\n            ),\n            sourceIndex: startingToken[TOKEN.START_POS],\n        };\n\n        if (len === 1 && !~[tokens.word].indexOf(attr[0][TOKEN.TYPE])) {\n            return this.expected('attribute', attr[0][TOKEN.START_POS]);\n        }\n\n        let pos = 0;\n        let spaceBefore = '';\n        let commentBefore = '';\n        let lastAdded = null;\n        let spaceAfterMeaningfulToken = false;\n\n        while (pos < len) {\n            const token = attr[pos];\n            const content = this.content(token);\n            const next = attr[pos + 1];\n\n            switch (token[TOKEN.TYPE]) {\n            case tokens.space:\n                // if (\n                //     len === 1 ||\n                //     pos === 0 && this.content(next) === '|'\n                // ) {\n                //     return this.expected('attribute', token[TOKEN.START_POS], content);\n                // }\n                spaceAfterMeaningfulToken = true;\n                if (this.options.lossy) {\n                    break;\n                }\n                if (lastAdded) {\n                    ensureObject(node, 'spaces', lastAdded);\n                    const prevContent = node.spaces[lastAdded].after || '';\n                    node.spaces[lastAdded].after = prevContent + content;\n\n                    const existingComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n                    if (existingComment) {\n                        node.raws.spaces[lastAdded].after = existingComment + content;\n                    }\n                } else {\n                    spaceBefore = spaceBefore + content;\n                    commentBefore = commentBefore + content;\n                }\n                break;\n            case tokens.asterisk:\n                if (next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                } else if ((!node.namespace || (lastAdded === \"namespace\" && !spaceAfterMeaningfulToken)) && next) {\n                    if (spaceBefore) {\n                        ensureObject(node, 'spaces', 'attribute');\n                        node.spaces.attribute.before = spaceBefore;\n                        spaceBefore = '';\n                    }\n                    if (commentBefore) {\n                        ensureObject(node, 'raws', 'spaces', 'attribute');\n                        node.raws.spaces.attribute.before = spaceBefore;\n                        commentBefore = '';\n                    }\n                    node.namespace = (node.namespace || \"\") + content;\n                    const rawValue = getProp(node, 'raws', 'namespace') || null;\n                    if (rawValue) {\n                        node.raws.namespace += content;\n                    }\n                    lastAdded = 'namespace';\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.dollar:\n                if (lastAdded === \"value\") {\n                    let oldRawValue = getProp(node, 'raws', 'value');\n                    node.value += \"$\";\n                    if (oldRawValue) {\n                        node.raws.value = oldRawValue + \"$\";\n                    }\n                    break;\n                }\n                // Falls through\n            case tokens.caret:\n                if (next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.combinator:\n                if (content === '~' && next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                }\n                if (content !== '|') {\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                }\n                if (next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                } else if (!node.namespace && !node.attribute) {\n                    node.namespace = true;\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.word:\n                if (\n                    next &&\n                    this.content(next) === '|' &&\n                    (attr[pos + 2] && attr[pos + 2][TOKEN.TYPE] !== tokens.equals) && // this look-ahead probably fails with comment nodes involved.\n                    !node.operator &&\n                    !node.namespace\n                ) {\n                    node.namespace = content;\n                    lastAdded = 'namespace';\n                } else if (!node.attribute || (lastAdded === \"attribute\" && !spaceAfterMeaningfulToken)) {\n                    if (spaceBefore) {\n                        ensureObject(node, 'spaces', 'attribute');\n                        node.spaces.attribute.before = spaceBefore;\n\n                        spaceBefore = '';\n                    }\n                    if (commentBefore) {\n                        ensureObject(node, 'raws', 'spaces', 'attribute');\n                        node.raws.spaces.attribute.before = commentBefore;\n                        commentBefore = '';\n                    }\n                    node.attribute = (node.attribute || \"\") + content;\n                    const rawValue = getProp(node, 'raws', 'attribute') || null;\n                    if (rawValue) {\n                        node.raws.attribute += content;\n                    }\n                    lastAdded = 'attribute';\n                } else if ((!node.value && node.value !== \"\") || (lastAdded === \"value\" && !(spaceAfterMeaningfulToken || node.quoteMark))) {\n                    let unescaped = unesc(content);\n                    let oldRawValue = getProp(node, 'raws', 'value') || '';\n                    let oldValue = node.value || '';\n                    node.value = oldValue + unescaped;\n                    node.quoteMark = null;\n                    if (unescaped !== content || oldRawValue) {\n                        ensureObject(node, 'raws');\n                        node.raws.value = (oldRawValue || oldValue) + content;\n                    }\n                    lastAdded = 'value';\n                } else {\n                    let insensitive = (content === 'i' || content === \"I\");\n                    if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n                        node.insensitive = insensitive;\n                        if (!insensitive || content === \"I\") {\n                            ensureObject(node, 'raws');\n                            node.raws.insensitiveFlag = content;\n                        }\n                        lastAdded = 'insensitive';\n                        if (spaceBefore) {\n                            ensureObject(node, 'spaces', 'insensitive');\n                            node.spaces.insensitive.before = spaceBefore;\n\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            ensureObject(node, 'raws', 'spaces', 'insensitive');\n                            node.raws.spaces.insensitive.before = commentBefore;\n                            commentBefore = '';\n                        }\n                    } else if (node.value || node.value === '') {\n                        lastAdded = 'value';\n                        node.value += content;\n                        if (node.raws.value) {\n                            node.raws.value += content;\n                        }\n                    }\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.str:\n                if (!node.attribute || !node.operator) {\n                    return this.error(`Expected an attribute followed by an operator preceding the string.`, {\n                        index: token[TOKEN.START_POS],\n                    });\n                }\n                let {unescaped, quoteMark} = unescapeValue(content);\n                node.value = unescaped;\n                node.quoteMark = quoteMark;\n                lastAdded = 'value';\n\n                ensureObject(node, 'raws');\n                node.raws.value = content;\n\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.equals:\n                if (!node.attribute) {\n                    return this.expected('attribute', token[TOKEN.START_POS], content);\n                }\n                if (node.value) {\n                    return this.error('Unexpected \"=\" found; an operator was already defined.', {index: token[TOKEN.START_POS]});\n                }\n                node.operator = node.operator ? node.operator + content : content;\n                lastAdded = 'operator';\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.comment:\n                if (lastAdded) {\n                    if (spaceAfterMeaningfulToken || (next && next[TOKEN.TYPE] === tokens.space) ||\n                        lastAdded === 'insensitive'\n                    ) {\n                        const lastComment = getProp(node, 'spaces', lastAdded, 'after') || '';\n                        const rawLastComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n\n                        ensureObject(node, 'raws', 'spaces', lastAdded);\n                        node.raws.spaces[lastAdded].after = rawLastComment + content;\n                    } else {\n                        const lastValue = node[lastAdded] || '';\n                        const rawLastValue = getProp(node, 'raws', lastAdded) || lastValue;\n                        ensureObject(node, 'raws');\n                        node.raws[lastAdded] = rawLastValue + content;\n                    }\n                } else {\n                    commentBefore = commentBefore + content;\n                }\n                break;\n            default:\n                return this.error(`Unexpected \"${content}\" found.`, {index: token[TOKEN.START_POS]});\n            }\n            pos ++;\n        }\n        unescapeProp(node, \"attribute\");\n        unescapeProp(node, \"namespace\");\n        this.newNode(new Attribute(node));\n        this.position ++;\n    }\n\n    /**\n     * return a node containing meaningless garbage up to (but not including) the specified token position.\n     * if the token position is negative, all remaining tokens are consumed.\n     *\n     * This returns an array containing a single string node if all whitespace,\n     * otherwise an array of comment nodes with space before and after.\n     *\n     * These tokens are not added to the current selector, the caller can add them or use them to amend\n     * a previous node's space metadata.\n     *\n     * In lossy mode, this returns only comments.\n     */\n    parseWhitespaceEquivalentTokens (stopPosition) {\n        if (stopPosition < 0) {\n            stopPosition = this.tokens.length;\n        }\n        let startPosition = this.position;\n        let nodes = [];\n        let space = \"\";\n        let lastComment = undefined;\n        do {\n            if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\n                if (!this.options.lossy) {\n                    space += this.content();\n                }\n            } else if (this.currToken[TOKEN.TYPE] === tokens.comment) {\n                let spaces = {};\n                if (space) {\n                    spaces.before = space;\n                    space = \"\";\n                }\n                lastComment = new Comment({\n                    value: this.content(),\n                    source: getTokenSource(this.currToken),\n                    sourceIndex: this.currToken[TOKEN.START_POS],\n                    spaces,\n                });\n                nodes.push(lastComment);\n            }\n        } while (++this.position < stopPosition);\n\n        if (space) {\n            if (lastComment) {\n                lastComment.spaces.after = space;\n            } else if (!this.options.lossy) {\n                let firstToken = this.tokens[startPosition];\n                let lastToken = this.tokens[this.position - 1];\n                nodes.push(new Str({\n                    value: '',\n                    source: getSource(\n                        firstToken[TOKEN.START_LINE],\n                        firstToken[TOKEN.START_COL],\n                        lastToken[TOKEN.END_LINE],\n                        lastToken[TOKEN.END_COL],\n                    ),\n                    sourceIndex: firstToken[TOKEN.START_POS],\n                    spaces: {before: space, after: ''},\n                }));\n            }\n        }\n        return nodes;\n    }\n\n    /**\n     *\n     * @param {*} nodes\n     */\n    convertWhitespaceNodesToSpace (nodes, requiredSpace = false) {\n        let space = \"\";\n        let rawSpace = \"\";\n        nodes.forEach(n => {\n            let spaceBefore = this.lossySpace(n.spaces.before, requiredSpace);\n            let rawSpaceBefore = this.lossySpace(n.rawSpaceBefore, requiredSpace);\n            space += spaceBefore + this.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n            rawSpace += spaceBefore + n.value + this.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n        });\n        if (rawSpace === space) {\n            rawSpace = undefined;\n        }\n        let result = {space, rawSpace};\n        return result;\n    }\n\n    isNamedCombinator (position = this.position) {\n        return this.tokens[position + 0] && this.tokens[position + 0][TOKEN.TYPE] === tokens.slash &&\n               this.tokens[position + 1] && this.tokens[position + 1][TOKEN.TYPE] === tokens.word &&\n               this.tokens[position + 2] && this.tokens[position + 2][TOKEN.TYPE] === tokens.slash;\n\n    }\n    namedCombinator () {\n        if (this.isNamedCombinator()) {\n            let nameRaw = this.content(this.tokens[this.position + 1]);\n            let name = unesc(nameRaw).toLowerCase();\n            let raws = {};\n            if (name !== nameRaw) {\n                raws.value = `/${nameRaw}/`;\n            }\n            let node = new Combinator({\n                value: `/${name}/`,\n                source: getSource(\n                    this.currToken[TOKEN.START_LINE],\n                    this.currToken[TOKEN.START_COL],\n                    this.tokens[this.position + 2][TOKEN.END_LINE],\n                    this.tokens[this.position + 2][TOKEN.END_COL],\n                ),\n                sourceIndex: this.currToken[TOKEN.START_POS],\n                raws,\n            });\n            this.position = this.position + 3;\n            return node;\n        } else {\n            this.unexpected();\n        }\n    }\n\n    combinator () {\n        if (this.content() === '|') {\n            return this.namespace();\n        }\n        // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n        let nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.closeParenthesis) {\n            let nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n            if (nodes.length > 0) {\n                let last = this.current.last;\n                if (last) {\n                    let {space, rawSpace} = this.convertWhitespaceNodesToSpace(nodes);\n                    if (rawSpace !== undefined) {\n                        last.rawSpaceAfter += rawSpace;\n                    }\n                    last.spaces.after += space;\n                } else {\n                    nodes.forEach(n => this.newNode(n));\n                }\n            }\n            return;\n        }\n\n        let firstToken = this.currToken;\n        let spaceOrDescendantSelectorNodes = undefined;\n        if (nextSigTokenPos > this.position) {\n            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n        }\n\n        let node;\n        if (this.isNamedCombinator()) {\n            node = this.namedCombinator();\n        } else if (this.currToken[TOKEN.TYPE] === tokens.combinator) {\n            node = new Combinator({\n                value: this.content(),\n                source: getTokenSource(this.currToken),\n                sourceIndex: this.currToken[TOKEN.START_POS],\n            });\n            this.position++;\n        } else if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\n            // pass\n        } else if (!spaceOrDescendantSelectorNodes) {\n            this.unexpected();\n        }\n\n        if (node) {\n            if (spaceOrDescendantSelectorNodes) {\n                let {space, rawSpace} = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes);\n                node.spaces.before = space;\n                node.rawSpaceBefore = rawSpace;\n            }\n        } else {\n            // descendant combinator\n            let {space, rawSpace} = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true);\n            if (!rawSpace) {\n                rawSpace = space;\n            }\n            let spaces = {};\n            let raws = {spaces: {}};\n            if (space.endsWith(' ') && rawSpace.endsWith(' ')) {\n                spaces.before = space.slice(0, space.length - 1);\n                raws.spaces.before = rawSpace.slice(0, rawSpace.length - 1);\n            } else if (space.startsWith(' ') && rawSpace.startsWith(' ')) {\n                spaces.after = space.slice(1);\n                raws.spaces.after = rawSpace.slice(1);\n            } else {\n                raws.value = rawSpace;\n            }\n            node = new Combinator({\n                value: ' ',\n                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n                sourceIndex: firstToken[TOKEN.START_POS],\n                spaces,\n                raws,\n            });\n        }\n\n        if (this.currToken && this.currToken[TOKEN.TYPE] === tokens.space) {\n            node.spaces.after = this.optionalSpace(this.content());\n            this.position++;\n        }\n\n        return this.newNode(node);\n    }\n\n    comma () {\n        if (this.position === this.tokens.length - 1) {\n            this.root.trailingComma = true;\n            this.position ++;\n            return;\n        }\n        this.current._inferEndPosition();\n        const selector = new Selector({\n            source: {\n                start: tokenStart(this.tokens[this.position + 1]),\n            },\n            sourceIndex: this.tokens[this.position + 1][TOKEN.START_POS],\n        });\n        this.current.parent.append(selector);\n        this.current = selector;\n        this.position ++;\n    }\n\n    comment () {\n        const current = this.currToken;\n        this.newNode(new Comment({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }));\n        this.position ++;\n    }\n\n    error (message, opts) {\n        throw this.root.error(message, opts);\n    }\n\n    missingBackslash () {\n        return this.error('Expected a backslash preceding the semicolon.', {\n            index: this.currToken[TOKEN.START_POS],\n        });\n    }\n\n    missingParenthesis () {\n        return this.expected('opening parenthesis', this.currToken[TOKEN.START_POS]);\n    }\n\n    missingSquareBracket () {\n        return this.expected('opening square bracket', this.currToken[TOKEN.START_POS]);\n    }\n\n    unexpected () {\n        return this.error(`Unexpected '${this.content()}'. Escaping special characters with \\\\ may help.`, this.currToken[TOKEN.START_POS]);\n    }\n\n    unexpectedPipe () {\n        return this.error(`Unexpected '|'.`, this.currToken[TOKEN.START_POS]);\n    }\n\n    namespace () {\n        const before = this.prevToken && this.content(this.prevToken) || true;\n        if (this.nextToken[TOKEN.TYPE] === tokens.word) {\n            this.position ++;\n            return this.word(before);\n        } else if (this.nextToken[TOKEN.TYPE] === tokens.asterisk) {\n            this.position ++;\n            return this.universal(before);\n        }\n\n        this.unexpectedPipe();\n    }\n\n    nesting () {\n        if (this.nextToken) {\n            let nextContent = this.content(this.nextToken);\n            if (nextContent === \"|\") {\n                this.position++;\n                return;\n            }\n        }\n        const current = this.currToken;\n        this.newNode(new Nesting({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }));\n        this.position ++;\n    }\n\n    parentheses () {\n        let last = this.current.last;\n        let unbalanced = 1;\n        this.position ++;\n        if (last && last.type === types.PSEUDO) {\n            const selector = new Selector({\n                source: {start: tokenStart(this.tokens[this.position])},\n                sourceIndex: this.tokens[this.position][TOKEN.START_POS],\n            });\n            const cache = this.current;\n            last.append(selector);\n            this.current = selector;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\n                    unbalanced ++;\n                }\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\n                    unbalanced --;\n                }\n                if (unbalanced) {\n                    this.parse();\n                } else {\n                    this.current.source.end = tokenEnd(this.currToken);\n                    this.current.parent.source.end = tokenEnd(this.currToken);\n                    this.position ++;\n                }\n            }\n            this.current = cache;\n        } else {\n            // I think this case should be an error. It's used to implement a basic parse of media queries\n            // but I don't think it's a good idea.\n            let parenStart = this.currToken;\n            let parenValue = \"(\";\n            let parenEnd;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\n                    unbalanced ++;\n                }\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\n                    unbalanced --;\n                }\n                parenEnd = this.currToken;\n                parenValue += this.parseParenthesisToken(this.currToken);\n                this.position ++;\n            }\n            if (last) {\n                last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n            } else {\n                this.newNode(new Str({\n                    value: parenValue,\n                    source: getSource(\n                        parenStart[TOKEN.START_LINE],\n                        parenStart[TOKEN.START_COL],\n                        parenEnd[TOKEN.END_LINE],\n                        parenEnd[TOKEN.END_COL],\n                    ),\n                    sourceIndex: parenStart[TOKEN.START_POS],\n                }));\n            }\n        }\n        if (unbalanced) {\n            return this.expected('closing parenthesis', this.currToken[TOKEN.START_POS]);\n        }\n    }\n\n    pseudo () {\n        let pseudoStr = '';\n        let startingToken = this.currToken;\n        while (this.currToken && this.currToken[TOKEN.TYPE] === tokens.colon) {\n            pseudoStr += this.content();\n            this.position ++;\n        }\n        if (!this.currToken) {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n        }\n        if (this.currToken[TOKEN.TYPE] === tokens.word) {\n            this.splitWord(false, (first, length) => {\n                pseudoStr += first;\n                this.newNode(new Pseudo({\n                    value: pseudoStr,\n                    source: getTokenSourceSpan(startingToken, this.currToken),\n                    sourceIndex: startingToken[TOKEN.START_POS],\n                }));\n                if (\n                    length > 1 &&\n                    this.nextToken &&\n                    this.nextToken[TOKEN.TYPE] === tokens.openParenthesis\n                ) {\n                    this.error('Misplaced parenthesis.', {\n                        index: this.nextToken[TOKEN.START_POS],\n                    });\n                }\n            });\n        } else {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[TOKEN.START_POS]);\n        }\n    }\n\n    space () {\n        const content = this.content();\n        // Handle space before and after the selector\n        if (\n            this.position === 0 ||\n            this.prevToken[TOKEN.TYPE] === tokens.comma ||\n            this.prevToken[TOKEN.TYPE] === tokens.openParenthesis ||\n            (this.current.nodes.every((node) => node.type === 'comment'))\n        ) {\n            this.spaces = this.optionalSpace(content);\n            this.position ++;\n        } else if (\n            this.position === (this.tokens.length - 1) ||\n            this.nextToken[TOKEN.TYPE] === tokens.comma ||\n            this.nextToken[TOKEN.TYPE] === tokens.closeParenthesis\n        ) {\n            this.current.last.spaces.after = this.optionalSpace(content);\n            this.position ++;\n        } else {\n            this.combinator();\n        }\n    }\n\n    string () {\n        const current = this.currToken;\n        this.newNode(new Str({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }));\n        this.position ++;\n    }\n\n    universal (namespace) {\n        const nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position ++;\n            return this.namespace();\n        }\n        const current = this.currToken;\n        this.newNode(new Universal({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }), namespace);\n        this.position ++;\n    }\n\n    splitWord (namespace, firstCallback) {\n        let nextToken = this.nextToken;\n        let word = this.content();\n        while (\n            nextToken &&\n            ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[TOKEN.TYPE])\n        ) {\n            this.position ++;\n            let current = this.content();\n            word += current;\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\n                let next = this.nextToken;\n                if (next && next[TOKEN.TYPE] === tokens.space) {\n                    word += this.requiredSpace(this.content(next));\n                    this.position ++;\n                }\n            }\n            nextToken = this.nextToken;\n        }\n        const hasClass = indexesOf(word, '.').filter(i => {\n            // Allow escaped dot within class name\n            const escapedDot = word[i - 1] === '\\\\';\n            // Allow decimal numbers percent in @keyframes\n            const isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n            return !escapedDot && !isKeyframesPercent;\n        });\n        let hasId = indexesOf(word, '#').filter(i => word[i - 1] !== '\\\\');\n        // Eliminate Sass interpolations from the list of id indexes\n        const interpolations = indexesOf(word, '#{');\n        if (interpolations.length) {\n            hasId = hasId.filter(hashIndex => !~interpolations.indexOf(hashIndex));\n        }\n        let indices = sortAsc(uniqs([0, ...hasClass, ...hasId]));\n        indices.forEach((ind, i) => {\n            const index = indices[i + 1] || word.length;\n            const value = word.slice(ind, index);\n            if (i === 0 && firstCallback) {\n                return firstCallback.call(this, value, indices.length);\n            }\n            let node;\n            const current = this.currToken;\n            const sourceIndex = current[TOKEN.START_POS] + indices[i];\n            const source = getSource(\n                current[1],\n                current[2] + ind,\n                current[3],\n                current[2] + (index - 1)\n            );\n            if (~hasClass.indexOf(ind)) {\n                let classNameOpts = {\n                    value: value.slice(1),\n                    source,\n                    sourceIndex,\n                };\n                node = new ClassName(unescapeProp(classNameOpts, \"value\"));\n            } else if (~hasId.indexOf(ind)) {\n                let idOpts = {\n                    value: value.slice(1),\n                    source,\n                    sourceIndex,\n                };\n                node = new ID(unescapeProp(idOpts, \"value\"));\n            } else {\n                let tagOpts = {\n                    value,\n                    source,\n                    sourceIndex,\n                };\n                unescapeProp(tagOpts, \"value\");\n                node = new Tag(tagOpts);\n            }\n            this.newNode(node, namespace);\n            // Ensure that the namespace is used only once\n            namespace = null;\n        });\n        this.position ++;\n    }\n\n    word (namespace) {\n        const nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position ++;\n            return this.namespace();\n        }\n        return this.splitWord(namespace);\n    }\n\n    loop () {\n        while (this.position < this.tokens.length) {\n            this.parse(true);\n        }\n        this.current._inferEndPosition();\n        return this.root;\n    }\n\n    parse (throwOnParenthesis) {\n        switch (this.currToken[TOKEN.TYPE]) {\n        case tokens.space:\n            this.space();\n            break;\n        case tokens.comment:\n            this.comment();\n            break;\n        case tokens.openParenthesis:\n            this.parentheses();\n            break;\n        case tokens.closeParenthesis:\n            if (throwOnParenthesis) {\n                this.missingParenthesis();\n            }\n            break;\n        case tokens.openSquare:\n            this.attribute();\n            break;\n        case tokens.dollar:\n        case tokens.caret:\n        case tokens.equals:\n        case tokens.word:\n            this.word();\n            break;\n        case tokens.colon:\n            this.pseudo();\n            break;\n        case tokens.comma:\n            this.comma();\n            break;\n        case tokens.asterisk:\n            this.universal();\n            break;\n        case tokens.ampersand:\n            this.nesting();\n            break;\n        case tokens.slash:\n        case tokens.combinator:\n            this.combinator();\n            break;\n        case tokens.str:\n            this.string();\n            break;\n        // These cases throw; no break needed.\n        case tokens.closeSquare:\n            this.missingSquareBracket();\n        case tokens.semicolon:\n            this.missingBackslash();\n        default:\n            this.unexpected();\n        }\n    }\n\n    /**\n     * Helpers\n     */\n\n    expected (description, index, found) {\n        if (Array.isArray(description)) {\n            const last = description.pop();\n            description = `${description.join(', ')} or ${last}`;\n        }\n        const an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n        if (!found) {\n            return this.error(\n                `Expected ${an} ${description}.`,\n                {index}\n            );\n        }\n        return this.error(\n            `Expected ${an} ${description}, found \"${found}\" instead.`,\n            {index}\n        );\n    }\n\n    requiredSpace (space) {\n        return this.options.lossy ? ' ' : space;\n    }\n\n    optionalSpace (space) {\n        return this.options.lossy ? '' : space;\n    }\n\n    lossySpace (space, required) {\n        if (this.options.lossy) {\n            return required ? ' ' : '';\n        } else {\n            return space;\n        }\n    }\n\n    parseParenthesisToken (token) {\n        const content = this.content(token);\n        if (token[TOKEN.TYPE] === tokens.space) {\n            return this.requiredSpace(content);\n        } else {\n            return content;\n        }\n    }\n\n    newNode (node, namespace) {\n        if (namespace) {\n            if (/^ +$/.test(namespace)) {\n                if (!this.options.lossy) {\n                    this.spaces = (this.spaces || '') + namespace;\n                }\n                namespace = true;\n            }\n            node.namespace = namespace;\n            unescapeProp(node, \"namespace\");\n        }\n        if (this.spaces) {\n            node.spaces.before = this.spaces;\n            this.spaces = '';\n        }\n        return this.current.append(node);\n    }\n\n    content (token = this.currToken) {\n        return this.css.slice(token[TOKEN.START_POS], token[TOKEN.END_POS]);\n    }\n\n    get currToken () {\n        return this.tokens[this.position];\n    }\n\n    get nextToken () {\n        return this.tokens[this.position + 1];\n    }\n\n    get prevToken () {\n        return this.tokens[this.position - 1];\n    }\n\n    /**\n     * returns the index of the next non-whitespace, non-comment token.\n     * returns -1 if no meaningful token is found.\n     */\n    locateNextMeaningfulToken (startPosition = this.position + 1) {\n        let searchPosition = startPosition;\n        while (searchPosition < this.tokens.length) {\n            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][TOKEN.TYPE]]) {\n                searchPosition++;\n                continue;\n            } else {\n                return searchPosition;\n            }\n        }\n        return -1;\n    }\n}\n", "import Parser from './parser';\n\nexport default class Processor {\n    constructor (func, options) {\n        this.func = func || function noop () {};\n        this.funcRes = null;\n        this.options = options;\n    }\n\n    _shouldUpdateSelector (rule, options = {}) {\n        let merged = Object.assign({}, this.options, options);\n        if (merged.updateSelector === false) {\n            return false;\n        } else {\n            return typeof rule !== \"string\";\n        }\n    }\n\n    _isLossy (options = {}) {\n        let merged = Object.assign({}, this.options, options);\n        if (merged.lossless === false) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    _root (rule, options = {}) {\n        let parser = new Parser(rule, this._parseOptions(options));\n        return parser.root;\n    }\n\n    _parseOptions (options) {\n        return {\n            lossy: this._isLossy(options),\n        };\n    }\n\n    _run (rule, options = {}) {\n        return new Promise((resolve, reject) => {\n            try {\n                let root = this._root(rule, options);\n                Promise.resolve(this.func(root)).then(transform => {\n                    let string = undefined;\n                    if (this._shouldUpdateSelector(rule, options)) {\n                        string = root.toString();\n                        rule.selector = string;\n                    }\n                    return {transform, root, string};\n                }).then(resolve, reject);\n            } catch (e) {\n                reject(e);\n                return;\n            }\n        });\n    }\n\n    _runSync (rule, options = {}) {\n        let root = this._root(rule, options);\n        let transform = this.func(root);\n        if (transform && typeof transform.then === \"function\") {\n            throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n        }\n        let string = undefined;\n        if (options.updateSelector && typeof rule !== \"string\") {\n            string = root.toString();\n            rule.selector = string;\n        }\n        return {transform, root, string};\n    }\n\n    /**\n     * Process rule into a selector AST.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n     */\n    ast (rule, options) {\n        return this._run(rule, options).then(result => result.root);\n    }\n\n    /**\n     * Process rule into a selector AST synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {parser.Root} The AST of the selector after processing it.\n     */\n    astSync (rule, options) {\n        return this._runSync(rule, options).root;\n    }\n\n    /**\n     * Process a selector into a transformed value asynchronously\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {Promise<any>} The value returned by the processor.\n     */\n    transform (rule, options) {\n        return this._run(rule, options).then(result => result.transform);\n    }\n\n    /**\n     * Process a selector into a transformed value synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {any} The value returned by the processor.\n     */\n    transformSync (rule, options) {\n        return this._runSync(rule, options).transform;\n    }\n\n    /**\n     * Process a selector into a new selector string asynchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {string} the selector after processing.\n     */\n    process (rule, options) {\n        return this._run(rule, options)\n            .then((result) => result.string || result.root.toString());\n    }\n\n    /**\n     * Process a selector into a new selector string synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {string} the selector after processing.\n     */\n    processSync (rule, options) {\n        let result = this._runSync(rule, options);\n        return result.string || result.root.toString();\n    }\n}\n"],
  "mappings": "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",
  "names": ["str", "hex", "str", "ID", "String", "unescaped", "space", "String", "word", "ID"]
}
