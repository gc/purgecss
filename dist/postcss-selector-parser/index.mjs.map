{
  "version": 3,
  "sources": ["../../src/postcss-selector-parser/util/unesc.js", "../../src/postcss-selector-parser/util/getProp.js", "../../src/postcss-selector-parser/util/ensureObject.js", "../../src/postcss-selector-parser/selectors/node.js", "../../src/postcss-selector-parser/selectors/types.js", "../../src/postcss-selector-parser/selectors/container.js", "../../src/postcss-selector-parser/selectors/root.js", "../../src/postcss-selector-parser/selectors/selector.js", "../../src/cssesc/index.js", "../../src/postcss-selector-parser/selectors/className.js", "../../src/postcss-selector-parser/selectors/comment.js", "../../src/postcss-selector-parser/selectors/id.js", "../../src/postcss-selector-parser/selectors/namespace.js", "../../src/postcss-selector-parser/selectors/tag.js", "../../src/postcss-selector-parser/selectors/string.js", "../../src/postcss-selector-parser/selectors/pseudo.js", "../../src/postcss-selector-parser/selectors/attribute.js", "../../src/postcss-selector-parser/selectors/universal.js", "../../src/postcss-selector-parser/selectors/combinator.js", "../../src/postcss-selector-parser/selectors/nesting.js", "../../src/postcss-selector-parser/sortAscending.js", "../../src/postcss-selector-parser/tokenTypes.js", "../../src/postcss-selector-parser/tokenize.js", "../../src/postcss-selector-parser/parser.js", "../../src/postcss-selector-parser/processor.js", "../../src/postcss-selector-parser/selectors/index.js", "../../src/postcss-selector-parser/selectors/constructors.js", "../../src/postcss-selector-parser/selectors/guards.js", "../../src/postcss-selector-parser/index.js"],
  "sourcesContent": ["// Many thanks for this post which made this migration much easier.\r\n// https://mathiasbynens.be/notes/css-escapes\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {[string, number]|undefined}\r\n */\r\nfunction gobbleHex(str) {\r\n    const lower = str.toLowerCase();\r\n    let hex = '';\r\n    let spaceTerminated = false;\r\n    for (let i = 0; i < 6 && lower[i] !== undefined; i++) {\r\n        const code = lower.charCodeAt(i);\r\n        // check to see if we are dealing with a valid hex char [a-f|0-9]\r\n        const valid = (code >= 97 && code <= 102) || (code >= 48 && code <= 57);\r\n        // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\r\n        spaceTerminated = code === 32;\r\n        if (!valid) {\r\n            break;\r\n        }\r\n        hex += lower[i];\r\n    }\r\n    if (hex.length === 0) {\r\n        return undefined;\r\n    }\r\n    const codePoint = parseInt(hex, 16);\r\n    const isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;\r\n    // Add special case for\r\n    // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\r\n    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\r\n    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\r\n        return ['\\uFFFD', hex.length + (spaceTerminated ? 1 : 0)];\r\n    }\r\n    return [\r\n        String.fromCodePoint(codePoint),\r\n        hex.length + (spaceTerminated ? 1 : 0),\r\n    ];\r\n}\r\nconst CONTAINS_ESCAPE = /\\\\/;\r\nexport default function unesc(str) {\r\n    let needToProcess = CONTAINS_ESCAPE.test(str);\r\n    if (!needToProcess) {\r\n        return str;\r\n    }\r\n    let ret = \"\";\r\n    for (let i = 0; i < str.length; i++) {\r\n        if ((str[i] === \"\\\\\")) {\r\n            const gobbled = gobbleHex(str.slice(i + 1, i + 7));\r\n            if (gobbled !== undefined) {\r\n                ret += gobbled[0];\r\n                i += gobbled[1];\r\n                continue;\r\n            }\r\n            // Retain a pair of \\\\ if double escaped `\\\\\\\\`\r\n            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\r\n            if (str[i + 1] === \"\\\\\") {\r\n                ret += \"\\\\\";\r\n                i++;\r\n                continue;\r\n            }\r\n            // if \\\\ is at the end of the string retain it\r\n            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\r\n            if (str.length === i + 1) {\r\n                ret += str[i];\r\n            }\r\n            continue;\r\n        }\r\n        ret += str[i];\r\n    }\r\n    return ret;\r\n}\r\n", "export default function getProp(obj, ...props) {\r\n    while (props.length > 0) {\r\n        const prop = props.shift();\r\n        if (!obj[prop]) {\r\n            return undefined;\r\n        }\r\n        obj = obj[prop];\r\n    }\r\n    return obj;\r\n}\r\n", "export default function ensureObject(obj, ...props) {\r\n    while (props.length > 0) {\r\n        const prop = props.shift();\r\n        if (!obj[prop]) {\r\n            obj[prop] = {};\r\n        }\r\n        obj = obj[prop];\r\n    }\r\n}\r\n", "import { ensureObject } from \"../util\";\r\nlet cloneNode = function (obj, parent) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n    let cloned = new obj.constructor();\r\n    for (let i in obj) {\r\n        if (!obj.hasOwnProperty(i)) {\r\n            continue;\r\n        }\r\n        let value = obj[i];\r\n        let type = typeof value;\r\n        if (i === 'parent' && type === 'object') {\r\n            if (parent) {\r\n                cloned[i] = parent;\r\n            }\r\n        }\r\n        else if (value instanceof Array) {\r\n            cloned[i] = value.map(j => cloneNode(j, cloned));\r\n        }\r\n        else {\r\n            cloned[i] = cloneNode(value, cloned);\r\n        }\r\n    }\r\n    return cloned;\r\n};\r\nexport default class Node {\r\n    constructor(opts = {}) {\r\n        Object.assign(this, opts);\r\n        this.spaces = this.spaces || {};\r\n        this.spaces.before = this.spaces.before || '';\r\n        this.spaces.after = this.spaces.after || '';\r\n    }\r\n    remove() {\r\n        if (this.parent) {\r\n            this.parent.removeChild(this);\r\n        }\r\n        this.parent = undefined;\r\n        return this;\r\n    }\r\n    replaceWith() {\r\n        if (this.parent) {\r\n            for (let index in arguments) {\r\n                this.parent.insertBefore(this, arguments[index]);\r\n            }\r\n            this.remove();\r\n        }\r\n        return this;\r\n    }\r\n    next() {\r\n        return this.parent.at(this.parent.index(this) + 1);\r\n    }\r\n    prev() {\r\n        return this.parent.at(this.parent.index(this) - 1);\r\n    }\r\n    clone(overrides = {}) {\r\n        let cloned = cloneNode(this);\r\n        for (let name in overrides) {\r\n            cloned[name] = overrides[name];\r\n        }\r\n        return cloned;\r\n    }\r\n    /**\r\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\r\n     * This allows non standard syntax to be appended to an existing property\r\n     * by specifying the escaped value. By specifying the escaped value,\r\n     * illegal characters are allowed to be directly inserted into css output.\r\n     * @param {string} name the property to set\r\n     * @param {any} value the unescaped value of the property\r\n     * @param {string} valueEscaped optional. the escaped value of the property.\r\n     */\r\n    appendToPropertyAndEscape(name, value, valueEscaped) {\r\n        if (!this.raws) {\r\n            this.raws = {};\r\n        }\r\n        let originalValue = this[name];\r\n        let originalEscaped = this.raws[name];\r\n        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        if (originalEscaped || valueEscaped !== value) {\r\n            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\r\n        }\r\n        else {\r\n            delete this.raws[name]; // delete any escaped value that was created by the setter.\r\n        }\r\n    }\r\n    /**\r\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\r\n     * This allows the escaped value to be specified directly, allowing illegal\r\n     * characters to be directly inserted into css output.\r\n     * @param {string} name the property to set\r\n     * @param {any} value the unescaped value of the property\r\n     * @param {string} valueEscaped the escaped value of the property.\r\n     */\r\n    setPropertyAndEscape(name, value, valueEscaped) {\r\n        if (!this.raws) {\r\n            this.raws = {};\r\n        }\r\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        this.raws[name] = valueEscaped;\r\n    }\r\n    /**\r\n     * When you want a value to passed through to CSS directly. This method\r\n     * deletes the corresponding raw value causing the stringifier to fallback\r\n     * to the unescaped value.\r\n     * @param {string} name the property to set.\r\n     * @param {any} value The value that is both escaped and unescaped.\r\n     */\r\n    setPropertyWithoutEscape(name, value) {\r\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        if (this.raws) {\r\n            delete this.raws[name];\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @param {number} line The number (starting with 1)\r\n     * @param {number} column The column number (starting with 1)\r\n     */\r\n    isAtPosition(line, column) {\r\n        if (this.source && this.source.start && this.source.end) {\r\n            if (this.source.start.line > line) {\r\n                return false;\r\n            }\r\n            if (this.source.end.line < line) {\r\n                return false;\r\n            }\r\n            if (this.source.start.line === line && this.source.start.column > column) {\r\n                return false;\r\n            }\r\n            if (this.source.end.line === line && this.source.end.column < column) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return undefined;\r\n    }\r\n    stringifyProperty(name) {\r\n        return (this.raws && this.raws[name]) || this[name];\r\n    }\r\n    get rawSpaceBefore() {\r\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\r\n        if (rawSpace === undefined) {\r\n            rawSpace = this.spaces && this.spaces.before;\r\n        }\r\n        return rawSpace || \"\";\r\n    }\r\n    set rawSpaceBefore(raw) {\r\n        ensureObject(this, \"raws\", \"spaces\");\r\n        this.raws.spaces.before = raw;\r\n    }\r\n    get rawSpaceAfter() {\r\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\r\n        if (rawSpace === undefined) {\r\n            rawSpace = this.spaces.after;\r\n        }\r\n        return rawSpace || \"\";\r\n    }\r\n    set rawSpaceAfter(raw) {\r\n        ensureObject(this, \"raws\", \"spaces\");\r\n        this.raws.spaces.after = raw;\r\n    }\r\n    valueToString() {\r\n        return String(this.stringifyProperty(\"value\"));\r\n    }\r\n    toString() {\r\n        return [\r\n            this.rawSpaceBefore,\r\n            this.valueToString(),\r\n            this.rawSpaceAfter,\r\n        ].join('');\r\n    }\r\n}\r\n", "export const TAG = 'tag';\r\nexport const STRING = 'string';\r\nexport const SELECTOR = 'selector';\r\nexport const ROOT = 'root';\r\nexport const PSEUDO = 'pseudo';\r\nexport const NESTING = 'nesting';\r\nexport const ID = 'id';\r\nexport const COMMENT = 'comment';\r\nexport const COMBINATOR = 'combinator';\r\nexport const CLASS = 'class';\r\nexport const ATTRIBUTE = 'attribute';\r\nexport const UNIVERSAL = 'universal';\r\n", "import Node from './node';\r\nimport * as types from './types';\r\nexport default class Container extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        if (!this.nodes) {\r\n            this.nodes = [];\r\n        }\r\n    }\r\n    append(selector) {\r\n        selector.parent = this;\r\n        this.nodes.push(selector);\r\n        return this;\r\n    }\r\n    prepend(selector) {\r\n        selector.parent = this;\r\n        this.nodes.unshift(selector);\r\n        for (let id in this.indexes) {\r\n            this.indexes[id]++;\r\n        }\r\n        return this;\r\n    }\r\n    at(index) {\r\n        return this.nodes[index];\r\n    }\r\n    index(child) {\r\n        if (typeof child === 'number') {\r\n            return child;\r\n        }\r\n        return this.nodes.indexOf(child);\r\n    }\r\n    get first() {\r\n        return this.at(0);\r\n    }\r\n    get last() {\r\n        return this.at(this.length - 1);\r\n    }\r\n    get length() {\r\n        return this.nodes.length;\r\n    }\r\n    removeChild(child) {\r\n        child = this.index(child);\r\n        this.at(child).parent = undefined;\r\n        this.nodes.splice(child, 1);\r\n        let index;\r\n        for (let id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (index >= child) {\r\n                this.indexes[id] = index - 1;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    removeAll() {\r\n        for (let node of this.nodes) {\r\n            node.parent = undefined;\r\n        }\r\n        this.nodes = [];\r\n        return this;\r\n    }\r\n    empty() {\r\n        return this.removeAll();\r\n    }\r\n    insertAfter(oldNode, newNode) {\r\n        newNode.parent = this;\r\n        let oldIndex = this.index(oldNode);\r\n        this.nodes.splice(oldIndex + 1, 0, newNode);\r\n        newNode.parent = this;\r\n        let index;\r\n        for (let id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (oldIndex < index) {\r\n                this.indexes[id] = index + 1;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    insertBefore(oldNode, newNode) {\r\n        newNode.parent = this;\r\n        let oldIndex = this.index(oldNode);\r\n        this.nodes.splice(oldIndex, 0, newNode);\r\n        newNode.parent = this;\r\n        let index;\r\n        for (let id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (index >= oldIndex) {\r\n                this.indexes[id] = index + 1;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    _findChildAtPosition(line, col) {\r\n        let found = undefined;\r\n        this.each(node => {\r\n            if (node.atPosition) {\r\n                let foundChild = node.atPosition(line, col);\r\n                if (foundChild) {\r\n                    found = foundChild;\r\n                    return false;\r\n                }\r\n            }\r\n            else if (node.isAtPosition(line, col)) {\r\n                found = node;\r\n                return false;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n    /**\r\n     * Return the most specific node at the line and column number given.\r\n     * The source location is based on the original parsed location, locations aren't\r\n     * updated as selector nodes are mutated.\r\n     *\r\n     * Note that this location is relative to the location of the first character\r\n     * of the selector, and not the location of the selector in the overall document\r\n     * when used in conjunction with postcss.\r\n     *\r\n     * If not found, returns undefined.\r\n     * @param {number} line The line number of the node to find. (1-based index)\r\n     * @param {number} col  The column number of the node to find. (1-based index)\r\n     */\r\n    atPosition(line, col) {\r\n        if (this.isAtPosition(line, col)) {\r\n            return this._findChildAtPosition(line, col) || this;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    _inferEndPosition() {\r\n        if (this.last && this.last.source && this.last.source.end) {\r\n            this.source = this.source || {};\r\n            this.source.end = this.source.end || {};\r\n            Object.assign(this.source.end, this.last.source.end);\r\n        }\r\n    }\r\n    each(callback) {\r\n        if (!this.lastEach) {\r\n            this.lastEach = 0;\r\n        }\r\n        if (!this.indexes) {\r\n            this.indexes = {};\r\n        }\r\n        this.lastEach++;\r\n        let id = this.lastEach;\r\n        this.indexes[id] = 0;\r\n        if (!this.length) {\r\n            return undefined;\r\n        }\r\n        let index, result;\r\n        while (this.indexes[id] < this.length) {\r\n            index = this.indexes[id];\r\n            result = callback(this.at(index), index);\r\n            if (result === false) {\r\n                break;\r\n            }\r\n            this.indexes[id] += 1;\r\n        }\r\n        delete this.indexes[id];\r\n        if (result === false) {\r\n            return false;\r\n        }\r\n    }\r\n    walk(callback) {\r\n        return this.each((node, i) => {\r\n            let result = callback(node, i);\r\n            if (result !== false && node.length) {\r\n                result = node.walk(callback);\r\n            }\r\n            if (result === false) {\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    walkAttributes(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.ATTRIBUTE) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkClasses(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.CLASS) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkCombinators(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.COMBINATOR) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkComments(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.COMMENT) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkIds(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.ID) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkNesting(callback) {\r\n        return this.walk(selector => {\r\n            if (selector.type === types.NESTING) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkPseudos(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.PSEUDO) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkTags(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.TAG) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkUniversals(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.UNIVERSAL) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    split(callback) {\r\n        let current = [];\r\n        return this.reduce((memo, node, index) => {\r\n            let split = callback.call(this, node);\r\n            current.push(node);\r\n            if (split) {\r\n                memo.push(current);\r\n                current = [];\r\n            }\r\n            else if (index === this.length - 1) {\r\n                memo.push(current);\r\n            }\r\n            return memo;\r\n        }, []);\r\n    }\r\n    map(callback) {\r\n        return this.nodes.map(callback);\r\n    }\r\n    reduce(callback, memo) {\r\n        return this.nodes.reduce(callback, memo);\r\n    }\r\n    every(callback) {\r\n        return this.nodes.every(callback);\r\n    }\r\n    some(callback) {\r\n        return this.nodes.some(callback);\r\n    }\r\n    filter(callback) {\r\n        return this.nodes.filter(callback);\r\n    }\r\n    sort(callback) {\r\n        return this.nodes.sort(callback);\r\n    }\r\n    toString() {\r\n        return this.map(String).join('');\r\n    }\r\n}\r\n", "import Container from './container';\r\nimport { ROOT } from './types';\r\nexport default class Root extends Container {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = ROOT;\r\n    }\r\n    toString() {\r\n        let str = this.reduce((memo, selector) => {\r\n            memo.push(String(selector));\r\n            return memo;\r\n        }, []).join(',');\r\n        return this.trailingComma ? str + ',' : str;\r\n    }\r\n    error(message, options) {\r\n        if (this._error) {\r\n            return this._error(message, options);\r\n        }\r\n        else {\r\n            return new Error(message);\r\n        }\r\n    }\r\n    set errorGenerator(handler) {\r\n        this._error = handler;\r\n    }\r\n}\r\n", "import Container from './container';\r\nimport { SELECTOR } from './types';\r\nexport default class Selector extends Container {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = SELECTOR;\r\n    }\r\n}\r\n", "const object = {};\r\nconst hasOwnProperty = object.hasOwnProperty;\r\nconst merge = (options, defaults) => {\r\n    if (!options) {\r\n        return defaults;\r\n    }\r\n    const result = {};\r\n    for (const key in defaults) {\r\n        // `if (defaults.hasOwnProperty(key) { \u2026 }` is not needed here, since\r\n        // only recognized option names are used.\r\n        result[key] = hasOwnProperty.call(options, key)\r\n            ? options[key]\r\n            : defaults[key];\r\n    }\r\n    return result;\r\n};\r\nconst regexAnySingleEscape = /<%= anySingleEscape %>/;\r\nconst regexSingleEscape = /<%= singleEscapes %>/;\r\nconst regexAlwaysEscape = /['\"\\\\]/;\r\nconst regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\r\n/*@__NO_SIDE_EFFECTS__*/\r\nconst cssesc = (string, options) => {\r\n    options = merge(options, cssesc.options);\r\n    if (options.quotes != 'single' && options.quotes != 'double') {\r\n        options.quotes = 'single';\r\n    }\r\n    const quote = options.quotes == 'double' ? '\"' : '\\'';\r\n    const isIdentifier = options.isIdentifier;\r\n    const firstChar = string.charAt(0);\r\n    let output = '';\r\n    let counter = 0;\r\n    const length = string.length;\r\n    while (counter < length) {\r\n        const character = string.charAt(counter++);\r\n        let codePoint = character.charCodeAt();\r\n        let value;\r\n        // If it\u2019s not a printable ASCII character\u2026\r\n        if (codePoint < 0x20 || codePoint > 0x7E) {\r\n            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\r\n                // It\u2019s a high surrogate, and there is a next character.\r\n                const extra = string.charCodeAt(counter++);\r\n                if ((extra & 0xFC00) == 0xDC00) { // next character is low surrogate\r\n                    codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\r\n                }\r\n                else {\r\n                    // It\u2019s an unmatched surrogate; only append this code unit, in case\r\n                    // the next code unit is the high surrogate of a surrogate pair.\r\n                    counter--;\r\n                }\r\n            }\r\n            value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n        }\r\n        else {\r\n            if (options.escapeEverything) {\r\n                if (regexAnySingleEscape.test(character)) {\r\n                    value = '\\\\' + character;\r\n                }\r\n                else {\r\n                    value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n                }\r\n            }\r\n            else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\r\n                value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n            }\r\n            else if (character == '\\\\' ||\r\n                (!isIdentifier &&\r\n                    ((character == '\"' && quote == character) ||\r\n                        (character == '\\'' && quote == character))) ||\r\n                (isIdentifier && regexSingleEscape.test(character))) {\r\n                value = '\\\\' + character;\r\n            }\r\n            else {\r\n                value = character;\r\n            }\r\n        }\r\n        output += value;\r\n    }\r\n    if (isIdentifier) {\r\n        if (/^-[-\\d]/.test(output)) {\r\n            output = '\\\\-' + output.slice(1);\r\n        }\r\n        else if (/\\d/.test(firstChar)) {\r\n            output = '\\\\3' + firstChar + ' ' + output.slice(1);\r\n        }\r\n    }\r\n    // Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\r\n    // since they\u2019re redundant. Note that this is only possible if the escape\r\n    // sequence isn\u2019t preceded by an odd number of backslashes.\r\n    output = output.replace(regexExcessiveSpaces, ($0, $1, $2) => {\r\n        if ($1 && $1.length % 2) {\r\n            // It\u2019s not safe to remove the space, so don\u2019t.\r\n            return $0;\r\n        }\r\n        // Strip the space.\r\n        return ($1 || '') + $2;\r\n    });\r\n    if (!isIdentifier && options.wrap) {\r\n        return quote + output + quote;\r\n    }\r\n    return output;\r\n};\r\n// Expose default options (so they can be overridden globally).\r\ncssesc.options = {\r\n    'escapeEverything': false,\r\n    'isIdentifier': false,\r\n    'quotes': 'single',\r\n    'wrap': false\r\n};\r\nexport default cssesc;\r\n", "import cssesc from \"../../cssesc\";\r\nimport { ensureObject } from '../util';\r\nimport Node from './node';\r\nimport { CLASS } from './types';\r\nexport default class ClassName extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = CLASS;\r\n        this._constructed = true;\r\n    }\r\n    set value(v) {\r\n        if (this._constructed) {\r\n            const escaped = cssesc(v, { isIdentifier: true });\r\n            if (escaped !== v) {\r\n                ensureObject(this, \"raws\");\r\n                this.raws.value = escaped;\r\n            }\r\n            else if (this.raws) {\r\n                delete this.raws.value;\r\n            }\r\n        }\r\n        this._value = v;\r\n    }\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    valueToString() {\r\n        return '.' + super.valueToString();\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { COMMENT } from './types';\r\nexport default class Comment extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = COMMENT;\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { ID as IDType } from './types';\r\nexport default class ID extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = IDType;\r\n    }\r\n    valueToString() {\r\n        return '#' + super.valueToString();\r\n    }\r\n}\r\n", "import cssesc from \"../../cssesc\";\r\nimport { ensureObject } from '../util';\r\nimport Node from './node';\r\nexport default class Namespace extends Node {\r\n    get namespace() {\r\n        return this._namespace;\r\n    }\r\n    set namespace(namespace) {\r\n        if (namespace === true || namespace === \"*\" || namespace === \"&\") {\r\n            this._namespace = namespace;\r\n            if (this.raws) {\r\n                delete this.raws.namespace;\r\n            }\r\n            return;\r\n        }\r\n        const escaped = cssesc(namespace, { isIdentifier: true });\r\n        this._namespace = namespace;\r\n        if (escaped !== namespace) {\r\n            ensureObject(this, \"raws\");\r\n            this.raws.namespace = escaped;\r\n        }\r\n        else if (this.raws) {\r\n            delete this.raws.namespace;\r\n        }\r\n    }\r\n    get ns() {\r\n        return this._namespace;\r\n    }\r\n    set ns(namespace) {\r\n        this.namespace = namespace;\r\n    }\r\n    get namespaceString() {\r\n        if (this.namespace) {\r\n            const ns = this.stringifyProperty(\"namespace\");\r\n            if (ns === true) {\r\n                return '';\r\n            }\r\n            else {\r\n                return ns;\r\n            }\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    qualifiedName(value) {\r\n        if (this.namespace) {\r\n            return `${this.namespaceString}|${value}`;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n    valueToString() {\r\n        return this.qualifiedName(super.valueToString());\r\n    }\r\n}\r\n;\r\n", "import Namespace from './namespace';\r\nimport { TAG } from './types';\r\nexport default class Tag extends Namespace {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = TAG;\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { STRING } from './types';\r\nexport default class String extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = STRING;\r\n    }\r\n}\r\n", "import Container from './container';\r\nimport { PSEUDO } from './types';\r\nexport default class Pseudo extends Container {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = PSEUDO;\r\n    }\r\n    toString() {\r\n        let params = this.length ? '(' + this.map(String).join(',') + ')' : '';\r\n        return [\r\n            this.rawSpaceBefore,\r\n            this.stringifyProperty(\"value\"),\r\n            params,\r\n            this.rawSpaceAfter,\r\n        ].join('');\r\n    }\r\n}\r\n", "import cssesc from \"../../cssesc\";\r\nimport unesc from \"../util/unesc\";\r\nimport Namespace from './namespace';\r\nimport { ATTRIBUTE } from './types';\r\nconst WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\r\nexport function unescapeValue(value) {\r\n    let deprecatedUsage = false;\r\n    let quoteMark = null;\r\n    let unescaped = value;\r\n    const m = unescaped.match(WRAPPED_IN_QUOTES);\r\n    if (m) {\r\n        quoteMark = m[1];\r\n        unescaped = m[2];\r\n    }\r\n    unescaped = unesc(unescaped);\r\n    if (unescaped !== value) {\r\n        deprecatedUsage = true;\r\n    }\r\n    return {\r\n        deprecatedUsage,\r\n        unescaped,\r\n        quoteMark,\r\n    };\r\n}\r\nfunction handleDeprecatedContructorOpts(opts) {\r\n    if (opts.quoteMark !== undefined) {\r\n        return opts;\r\n    }\r\n    if (opts.value === undefined) {\r\n        return opts;\r\n    }\r\n    warnOfDeprecatedConstructor();\r\n    const { quoteMark, unescaped } = unescapeValue(opts.value);\r\n    if (!opts.raws) {\r\n        opts.raws = {};\r\n    }\r\n    if (opts.raws.value === undefined) {\r\n        opts.raws.value = opts.value;\r\n    }\r\n    opts.value = unescaped;\r\n    opts.quoteMark = quoteMark;\r\n    return opts;\r\n}\r\nexport default class Attribute extends Namespace {\r\n    static NO_QUOTE = null;\r\n    static SINGLE_QUOTE = \"'\";\r\n    static DOUBLE_QUOTE = '\"';\r\n    constructor(opts = {}) {\r\n        super(handleDeprecatedContructorOpts(opts));\r\n        this.type = ATTRIBUTE;\r\n        this.raws = this.raws || {};\r\n        this._constructed = true;\r\n    }\r\n    /**\r\n     * Returns the Attribute's value quoted such that it would be legal to use\r\n     * in the value of a css file. The original value's quotation setting\r\n     * used for stringification is left unchanged. See `setValue(value, options)`\r\n     * if you want to control the quote settings of a new value for the attribute.\r\n     *\r\n     * You can also change the quotation used for the current value by setting quoteMark.\r\n     *\r\n     * Options:\r\n     *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\r\n     *     option is not set, the original value for quoteMark will be used. If\r\n     *     indeterminate, a double quote is used. The legal values are:\r\n     *     * `null` - the value will be unquoted and characters will be escaped as necessary.\r\n     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\r\n     *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\r\n     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\r\n     *     over the quoteMark option value.\r\n     *   * smart {boolean} - if true, will select a quote mark based on the value\r\n     *     and the other options specified here. See the `smartQuoteMark()`\r\n     *     method.\r\n     **/\r\n    getQuotedValue(options = {}) {\r\n        const quoteMark = this._determineQuoteMark(options);\r\n        const cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\r\n        const escaped = cssesc(this._value, cssescopts);\r\n        return escaped;\r\n    }\r\n    _determineQuoteMark(options) {\r\n        return (options.smart) ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\r\n    }\r\n    /**\r\n     * Set the unescaped value with the specified quotation options. The value\r\n     * provided must not include any wrapping quote marks -- those quotes will\r\n     * be interpreted as part of the value and escaped accordingly.\r\n     */\r\n    setValue(value, options = {}) {\r\n        this._value = value;\r\n        this._quoteMark = this._determineQuoteMark(options);\r\n        this._syncRawValue();\r\n    }\r\n    /**\r\n     * Intelligently select a quoteMark value based on the value's contents. If\r\n     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\r\n     * mark will be picked that minimizes the number of escapes.\r\n     *\r\n     * If there's no clear winner, the quote mark from these options is used,\r\n     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\r\n     * true). If the quoteMark is unspecified, a double quote is used.\r\n     *\r\n     * @param options This takes the quoteMark and preferCurrentQuoteMark options\r\n     * from the quoteValue method.\r\n     */\r\n    smartQuoteMark(options) {\r\n        const v = this.value;\r\n        const numSingleQuotes = v.replace(/[^']/g, '').length;\r\n        const numDoubleQuotes = v.replace(/[^\"]/g, '').length;\r\n        if (numSingleQuotes + numDoubleQuotes === 0) {\r\n            const escaped = cssesc(v, { isIdentifier: true });\r\n            if (escaped === v) {\r\n                return Attribute.NO_QUOTE;\r\n            }\r\n            else {\r\n                const pref = this.preferredQuoteMark(options);\r\n                if (pref === Attribute.NO_QUOTE) {\r\n                    // pick a quote mark that isn't none and see if it's smaller\r\n                    const quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\r\n                    const opts = CSSESC_QUOTE_OPTIONS[quote];\r\n                    const quoteValue = cssesc(v, opts);\r\n                    if (quoteValue.length < escaped.length) {\r\n                        return quote;\r\n                    }\r\n                }\r\n                return pref;\r\n            }\r\n        }\r\n        else if (numDoubleQuotes === numSingleQuotes) {\r\n            return this.preferredQuoteMark(options);\r\n        }\r\n        else if (numDoubleQuotes < numSingleQuotes) {\r\n            return Attribute.DOUBLE_QUOTE;\r\n        }\r\n        else {\r\n            return Attribute.SINGLE_QUOTE;\r\n        }\r\n    }\r\n    /**\r\n     * Selects the preferred quote mark based on the options and the current quote mark value.\r\n     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\r\n     * instead.\r\n     */\r\n    preferredQuoteMark(options) {\r\n        let quoteMark = (options.preferCurrentQuoteMark) ? this.quoteMark : options.quoteMark;\r\n        if (quoteMark === undefined) {\r\n            quoteMark = (options.preferCurrentQuoteMark) ? options.quoteMark : this.quoteMark;\r\n        }\r\n        if (quoteMark === undefined) {\r\n            quoteMark = Attribute.DOUBLE_QUOTE;\r\n        }\r\n        return quoteMark;\r\n    }\r\n    get quoted() {\r\n        const qm = this.quoteMark;\r\n        return qm === \"'\" || qm === '\"';\r\n    }\r\n    set quoted(value) {\r\n        warnOfDeprecatedQuotedAssignment();\r\n    }\r\n    /**\r\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\r\n     * returns `null` if the value is not quoted.\r\n     * returns `undefined` if the quotation state is unknown (this can happen when\r\n     * the attribute is constructed without specifying a quote mark.)\r\n     */\r\n    get quoteMark() {\r\n        return this._quoteMark;\r\n    }\r\n    /**\r\n     * Set the quote mark to be used by this attribute's value.\r\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\r\n     * value is updated accordingly.\r\n     *\r\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\r\n     */\r\n    set quoteMark(quoteMark) {\r\n        if (!this._constructed) {\r\n            this._quoteMark = quoteMark;\r\n            return;\r\n        }\r\n        if (this._quoteMark !== quoteMark) {\r\n            this._quoteMark = quoteMark;\r\n            this._syncRawValue();\r\n        }\r\n    }\r\n    _syncRawValue() {\r\n        const rawValue = cssesc(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\r\n        if (rawValue === this._value) {\r\n            if (this.raws) {\r\n                delete this.raws.value;\r\n            }\r\n        }\r\n        else {\r\n            this.raws.value = rawValue;\r\n        }\r\n    }\r\n    get qualifiedAttribute() {\r\n        return this.qualifiedName(this.raws.attribute || this.attribute);\r\n    }\r\n    get insensitiveFlag() {\r\n        return this.insensitive ? 'i' : '';\r\n    }\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    get insensitive() {\r\n        return this._insensitive;\r\n    }\r\n    /**\r\n     * Set the case insensitive flag.\r\n     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`\r\n     * of the attribute is updated accordingly.\r\n     *\r\n     * @param {true | false} insensitive true if the attribute should match case-insensitively.\r\n     */\r\n    set insensitive(insensitive) {\r\n        if (!insensitive) {\r\n            this._insensitive = false;\r\n            // \"i\" and \"I\" can be used in \"this.raws.insensitiveFlag\" to store the original notation.\r\n            // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.\r\n            if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {\r\n                this.raws.insensitiveFlag = undefined;\r\n            }\r\n        }\r\n        this._insensitive = insensitive;\r\n    }\r\n    /**\r\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\r\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\r\n     * is unescaped during parsing and any quote marks are removed.\r\n     *\r\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\r\n     * a deprecation warning is raised when the new value contains any characters that would\r\n     * require escaping (including if it contains wrapped quotes).\r\n     *\r\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\r\n     * how the new value is quoted.\r\n     */\r\n    set value(v) {\r\n        if (this._constructed) {\r\n            const { deprecatedUsage, unescaped, quoteMark, } = unescapeValue(v);\r\n            if (deprecatedUsage) {\r\n                warnOfDeprecatedValueAssignment();\r\n            }\r\n            if (unescaped === this._value && quoteMark === this._quoteMark) {\r\n                return;\r\n            }\r\n            this._value = unescaped;\r\n            this._quoteMark = quoteMark;\r\n            this._syncRawValue();\r\n        }\r\n        else {\r\n            this._value = v;\r\n        }\r\n    }\r\n    get attribute() {\r\n        return this._attribute;\r\n    }\r\n    set attribute(name) {\r\n        this._handleEscapes(\"attribute\", name);\r\n        this._attribute = name;\r\n    }\r\n    _handleEscapes(prop, value) {\r\n        if (this._constructed) {\r\n            const escaped = cssesc(value, { isIdentifier: true });\r\n            if (escaped !== value) {\r\n                this.raws[prop] = escaped;\r\n            }\r\n            else {\r\n                delete this.raws[prop];\r\n            }\r\n        }\r\n    }\r\n    _spacesFor(name) {\r\n        const attrSpaces = { before: '', after: '' };\r\n        const spaces = this.spaces[name] || {};\r\n        const rawSpaces = (this.raws.spaces && this.raws.spaces[name]) || {};\r\n        return Object.assign(attrSpaces, spaces, rawSpaces);\r\n    }\r\n    _stringFor(name, spaceName = name, concat = defaultAttrConcat) {\r\n        const attrSpaces = this._spacesFor(spaceName);\r\n        return concat(this.stringifyProperty(name), attrSpaces);\r\n    }\r\n    /**\r\n     * returns the offset of the attribute part specified relative to the\r\n     * start of the node of the output string.\r\n     *\r\n     * * \"ns\" - alias for \"namespace\"\r\n     * * \"namespace\" - the namespace if it exists.\r\n     * * \"attribute\" - the attribute name\r\n     * * \"attributeNS\" - the start of the attribute or its namespace\r\n     * * \"operator\" - the match operator of the attribute\r\n     * * \"value\" - The value (string or identifier)\r\n     * * \"insensitive\" - the case insensitivity flag;\r\n     * @param part One of the possible values inside an attribute.\r\n     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\r\n     */\r\n    offsetOf(name) {\r\n        let count = 1;\r\n        const attributeSpaces = this._spacesFor(\"attribute\");\r\n        count += attributeSpaces.before.length;\r\n        if (name === \"namespace\" || name === \"ns\") {\r\n            return (this.namespace) ? count : -1;\r\n        }\r\n        if (name === \"attributeNS\") {\r\n            return count;\r\n        }\r\n        count += this.namespaceString.length;\r\n        if (this.namespace) {\r\n            count += 1;\r\n        }\r\n        if (name === \"attribute\") {\r\n            return count;\r\n        }\r\n        count += this.stringifyProperty(\"attribute\").length;\r\n        count += attributeSpaces.after.length;\r\n        const operatorSpaces = this._spacesFor(\"operator\");\r\n        count += operatorSpaces.before.length;\r\n        const operator = this.stringifyProperty(\"operator\");\r\n        if (name === \"operator\") {\r\n            return operator ? count : -1;\r\n        }\r\n        count += operator.length;\r\n        count += operatorSpaces.after.length;\r\n        const valueSpaces = this._spacesFor(\"value\");\r\n        count += valueSpaces.before.length;\r\n        const value = this.stringifyProperty(\"value\");\r\n        if (name === \"value\") {\r\n            return value ? count : -1;\r\n        }\r\n        count += value.length;\r\n        count += valueSpaces.after.length;\r\n        const insensitiveSpaces = this._spacesFor(\"insensitive\");\r\n        count += insensitiveSpaces.before.length;\r\n        if (name === \"insensitive\") {\r\n            return (this.insensitive) ? count : -1;\r\n        }\r\n        return -1;\r\n    }\r\n    toString() {\r\n        const selector = [\r\n            this.rawSpaceBefore,\r\n            '[',\r\n        ];\r\n        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\r\n        if (this.operator && (this.value || this.value === '')) {\r\n            selector.push(this._stringFor('operator'));\r\n            selector.push(this._stringFor('value'));\r\n            selector.push(this._stringFor('insensitiveFlag', 'insensitive', (attrValue, attrSpaces) => {\r\n                if (attrValue.length > 0\r\n                    && !this.quoted\r\n                    && attrSpaces.before.length === 0\r\n                    && !(this.spaces.value && this.spaces.value.after)) {\r\n                    attrSpaces.before = \" \";\r\n                }\r\n                return defaultAttrConcat(attrValue, attrSpaces);\r\n            }));\r\n        }\r\n        selector.push(']');\r\n        selector.push(this.rawSpaceAfter);\r\n        return selector.join('');\r\n    }\r\n}\r\nconst CSSESC_QUOTE_OPTIONS = {\r\n    \"'\": { quotes: 'single', wrap: true },\r\n    '\"': { quotes: 'double', wrap: true },\r\n    [null]: { isIdentifier: true },\r\n};\r\nfunction defaultAttrConcat(attrValue, attrSpaces) {\r\n    return `${attrSpaces.before}${attrValue}${attrSpaces.after}`;\r\n}\r\n", "import Namespace from './namespace';\r\nimport { UNIVERSAL } from './types';\r\nexport default class Universal extends Namespace {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = UNIVERSAL;\r\n        this.value = '*';\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { COMBINATOR } from './types';\r\nexport default class Combinator extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = COMBINATOR;\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { NESTING } from './types';\r\nexport default class Nesting extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = NESTING;\r\n        this.value = '&';\r\n    }\r\n}\r\n", "export default function sortAscending(list) {\r\n    return list.sort((a, b) => a - b);\r\n}\r\n;\r\n", "export const ampersand = 38; // `&`.charCodeAt(0);\r\nexport const asterisk = 42; // `*`.charCodeAt(0);\r\nexport const at = 64; // `@`.charCodeAt(0);\r\nexport const comma = 44; // `,`.charCodeAt(0);\r\nexport const colon = 58; // `:`.charCodeAt(0);\r\nexport const semicolon = 59; // `;`.charCodeAt(0);\r\nexport const openParenthesis = 40; // `(`.charCodeAt(0);\r\nexport const closeParenthesis = 41; // `)`.charCodeAt(0);\r\nexport const openSquare = 91; // `[`.charCodeAt(0);\r\nexport const closeSquare = 93; // `]`.charCodeAt(0);\r\nexport const dollar = 36; // `$`.charCodeAt(0);\r\nexport const tilde = 126; // `~`.charCodeAt(0);\r\nexport const caret = 94; // `^`.charCodeAt(0);\r\nexport const plus = 43; // `+`.charCodeAt(0);\r\nexport const equals = 61; // `=`.charCodeAt(0);\r\nexport const pipe = 124; // `|`.charCodeAt(0);\r\nexport const greaterThan = 62; // `>`.charCodeAt(0);\r\nexport const space = 32; // ` `.charCodeAt(0);\r\nexport const singleQuote = 39; // `'`.charCodeAt(0);\r\nexport const doubleQuote = 34; // `\"`.charCodeAt(0);\r\nexport const slash = 47; // `/`.charCodeAt(0);\r\nexport const bang = 33; // `!`.charCodeAt(0);\r\nexport const backslash = 92; // '\\\\'.charCodeAt(0);\r\nexport const cr = 13; // '\\r'.charCodeAt(0);\r\nexport const feed = 12; // '\\f'.charCodeAt(0);\r\nexport const newline = 10; // '\\n'.charCodeAt(0);\r\nexport const tab = 9; // '\\t'.charCodeAt(0);\r\n// Expose aliases primarily for readability.\r\nexport const str = singleQuote;\r\n// No good single character representation!\r\nexport const comment = -1;\r\nexport const word = -2;\r\nexport const combinator = -3;\r\n", "import * as t from './tokenTypes';\r\nconst unescapable = {\r\n    [t.tab]: true,\r\n    [t.newline]: true,\r\n    [t.cr]: true,\r\n    [t.feed]: true,\r\n};\r\nconst wordDelimiters = {\r\n    [t.space]: true,\r\n    [t.tab]: true,\r\n    [t.newline]: true,\r\n    [t.cr]: true,\r\n    [t.feed]: true,\r\n    [t.ampersand]: true,\r\n    [t.asterisk]: true,\r\n    [t.bang]: true,\r\n    [t.comma]: true,\r\n    [t.colon]: true,\r\n    [t.semicolon]: true,\r\n    [t.openParenthesis]: true,\r\n    [t.closeParenthesis]: true,\r\n    [t.openSquare]: true,\r\n    [t.closeSquare]: true,\r\n    [t.singleQuote]: true,\r\n    [t.doubleQuote]: true,\r\n    [t.plus]: true,\r\n    [t.pipe]: true,\r\n    [t.tilde]: true,\r\n    [t.greaterThan]: true,\r\n    [t.equals]: true,\r\n    [t.dollar]: true,\r\n    [t.caret]: true,\r\n    [t.slash]: true,\r\n};\r\nconst hex = {};\r\nconst hexChars = \"0123456789abcdefABCDEF\";\r\nfor (let i = 0; i < hexChars.length; i++) {\r\n    hex[hexChars.charCodeAt(i)] = true;\r\n}\r\n/**\r\n *  Returns the last index of the bar css word\r\n * @param {string} css The string in which the word begins\r\n * @param {number} start The index into the string where word's first letter occurs\r\n */\r\nfunction consumeWord(css, start) {\r\n    let next = start;\r\n    let code;\r\n    do {\r\n        code = css.charCodeAt(next);\r\n        if (wordDelimiters[code]) {\r\n            return next - 1;\r\n        }\r\n        else if (code === t.backslash) {\r\n            next = consumeEscape(css, next) + 1;\r\n        }\r\n        else {\r\n            // All other characters are part of the word\r\n            next++;\r\n        }\r\n    } while (next < css.length);\r\n    return next - 1;\r\n}\r\n/**\r\n *  Returns the last index of the escape sequence\r\n * @param {string} css The string in which the sequence begins\r\n * @param {number} start The index into the string where escape character (`\\`) occurs.\r\n */\r\nfunction consumeEscape(css, start) {\r\n    let next = start;\r\n    let code = css.charCodeAt(next + 1);\r\n    if (unescapable[code]) {\r\n        // just consume the escape char\r\n    }\r\n    else if (hex[code]) {\r\n        let hexDigits = 0;\r\n        // consume up to 6 hex chars\r\n        do {\r\n            next++;\r\n            hexDigits++;\r\n            code = css.charCodeAt(next + 1);\r\n        } while (hex[code] && hexDigits < 6);\r\n        // if fewer than 6 hex chars, a trailing space ends the escape\r\n        if (hexDigits < 6 && code === t.space) {\r\n            next++;\r\n        }\r\n    }\r\n    else {\r\n        // the next char is part of the current word\r\n        next++;\r\n    }\r\n    return next;\r\n}\r\nexport const FIELDS = {\r\n    TYPE: 0,\r\n    START_LINE: 1,\r\n    START_COL: 2,\r\n    END_LINE: 3,\r\n    END_COL: 4,\r\n    START_POS: 5,\r\n    END_POS: 6,\r\n};\r\nexport default function tokenize(input) {\r\n    const tokens = [];\r\n    let css = input.css.valueOf();\r\n    let { length } = css;\r\n    let offset = -1;\r\n    let line = 1;\r\n    let start = 0;\r\n    let end = 0;\r\n    let code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\r\n    function unclosed(what, fix) {\r\n        if (input.safe) { // fyi: this is never set to true.\r\n            css += fix;\r\n            next = css.length - 1;\r\n        }\r\n        else {\r\n            throw input.error('Unclosed ' + what, line, start - offset, start);\r\n        }\r\n    }\r\n    while (start < length) {\r\n        code = css.charCodeAt(start);\r\n        if (code === t.newline) {\r\n            offset = start;\r\n            line += 1;\r\n        }\r\n        switch (code) {\r\n            case t.space:\r\n            case t.tab:\r\n            case t.newline:\r\n            case t.cr:\r\n            case t.feed:\r\n                next = start;\r\n                do {\r\n                    next += 1;\r\n                    code = css.charCodeAt(next);\r\n                    if (code === t.newline) {\r\n                        offset = next;\r\n                        line += 1;\r\n                    }\r\n                } while (code === t.space ||\r\n                    code === t.newline ||\r\n                    code === t.tab ||\r\n                    code === t.cr ||\r\n                    code === t.feed);\r\n                tokenType = t.space;\r\n                endLine = line;\r\n                endColumn = next - offset - 1;\r\n                end = next;\r\n                break;\r\n            case t.plus:\r\n            case t.greaterThan:\r\n            case t.tilde:\r\n            case t.pipe:\r\n                next = start;\r\n                do {\r\n                    next += 1;\r\n                    code = css.charCodeAt(next);\r\n                } while (code === t.plus ||\r\n                    code === t.greaterThan ||\r\n                    code === t.tilde ||\r\n                    code === t.pipe);\r\n                tokenType = t.combinator;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next;\r\n                break;\r\n            // Consume these characters as single tokens.\r\n            case t.asterisk:\r\n            case t.ampersand:\r\n            case t.bang:\r\n            case t.comma:\r\n            case t.equals:\r\n            case t.dollar:\r\n            case t.caret:\r\n            case t.openSquare:\r\n            case t.closeSquare:\r\n            case t.colon:\r\n            case t.semicolon:\r\n            case t.openParenthesis:\r\n            case t.closeParenthesis:\r\n                next = start;\r\n                tokenType = code;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next + 1;\r\n                break;\r\n            case t.singleQuote:\r\n            case t.doubleQuote:\r\n                quote = code === t.singleQuote ? \"'\" : '\"';\r\n                next = start;\r\n                do {\r\n                    escaped = false;\r\n                    next = css.indexOf(quote, next + 1);\r\n                    if (next === -1) {\r\n                        unclosed('quote', quote);\r\n                    }\r\n                    escapePos = next;\r\n                    while (css.charCodeAt(escapePos - 1) === t.backslash) {\r\n                        escapePos -= 1;\r\n                        escaped = !escaped;\r\n                    }\r\n                } while (escaped);\r\n                tokenType = t.str;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next + 1;\r\n                break;\r\n            default:\r\n                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\r\n                    next = css.indexOf('*/', start + 2) + 1;\r\n                    if (next === 0) {\r\n                        unclosed('comment', '*/');\r\n                    }\r\n                    content = css.slice(start, next + 1);\r\n                    lines = content.split('\\n');\r\n                    last = lines.length - 1;\r\n                    if (last > 0) {\r\n                        nextLine = line + last;\r\n                        nextOffset = next - lines[last].length;\r\n                    }\r\n                    else {\r\n                        nextLine = line;\r\n                        nextOffset = offset;\r\n                    }\r\n                    tokenType = t.comment;\r\n                    line = nextLine;\r\n                    endLine = nextLine;\r\n                    endColumn = next - nextOffset;\r\n                }\r\n                else if (code === t.slash) {\r\n                    next = start;\r\n                    tokenType = code;\r\n                    endLine = line;\r\n                    endColumn = start - offset;\r\n                    end = next + 1;\r\n                }\r\n                else {\r\n                    next = consumeWord(css, start);\r\n                    tokenType = t.word;\r\n                    endLine = line;\r\n                    endColumn = next - offset;\r\n                }\r\n                end = next + 1;\r\n                break;\r\n        }\r\n        // Ensure that the token structure remains consistent\r\n        tokens.push([\r\n            tokenType, // [0] Token type\r\n            line, // [1] Starting line\r\n            start - offset, // [2] Starting column\r\n            endLine, // [3] Ending line\r\n            endColumn, // [4] Ending column\r\n            start, // [5] Start position / Source index\r\n            end, // [6] End position\r\n        ]);\r\n        // Reset offset for the next token\r\n        if (nextOffset) {\r\n            offset = nextOffset;\r\n            nextOffset = null;\r\n        }\r\n        start = end;\r\n    }\r\n    return tokens;\r\n}\r\n", "import Root from './selectors/root';\r\nimport Selector from './selectors/selector';\r\nimport ClassName from './selectors/className';\r\nimport Comment from './selectors/comment';\r\nimport ID from './selectors/id';\r\nimport Tag from './selectors/tag';\r\nimport Str from './selectors/string';\r\nimport Pseudo from './selectors/pseudo';\r\nimport Attribute, { unescapeValue } from './selectors/attribute';\r\nimport Universal from './selectors/universal';\r\nimport Combinator from './selectors/combinator';\r\nimport Nesting from './selectors/nesting';\r\nimport sortAsc from './sortAscending';\r\nimport tokenize, { FIELDS as TOKEN } from './tokenize';\r\nimport * as tokens from './tokenTypes';\r\nimport * as types from './selectors/types';\r\nimport { unesc, getProp, ensureObject } from './util';\r\nconst WHITESPACE_TOKENS = {\r\n    [tokens.space]: true,\r\n    [tokens.cr]: true,\r\n    [tokens.feed]: true,\r\n    [tokens.newline]: true,\r\n    [tokens.tab]: true,\r\n};\r\nconst WHITESPACE_EQUIV_TOKENS = {\r\n    ...WHITESPACE_TOKENS,\r\n    [tokens.comment]: true,\r\n};\r\nfunction tokenStart(token) {\r\n    return {\r\n        line: token[TOKEN.START_LINE],\r\n        column: token[TOKEN.START_COL],\r\n    };\r\n}\r\nfunction tokenEnd(token) {\r\n    return {\r\n        line: token[TOKEN.END_LINE],\r\n        column: token[TOKEN.END_COL],\r\n    };\r\n}\r\nfunction getSource(startLine, startColumn, endLine, endColumn) {\r\n    return {\r\n        start: {\r\n            line: startLine,\r\n            column: startColumn,\r\n        },\r\n        end: {\r\n            line: endLine,\r\n            column: endColumn,\r\n        },\r\n    };\r\n}\r\nfunction getTokenSource(token) {\r\n    return getSource(token[TOKEN.START_LINE], token[TOKEN.START_COL], token[TOKEN.END_LINE], token[TOKEN.END_COL]);\r\n}\r\nfunction getTokenSourceSpan(startToken, endToken) {\r\n    if (!startToken) {\r\n        return undefined;\r\n    }\r\n    return getSource(startToken[TOKEN.START_LINE], startToken[TOKEN.START_COL], endToken[TOKEN.END_LINE], endToken[TOKEN.END_COL]);\r\n}\r\nfunction unescapeProp(node, prop) {\r\n    let value = node[prop];\r\n    if (typeof value !== \"string\") {\r\n        return;\r\n    }\r\n    if (value.indexOf(\"\\\\\") !== -1) {\r\n        ensureObject(node, 'raws');\r\n        node[prop] = unesc(value);\r\n        if (node.raws[prop] === undefined) {\r\n            node.raws[prop] = value;\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction indexesOf(array, item) {\r\n    let i = -1;\r\n    const indexes = [];\r\n    while ((i = array.indexOf(item, i + 1)) !== -1) {\r\n        indexes.push(i);\r\n    }\r\n    return indexes;\r\n}\r\nfunction uniqs() {\r\n    const list = Array.prototype.concat.apply([], arguments);\r\n    return list.filter((item, i) => i === list.indexOf(item));\r\n}\r\nexport default class Parser {\r\n    constructor(rule, options = {}) {\r\n        this.rule = rule;\r\n        this.options = Object.assign({ lossy: false, safe: false }, options);\r\n        this.position = 0;\r\n        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\r\n        this.tokens = tokenize({\r\n            css: this.css,\r\n            error: this._errorGenerator(),\r\n            safe: this.options.safe,\r\n        });\r\n        let rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\r\n        this.root = new Root({ source: rootSource });\r\n        this.root.errorGenerator = this._errorGenerator();\r\n        const selector = new Selector({\r\n            source: { start: { line: 1, column: 1 } },\r\n            sourceIndex: 0,\r\n        });\r\n        this.root.append(selector);\r\n        this.current = selector;\r\n        this.loop();\r\n    }\r\n    _errorGenerator() {\r\n        return (message, errorOptions) => {\r\n            if (typeof this.rule === 'string') {\r\n                return new Error(message);\r\n            }\r\n            return this.rule.error(message, errorOptions);\r\n        };\r\n    }\r\n    attribute() {\r\n        const attr = [];\r\n        const startingToken = this.currToken;\r\n        this.position++;\r\n        while (this.position < this.tokens.length &&\r\n            this.currToken[TOKEN.TYPE] !== tokens.closeSquare) {\r\n            attr.push(this.currToken);\r\n            this.position++;\r\n        }\r\n        if (this.currToken[TOKEN.TYPE] !== tokens.closeSquare) {\r\n            return this.expected('closing square bracket', this.currToken[TOKEN.START_POS]);\r\n        }\r\n        const len = attr.length;\r\n        const node = {\r\n            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\r\n            sourceIndex: startingToken[TOKEN.START_POS],\r\n        };\r\n        if (len === 1 && !~[tokens.word].indexOf(attr[0][TOKEN.TYPE])) {\r\n            return this.expected('attribute', attr[0][TOKEN.START_POS]);\r\n        }\r\n        let pos = 0;\r\n        let spaceBefore = '';\r\n        let commentBefore = '';\r\n        let lastAdded = null;\r\n        let spaceAfterMeaningfulToken = false;\r\n        while (pos < len) {\r\n            const token = attr[pos];\r\n            const content = this.content(token);\r\n            const next = attr[pos + 1];\r\n            switch (token[TOKEN.TYPE]) {\r\n                case tokens.space:\r\n                    // if (\r\n                    //     len === 1 ||\r\n                    //     pos === 0 && this.content(next) === '|'\r\n                    // ) {\r\n                    //     return this.expected('attribute', token[TOKEN.START_POS], content);\r\n                    // }\r\n                    spaceAfterMeaningfulToken = true;\r\n                    if (this.options.lossy) {\r\n                        break;\r\n                    }\r\n                    if (lastAdded) {\r\n                        ensureObject(node, 'spaces', lastAdded);\r\n                        const prevContent = node.spaces[lastAdded].after || '';\r\n                        node.spaces[lastAdded].after = prevContent + content;\r\n                        const existingComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || null;\r\n                        if (existingComment) {\r\n                            node.raws.spaces[lastAdded].after = existingComment + content;\r\n                        }\r\n                    }\r\n                    else {\r\n                        spaceBefore = spaceBefore + content;\r\n                        commentBefore = commentBefore + content;\r\n                    }\r\n                    break;\r\n                case tokens.asterisk:\r\n                    if (next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    else if ((!node.namespace || (lastAdded === \"namespace\" && !spaceAfterMeaningfulToken)) && next) {\r\n                        if (spaceBefore) {\r\n                            ensureObject(node, 'spaces', 'attribute');\r\n                            node.spaces.attribute.before = spaceBefore;\r\n                            spaceBefore = '';\r\n                        }\r\n                        if (commentBefore) {\r\n                            ensureObject(node, 'raws', 'spaces', 'attribute');\r\n                            node.raws.spaces.attribute.before = spaceBefore;\r\n                            commentBefore = '';\r\n                        }\r\n                        node.namespace = (node.namespace || \"\") + content;\r\n                        const rawValue = getProp(node, 'raws', 'namespace') || null;\r\n                        if (rawValue) {\r\n                            node.raws.namespace += content;\r\n                        }\r\n                        lastAdded = 'namespace';\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.dollar:\r\n                    if (lastAdded === \"value\") {\r\n                        let oldRawValue = getProp(node, 'raws', 'value');\r\n                        node.value += \"$\";\r\n                        if (oldRawValue) {\r\n                            node.raws.value = oldRawValue + \"$\";\r\n                        }\r\n                        break;\r\n                    }\r\n                // Falls through\r\n                case tokens.caret:\r\n                    if (next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.combinator:\r\n                    if (content === '~' && next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    if (content !== '|') {\r\n                        spaceAfterMeaningfulToken = false;\r\n                        break;\r\n                    }\r\n                    if (next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    else if (!node.namespace && !node.attribute) {\r\n                        node.namespace = true;\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.word:\r\n                    if (next &&\r\n                        this.content(next) === '|' &&\r\n                        (attr[pos + 2] && attr[pos + 2][TOKEN.TYPE] !== tokens.equals) && // this look-ahead probably fails with comment nodes involved.\r\n                        !node.operator &&\r\n                        !node.namespace) {\r\n                        node.namespace = content;\r\n                        lastAdded = 'namespace';\r\n                    }\r\n                    else if (!node.attribute || (lastAdded === \"attribute\" && !spaceAfterMeaningfulToken)) {\r\n                        if (spaceBefore) {\r\n                            ensureObject(node, 'spaces', 'attribute');\r\n                            node.spaces.attribute.before = spaceBefore;\r\n                            spaceBefore = '';\r\n                        }\r\n                        if (commentBefore) {\r\n                            ensureObject(node, 'raws', 'spaces', 'attribute');\r\n                            node.raws.spaces.attribute.before = commentBefore;\r\n                            commentBefore = '';\r\n                        }\r\n                        node.attribute = (node.attribute || \"\") + content;\r\n                        const rawValue = getProp(node, 'raws', 'attribute') || null;\r\n                        if (rawValue) {\r\n                            node.raws.attribute += content;\r\n                        }\r\n                        lastAdded = 'attribute';\r\n                    }\r\n                    else if ((!node.value && node.value !== \"\") || (lastAdded === \"value\" && !(spaceAfterMeaningfulToken || node.quoteMark))) {\r\n                        let unescaped = unesc(content);\r\n                        let oldRawValue = getProp(node, 'raws', 'value') || '';\r\n                        let oldValue = node.value || '';\r\n                        node.value = oldValue + unescaped;\r\n                        node.quoteMark = null;\r\n                        if (unescaped !== content || oldRawValue) {\r\n                            ensureObject(node, 'raws');\r\n                            node.raws.value = (oldRawValue || oldValue) + content;\r\n                        }\r\n                        lastAdded = 'value';\r\n                    }\r\n                    else {\r\n                        let insensitive = (content === 'i' || content === \"I\");\r\n                        if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\r\n                            node.insensitive = insensitive;\r\n                            if (!insensitive || content === \"I\") {\r\n                                ensureObject(node, 'raws');\r\n                                node.raws.insensitiveFlag = content;\r\n                            }\r\n                            lastAdded = 'insensitive';\r\n                            if (spaceBefore) {\r\n                                ensureObject(node, 'spaces', 'insensitive');\r\n                                node.spaces.insensitive.before = spaceBefore;\r\n                                spaceBefore = '';\r\n                            }\r\n                            if (commentBefore) {\r\n                                ensureObject(node, 'raws', 'spaces', 'insensitive');\r\n                                node.raws.spaces.insensitive.before = commentBefore;\r\n                                commentBefore = '';\r\n                            }\r\n                        }\r\n                        else if (node.value || node.value === '') {\r\n                            lastAdded = 'value';\r\n                            node.value += content;\r\n                            if (node.raws.value) {\r\n                                node.raws.value += content;\r\n                            }\r\n                        }\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.str:\r\n                    if (!node.attribute || !node.operator) {\r\n                        return this.error(`Expected an attribute followed by an operator preceding the string.`, {\r\n                            index: token[TOKEN.START_POS],\r\n                        });\r\n                    }\r\n                    let { unescaped, quoteMark } = unescapeValue(content);\r\n                    node.value = unescaped;\r\n                    node.quoteMark = quoteMark;\r\n                    lastAdded = 'value';\r\n                    ensureObject(node, 'raws');\r\n                    node.raws.value = content;\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.equals:\r\n                    if (!node.attribute) {\r\n                        return this.expected('attribute', token[TOKEN.START_POS], content);\r\n                    }\r\n                    if (node.value) {\r\n                        return this.error('Unexpected \"=\" found; an operator was already defined.', { index: token[TOKEN.START_POS] });\r\n                    }\r\n                    node.operator = node.operator ? node.operator + content : content;\r\n                    lastAdded = 'operator';\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.comment:\r\n                    if (lastAdded) {\r\n                        if (spaceAfterMeaningfulToken || (next && next[TOKEN.TYPE] === tokens.space) ||\r\n                            lastAdded === 'insensitive') {\r\n                            const lastComment = getProp(node, 'spaces', lastAdded, 'after') || '';\r\n                            const rawLastComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\r\n                            ensureObject(node, 'raws', 'spaces', lastAdded);\r\n                            node.raws.spaces[lastAdded].after = rawLastComment + content;\r\n                        }\r\n                        else {\r\n                            const lastValue = node[lastAdded] || '';\r\n                            const rawLastValue = getProp(node, 'raws', lastAdded) || lastValue;\r\n                            ensureObject(node, 'raws');\r\n                            node.raws[lastAdded] = rawLastValue + content;\r\n                        }\r\n                    }\r\n                    else {\r\n                        commentBefore = commentBefore + content;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return this.error(`Unexpected \"${content}\" found.`, { index: token[TOKEN.START_POS] });\r\n            }\r\n            pos++;\r\n        }\r\n        unescapeProp(node, \"attribute\");\r\n        unescapeProp(node, \"namespace\");\r\n        this.newNode(new Attribute(node));\r\n        this.position++;\r\n    }\r\n    /**\r\n     * return a node containing meaningless garbage up to (but not including) the specified token position.\r\n     * if the token position is negative, all remaining tokens are consumed.\r\n     *\r\n     * This returns an array containing a single string node if all whitespace,\r\n     * otherwise an array of comment nodes with space before and after.\r\n     *\r\n     * These tokens are not added to the current selector, the caller can add them or use them to amend\r\n     * a previous node's space metadata.\r\n     *\r\n     * In lossy mode, this returns only comments.\r\n     */\r\n    parseWhitespaceEquivalentTokens(stopPosition) {\r\n        if (stopPosition < 0) {\r\n            stopPosition = this.tokens.length;\r\n        }\r\n        let startPosition = this.position;\r\n        let nodes = [];\r\n        let space = \"\";\r\n        let lastComment = undefined;\r\n        do {\r\n            if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\r\n                if (!this.options.lossy) {\r\n                    space += this.content();\r\n                }\r\n            }\r\n            else if (this.currToken[TOKEN.TYPE] === tokens.comment) {\r\n                let spaces = {};\r\n                if (space) {\r\n                    spaces.before = space;\r\n                    space = \"\";\r\n                }\r\n                lastComment = new Comment({\r\n                    value: this.content(),\r\n                    source: getTokenSource(this.currToken),\r\n                    sourceIndex: this.currToken[TOKEN.START_POS],\r\n                    spaces,\r\n                });\r\n                nodes.push(lastComment);\r\n            }\r\n        } while (++this.position < stopPosition);\r\n        if (space) {\r\n            if (lastComment) {\r\n                lastComment.spaces.after = space;\r\n            }\r\n            else if (!this.options.lossy) {\r\n                let firstToken = this.tokens[startPosition];\r\n                let lastToken = this.tokens[this.position - 1];\r\n                nodes.push(new Str({\r\n                    value: '',\r\n                    source: getSource(firstToken[TOKEN.START_LINE], firstToken[TOKEN.START_COL], lastToken[TOKEN.END_LINE], lastToken[TOKEN.END_COL]),\r\n                    sourceIndex: firstToken[TOKEN.START_POS],\r\n                    spaces: { before: space, after: '' },\r\n                }));\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n    /**\r\n     *\r\n     * @param {*} nodes\r\n     */\r\n    convertWhitespaceNodesToSpace(nodes, requiredSpace = false) {\r\n        let space = \"\";\r\n        let rawSpace = \"\";\r\n        nodes.forEach(n => {\r\n            let spaceBefore = this.lossySpace(n.spaces.before, requiredSpace);\r\n            let rawSpaceBefore = this.lossySpace(n.rawSpaceBefore, requiredSpace);\r\n            space += spaceBefore + this.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\r\n            rawSpace += spaceBefore + n.value + this.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\r\n        });\r\n        if (rawSpace === space) {\r\n            rawSpace = undefined;\r\n        }\r\n        let result = { space, rawSpace };\r\n        return result;\r\n    }\r\n    isNamedCombinator(position = this.position) {\r\n        return this.tokens[position + 0] && this.tokens[position + 0][TOKEN.TYPE] === tokens.slash &&\r\n            this.tokens[position + 1] && this.tokens[position + 1][TOKEN.TYPE] === tokens.word &&\r\n            this.tokens[position + 2] && this.tokens[position + 2][TOKEN.TYPE] === tokens.slash;\r\n    }\r\n    namedCombinator() {\r\n        if (this.isNamedCombinator()) {\r\n            let nameRaw = this.content(this.tokens[this.position + 1]);\r\n            let name = unesc(nameRaw).toLowerCase();\r\n            let raws = {};\r\n            if (name !== nameRaw) {\r\n                raws.value = `/${nameRaw}/`;\r\n            }\r\n            let node = new Combinator({\r\n                value: `/${name}/`,\r\n                source: getSource(this.currToken[TOKEN.START_LINE], this.currToken[TOKEN.START_COL], this.tokens[this.position + 2][TOKEN.END_LINE], this.tokens[this.position + 2][TOKEN.END_COL]),\r\n                sourceIndex: this.currToken[TOKEN.START_POS],\r\n                raws,\r\n            });\r\n            this.position = this.position + 3;\r\n            return node;\r\n        }\r\n        else {\r\n            this.unexpected();\r\n        }\r\n    }\r\n    combinator() {\r\n        if (this.content() === '|') {\r\n            return this.namespace();\r\n        }\r\n        // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\r\n        let nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\r\n        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.closeParenthesis) {\r\n            let nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\r\n            if (nodes.length > 0) {\r\n                let last = this.current.last;\r\n                if (last) {\r\n                    let { space, rawSpace } = this.convertWhitespaceNodesToSpace(nodes);\r\n                    if (rawSpace !== undefined) {\r\n                        last.rawSpaceAfter += rawSpace;\r\n                    }\r\n                    last.spaces.after += space;\r\n                }\r\n                else {\r\n                    nodes.forEach(n => this.newNode(n));\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        let firstToken = this.currToken;\r\n        let spaceOrDescendantSelectorNodes = undefined;\r\n        if (nextSigTokenPos > this.position) {\r\n            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\r\n        }\r\n        let node;\r\n        if (this.isNamedCombinator()) {\r\n            node = this.namedCombinator();\r\n        }\r\n        else if (this.currToken[TOKEN.TYPE] === tokens.combinator) {\r\n            node = new Combinator({\r\n                value: this.content(),\r\n                source: getTokenSource(this.currToken),\r\n                sourceIndex: this.currToken[TOKEN.START_POS],\r\n            });\r\n            this.position++;\r\n        }\r\n        else if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\r\n            // pass\r\n        }\r\n        else if (!spaceOrDescendantSelectorNodes) {\r\n            this.unexpected();\r\n        }\r\n        if (node) {\r\n            if (spaceOrDescendantSelectorNodes) {\r\n                let { space, rawSpace } = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes);\r\n                node.spaces.before = space;\r\n                node.rawSpaceBefore = rawSpace;\r\n            }\r\n        }\r\n        else {\r\n            // descendant combinator\r\n            let { space, rawSpace } = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true);\r\n            if (!rawSpace) {\r\n                rawSpace = space;\r\n            }\r\n            let spaces = {};\r\n            let raws = { spaces: {} };\r\n            if (space.endsWith(' ') && rawSpace.endsWith(' ')) {\r\n                spaces.before = space.slice(0, space.length - 1);\r\n                raws.spaces.before = rawSpace.slice(0, rawSpace.length - 1);\r\n            }\r\n            else if (space.startsWith(' ') && rawSpace.startsWith(' ')) {\r\n                spaces.after = space.slice(1);\r\n                raws.spaces.after = rawSpace.slice(1);\r\n            }\r\n            else {\r\n                raws.value = rawSpace;\r\n            }\r\n            node = new Combinator({\r\n                value: ' ',\r\n                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\r\n                sourceIndex: firstToken[TOKEN.START_POS],\r\n                spaces,\r\n                raws,\r\n            });\r\n        }\r\n        if (this.currToken && this.currToken[TOKEN.TYPE] === tokens.space) {\r\n            node.spaces.after = this.optionalSpace(this.content());\r\n            this.position++;\r\n        }\r\n        return this.newNode(node);\r\n    }\r\n    comma() {\r\n        if (this.position === this.tokens.length - 1) {\r\n            this.root.trailingComma = true;\r\n            this.position++;\r\n            return;\r\n        }\r\n        this.current._inferEndPosition();\r\n        const selector = new Selector({\r\n            source: {\r\n                start: tokenStart(this.tokens[this.position + 1]),\r\n            },\r\n            sourceIndex: this.tokens[this.position + 1][TOKEN.START_POS],\r\n        });\r\n        this.current.parent.append(selector);\r\n        this.current = selector;\r\n        this.position++;\r\n    }\r\n    comment() {\r\n        const current = this.currToken;\r\n        this.newNode(new Comment({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }));\r\n        this.position++;\r\n    }\r\n    error(message, opts) {\r\n        throw this.root.error(message, opts);\r\n    }\r\n    missingBackslash() {\r\n        return this.error('Expected a backslash preceding the semicolon.', {\r\n            index: this.currToken[TOKEN.START_POS],\r\n        });\r\n    }\r\n    missingParenthesis() {\r\n        return this.expected('opening parenthesis', this.currToken[TOKEN.START_POS]);\r\n    }\r\n    missingSquareBracket() {\r\n        return this.expected('opening square bracket', this.currToken[TOKEN.START_POS]);\r\n    }\r\n    unexpected() {\r\n        return this.error(`Unexpected '${this.content()}'. Escaping special characters with \\\\ may help.`, this.currToken[TOKEN.START_POS]);\r\n    }\r\n    unexpectedPipe() {\r\n        return this.error(`Unexpected '|'.`, this.currToken[TOKEN.START_POS]);\r\n    }\r\n    namespace() {\r\n        const before = this.prevToken && this.content(this.prevToken) || true;\r\n        if (this.nextToken[TOKEN.TYPE] === tokens.word) {\r\n            this.position++;\r\n            return this.word(before);\r\n        }\r\n        else if (this.nextToken[TOKEN.TYPE] === tokens.asterisk) {\r\n            this.position++;\r\n            return this.universal(before);\r\n        }\r\n        this.unexpectedPipe();\r\n    }\r\n    nesting() {\r\n        if (this.nextToken) {\r\n            let nextContent = this.content(this.nextToken);\r\n            if (nextContent === \"|\") {\r\n                this.position++;\r\n                return;\r\n            }\r\n        }\r\n        const current = this.currToken;\r\n        this.newNode(new Nesting({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }));\r\n        this.position++;\r\n    }\r\n    parentheses() {\r\n        let last = this.current.last;\r\n        let unbalanced = 1;\r\n        this.position++;\r\n        if (last && last.type === types.PSEUDO) {\r\n            const selector = new Selector({\r\n                source: { start: tokenStart(this.tokens[this.position]) },\r\n                sourceIndex: this.tokens[this.position][TOKEN.START_POS],\r\n            });\r\n            const cache = this.current;\r\n            last.append(selector);\r\n            this.current = selector;\r\n            while (this.position < this.tokens.length && unbalanced) {\r\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\r\n                    unbalanced++;\r\n                }\r\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\r\n                    unbalanced--;\r\n                }\r\n                if (unbalanced) {\r\n                    this.parse();\r\n                }\r\n                else {\r\n                    this.current.source.end = tokenEnd(this.currToken);\r\n                    this.current.parent.source.end = tokenEnd(this.currToken);\r\n                    this.position++;\r\n                }\r\n            }\r\n            this.current = cache;\r\n        }\r\n        else {\r\n            // I think this case should be an error. It's used to implement a basic parse of media queries\r\n            // but I don't think it's a good idea.\r\n            let parenStart = this.currToken;\r\n            let parenValue = \"(\";\r\n            let parenEnd;\r\n            while (this.position < this.tokens.length && unbalanced) {\r\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\r\n                    unbalanced++;\r\n                }\r\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\r\n                    unbalanced--;\r\n                }\r\n                parenEnd = this.currToken;\r\n                parenValue += this.parseParenthesisToken(this.currToken);\r\n                this.position++;\r\n            }\r\n            if (last) {\r\n                last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\r\n            }\r\n            else {\r\n                this.newNode(new Str({\r\n                    value: parenValue,\r\n                    source: getSource(parenStart[TOKEN.START_LINE], parenStart[TOKEN.START_COL], parenEnd[TOKEN.END_LINE], parenEnd[TOKEN.END_COL]),\r\n                    sourceIndex: parenStart[TOKEN.START_POS],\r\n                }));\r\n            }\r\n        }\r\n        if (unbalanced) {\r\n            return this.expected('closing parenthesis', this.currToken[TOKEN.START_POS]);\r\n        }\r\n    }\r\n    pseudo() {\r\n        let pseudoStr = '';\r\n        let startingToken = this.currToken;\r\n        while (this.currToken && this.currToken[TOKEN.TYPE] === tokens.colon) {\r\n            pseudoStr += this.content();\r\n            this.position++;\r\n        }\r\n        if (!this.currToken) {\r\n            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\r\n        }\r\n        if (this.currToken[TOKEN.TYPE] === tokens.word) {\r\n            this.splitWord(false, (first, length) => {\r\n                pseudoStr += first;\r\n                this.newNode(new Pseudo({\r\n                    value: pseudoStr,\r\n                    source: getTokenSourceSpan(startingToken, this.currToken),\r\n                    sourceIndex: startingToken[TOKEN.START_POS],\r\n                }));\r\n                if (length > 1 &&\r\n                    this.nextToken &&\r\n                    this.nextToken[TOKEN.TYPE] === tokens.openParenthesis) {\r\n                    this.error('Misplaced parenthesis.', {\r\n                        index: this.nextToken[TOKEN.START_POS],\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[TOKEN.START_POS]);\r\n        }\r\n    }\r\n    space() {\r\n        const content = this.content();\r\n        // Handle space before and after the selector\r\n        if (this.position === 0 ||\r\n            this.prevToken[TOKEN.TYPE] === tokens.comma ||\r\n            this.prevToken[TOKEN.TYPE] === tokens.openParenthesis ||\r\n            (this.current.nodes.every((node) => node.type === 'comment'))) {\r\n            this.spaces = this.optionalSpace(content);\r\n            this.position++;\r\n        }\r\n        else if (this.position === (this.tokens.length - 1) ||\r\n            this.nextToken[TOKEN.TYPE] === tokens.comma ||\r\n            this.nextToken[TOKEN.TYPE] === tokens.closeParenthesis) {\r\n            this.current.last.spaces.after = this.optionalSpace(content);\r\n            this.position++;\r\n        }\r\n        else {\r\n            this.combinator();\r\n        }\r\n    }\r\n    string() {\r\n        const current = this.currToken;\r\n        this.newNode(new Str({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }));\r\n        this.position++;\r\n    }\r\n    universal(namespace) {\r\n        const nextToken = this.nextToken;\r\n        if (nextToken && this.content(nextToken) === '|') {\r\n            this.position++;\r\n            return this.namespace();\r\n        }\r\n        const current = this.currToken;\r\n        this.newNode(new Universal({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }), namespace);\r\n        this.position++;\r\n    }\r\n    splitWord(namespace, firstCallback) {\r\n        let nextToken = this.nextToken;\r\n        let word = this.content();\r\n        while (nextToken &&\r\n            ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[TOKEN.TYPE])) {\r\n            this.position++;\r\n            let current = this.content();\r\n            word += current;\r\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\r\n                let next = this.nextToken;\r\n                if (next && next[TOKEN.TYPE] === tokens.space) {\r\n                    word += this.requiredSpace(this.content(next));\r\n                    this.position++;\r\n                }\r\n            }\r\n            nextToken = this.nextToken;\r\n        }\r\n        const hasClass = indexesOf(word, '.').filter(i => {\r\n            // Allow escaped dot within class name\r\n            const escapedDot = word[i - 1] === '\\\\';\r\n            // Allow decimal numbers percent in @keyframes\r\n            const isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\r\n            return !escapedDot && !isKeyframesPercent;\r\n        });\r\n        let hasId = indexesOf(word, '#').filter(i => word[i - 1] !== '\\\\');\r\n        // Eliminate Sass interpolations from the list of id indexes\r\n        const interpolations = indexesOf(word, '#{');\r\n        if (interpolations.length) {\r\n            hasId = hasId.filter(hashIndex => !~interpolations.indexOf(hashIndex));\r\n        }\r\n        let indices = sortAsc(uniqs([0, ...hasClass, ...hasId]));\r\n        indices.forEach((ind, i) => {\r\n            const index = indices[i + 1] || word.length;\r\n            const value = word.slice(ind, index);\r\n            if (i === 0 && firstCallback) {\r\n                return firstCallback.call(this, value, indices.length);\r\n            }\r\n            let node;\r\n            const current = this.currToken;\r\n            const sourceIndex = current[TOKEN.START_POS] + indices[i];\r\n            const source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\r\n            if (~hasClass.indexOf(ind)) {\r\n                let classNameOpts = {\r\n                    value: value.slice(1),\r\n                    source,\r\n                    sourceIndex,\r\n                };\r\n                node = new ClassName(unescapeProp(classNameOpts, \"value\"));\r\n            }\r\n            else if (~hasId.indexOf(ind)) {\r\n                let idOpts = {\r\n                    value: value.slice(1),\r\n                    source,\r\n                    sourceIndex,\r\n                };\r\n                node = new ID(unescapeProp(idOpts, \"value\"));\r\n            }\r\n            else {\r\n                let tagOpts = {\r\n                    value,\r\n                    source,\r\n                    sourceIndex,\r\n                };\r\n                unescapeProp(tagOpts, \"value\");\r\n                node = new Tag(tagOpts);\r\n            }\r\n            this.newNode(node, namespace);\r\n            // Ensure that the namespace is used only once\r\n            namespace = null;\r\n        });\r\n        this.position++;\r\n    }\r\n    word(namespace) {\r\n        const nextToken = this.nextToken;\r\n        if (nextToken && this.content(nextToken) === '|') {\r\n            this.position++;\r\n            return this.namespace();\r\n        }\r\n        return this.splitWord(namespace);\r\n    }\r\n    loop() {\r\n        while (this.position < this.tokens.length) {\r\n            this.parse(true);\r\n        }\r\n        this.current._inferEndPosition();\r\n        return this.root;\r\n    }\r\n    parse(throwOnParenthesis) {\r\n        switch (this.currToken[TOKEN.TYPE]) {\r\n            case tokens.space:\r\n                this.space();\r\n                break;\r\n            case tokens.comment:\r\n                this.comment();\r\n                break;\r\n            case tokens.openParenthesis:\r\n                this.parentheses();\r\n                break;\r\n            case tokens.closeParenthesis:\r\n                if (throwOnParenthesis) {\r\n                    this.missingParenthesis();\r\n                }\r\n                break;\r\n            case tokens.openSquare:\r\n                this.attribute();\r\n                break;\r\n            case tokens.dollar:\r\n            case tokens.caret:\r\n            case tokens.equals:\r\n            case tokens.word:\r\n                this.word();\r\n                break;\r\n            case tokens.colon:\r\n                this.pseudo();\r\n                break;\r\n            case tokens.comma:\r\n                this.comma();\r\n                break;\r\n            case tokens.asterisk:\r\n                this.universal();\r\n                break;\r\n            case tokens.ampersand:\r\n                this.nesting();\r\n                break;\r\n            case tokens.slash:\r\n            case tokens.combinator:\r\n                this.combinator();\r\n                break;\r\n            case tokens.str:\r\n                this.string();\r\n                break;\r\n            // These cases throw; no break needed.\r\n            case tokens.closeSquare:\r\n                this.missingSquareBracket();\r\n            case tokens.semicolon:\r\n                this.missingBackslash();\r\n            default:\r\n                this.unexpected();\r\n        }\r\n    }\r\n    /**\r\n     * Helpers\r\n     */\r\n    expected(description, index, found) {\r\n        if (Array.isArray(description)) {\r\n            const last = description.pop();\r\n            description = `${description.join(', ')} or ${last}`;\r\n        }\r\n        const an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\r\n        if (!found) {\r\n            return this.error(`Expected ${an} ${description}.`, { index });\r\n        }\r\n        return this.error(`Expected ${an} ${description}, found \"${found}\" instead.`, { index });\r\n    }\r\n    requiredSpace(space) {\r\n        return this.options.lossy ? ' ' : space;\r\n    }\r\n    optionalSpace(space) {\r\n        return this.options.lossy ? '' : space;\r\n    }\r\n    lossySpace(space, required) {\r\n        if (this.options.lossy) {\r\n            return required ? ' ' : '';\r\n        }\r\n        else {\r\n            return space;\r\n        }\r\n    }\r\n    parseParenthesisToken(token) {\r\n        const content = this.content(token);\r\n        if (token[TOKEN.TYPE] === tokens.space) {\r\n            return this.requiredSpace(content);\r\n        }\r\n        else {\r\n            return content;\r\n        }\r\n    }\r\n    newNode(node, namespace) {\r\n        if (namespace) {\r\n            if (/^ +$/.test(namespace)) {\r\n                if (!this.options.lossy) {\r\n                    this.spaces = (this.spaces || '') + namespace;\r\n                }\r\n                namespace = true;\r\n            }\r\n            node.namespace = namespace;\r\n            unescapeProp(node, \"namespace\");\r\n        }\r\n        if (this.spaces) {\r\n            node.spaces.before = this.spaces;\r\n            this.spaces = '';\r\n        }\r\n        return this.current.append(node);\r\n    }\r\n    content(token = this.currToken) {\r\n        return this.css.slice(token[TOKEN.START_POS], token[TOKEN.END_POS]);\r\n    }\r\n    get currToken() {\r\n        return this.tokens[this.position];\r\n    }\r\n    get nextToken() {\r\n        return this.tokens[this.position + 1];\r\n    }\r\n    get prevToken() {\r\n        return this.tokens[this.position - 1];\r\n    }\r\n    /**\r\n     * returns the index of the next non-whitespace, non-comment token.\r\n     * returns -1 if no meaningful token is found.\r\n     */\r\n    locateNextMeaningfulToken(startPosition = this.position + 1) {\r\n        let searchPosition = startPosition;\r\n        while (searchPosition < this.tokens.length) {\r\n            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][TOKEN.TYPE]]) {\r\n                searchPosition++;\r\n                continue;\r\n            }\r\n            else {\r\n                return searchPosition;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n", "import Parser from './parser';\r\nexport default class Processor {\r\n    constructor(func, options) {\r\n        this.func = func || function noop() { };\r\n        this.funcRes = null;\r\n        this.options = options;\r\n    }\r\n    _shouldUpdateSelector(rule, options = {}) {\r\n        let merged = Object.assign({}, this.options, options);\r\n        if (merged.updateSelector === false) {\r\n            return false;\r\n        }\r\n        else {\r\n            return typeof rule !== \"string\";\r\n        }\r\n    }\r\n    _isLossy(options = {}) {\r\n        let merged = Object.assign({}, this.options, options);\r\n        if (merged.lossless === false) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    _root(rule, options = {}) {\r\n        let parser = new Parser(rule, this._parseOptions(options));\r\n        return parser.root;\r\n    }\r\n    _parseOptions(options) {\r\n        return {\r\n            lossy: this._isLossy(options),\r\n        };\r\n    }\r\n    _run(rule, options = {}) {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                let root = this._root(rule, options);\r\n                Promise.resolve(this.func(root)).then(transform => {\r\n                    let string = undefined;\r\n                    if (this._shouldUpdateSelector(rule, options)) {\r\n                        string = root.toString();\r\n                        rule.selector = string;\r\n                    }\r\n                    return { transform, root, string };\r\n                }).then(resolve, reject);\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    _runSync(rule, options = {}) {\r\n        let root = this._root(rule, options);\r\n        let transform = this.func(root);\r\n        if (transform && typeof transform.then === \"function\") {\r\n            throw new Error(\"Selector processor returned a promise to a synchronous call.\");\r\n        }\r\n        let string = undefined;\r\n        if (options.updateSelector && typeof rule !== \"string\") {\r\n            string = root.toString();\r\n            rule.selector = string;\r\n        }\r\n        return { transform, root, string };\r\n    }\r\n    /**\r\n     * Process rule into a selector AST.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {Promise<parser.Root>} The AST of the selector after processing it.\r\n     */\r\n    ast(rule, options) {\r\n        return this._run(rule, options).then(result => result.root);\r\n    }\r\n    /**\r\n     * Process rule into a selector AST synchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {parser.Root} The AST of the selector after processing it.\r\n     */\r\n    astSync(rule, options) {\r\n        return this._runSync(rule, options).root;\r\n    }\r\n    /**\r\n     * Process a selector into a transformed value asynchronously\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {Promise<any>} The value returned by the processor.\r\n     */\r\n    transform(rule, options) {\r\n        return this._run(rule, options).then(result => result.transform);\r\n    }\r\n    /**\r\n     * Process a selector into a transformed value synchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {any} The value returned by the processor.\r\n     */\r\n    transformSync(rule, options) {\r\n        return this._runSync(rule, options).transform;\r\n    }\r\n    /**\r\n     * Process a selector into a new selector string asynchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {string} the selector after processing.\r\n     */\r\n    process(rule, options) {\r\n        return this._run(rule, options)\r\n            .then((result) => result.string || result.root.toString());\r\n    }\r\n    /**\r\n     * Process a selector into a new selector string synchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {string} the selector after processing.\r\n     */\r\n    processSync(rule, options) {\r\n        let result = this._runSync(rule, options);\r\n        return result.string || result.root.toString();\r\n    }\r\n}\r\n", "export * from \"./types\";\r\nexport * from \"./constructors\";\r\nexport * from \"./guards\";\r\n", "import Attribute from './attribute';\r\nimport ClassName from './className';\r\nimport Combinator from './combinator';\r\nimport Comment from './comment';\r\nimport Id from './id';\r\nimport Nesting from './nesting';\r\nimport Pseudo from './pseudo';\r\nimport Root from './root';\r\nimport Selector from './selector';\r\nimport Str from './string';\r\nimport Tag from './tag';\r\nimport Universal from './universal';\r\nexport const attribute = opts => new Attribute(opts);\r\nexport const className = opts => new ClassName(opts);\r\nexport const combinator = opts => new Combinator(opts);\r\nexport const comment = opts => new Comment(opts);\r\nexport const id = opts => new Id(opts);\r\nexport const nesting = opts => new Nesting(opts);\r\nexport const pseudo = opts => new Pseudo(opts);\r\nexport const root = opts => new Root(opts);\r\nexport const selector = opts => new Selector(opts);\r\nexport const string = opts => new Str(opts);\r\nexport const tag = opts => new Tag(opts);\r\nexport const universal = opts => new Universal(opts);\r\n", "import { ATTRIBUTE, CLASS, COMBINATOR, COMMENT, ID, NESTING, PSEUDO, ROOT, SELECTOR, STRING, TAG, UNIVERSAL, } from \"./types\";\r\nconst IS_TYPE = {\r\n    [ATTRIBUTE]: true,\r\n    [CLASS]: true,\r\n    [COMBINATOR]: true,\r\n    [COMMENT]: true,\r\n    [ID]: true,\r\n    [NESTING]: true,\r\n    [PSEUDO]: true,\r\n    [ROOT]: true,\r\n    [SELECTOR]: true,\r\n    [STRING]: true,\r\n    [TAG]: true,\r\n    [UNIVERSAL]: true,\r\n};\r\nexport function isNode(node) {\r\n    return (typeof node === \"object\" && IS_TYPE[node.type]);\r\n}\r\nfunction isNodeType(type, node) {\r\n    return isNode(node) && node.type === type;\r\n}\r\nexport const isAttribute = isNodeType.bind(null, ATTRIBUTE);\r\nexport const isClassName = isNodeType.bind(null, CLASS);\r\nexport const isCombinator = isNodeType.bind(null, COMBINATOR);\r\nexport const isComment = isNodeType.bind(null, COMMENT);\r\nexport const isIdentifier = isNodeType.bind(null, ID);\r\nexport const isNesting = isNodeType.bind(null, NESTING);\r\nexport const isPseudo = isNodeType.bind(null, PSEUDO);\r\nexport const isRoot = isNodeType.bind(null, ROOT);\r\nexport const isSelector = isNodeType.bind(null, SELECTOR);\r\nexport const isString = isNodeType.bind(null, STRING);\r\nexport const isTag = isNodeType.bind(null, TAG);\r\nexport const isUniversal = isNodeType.bind(null, UNIVERSAL);\r\nexport function isPseudoElement(node) {\r\n    return isPseudo(node)\r\n        && node.value\r\n        && (node.value.startsWith(\"::\")\r\n            || node.value.toLowerCase() === \":before\"\r\n            || node.value.toLowerCase() === \":after\"\r\n            || node.value.toLowerCase() === \":first-letter\"\r\n            || node.value.toLowerCase() === \":first-line\");\r\n}\r\nexport function isPseudoClass(node) {\r\n    return isPseudo(node) && !isPseudoElement(node);\r\n}\r\nexport function isContainer(node) {\r\n    return !!(isNode(node) && node.walk);\r\n}\r\nexport function isNamespace(node) {\r\n    return isAttribute(node) || isTag(node);\r\n}\r\n", "import Processor from './processor';\r\nimport * as selectors from './selectors';\r\nconst parser = processor => new Processor(processor);\r\nObject.assign(parser, selectors);\r\nexport default parser;\r\n"],
  "mappings": "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",
  "names": ["str", "hex", "selector", "id", "str", "selector", "string", "isIdentifier", "ID", "String", "selector", "selector", "unescaped", "space", "String", "word", "ID", "parser", "root", "string", "combinator", "comment", "combinator", "comment", "ID", "String"]
}
