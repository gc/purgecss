{
  "version": 3,
  "sources": ["../../src/postcss-selector-parser/util/unesc.js", "../../src/postcss-selector-parser/util/getProp.js", "../../src/postcss-selector-parser/util/ensureObject.js", "../../src/postcss-selector-parser/util/stripComments.js", "../../src/postcss-selector-parser/util/index.js", "../../src/postcss-selector-parser/selectors/node.js", "../../src/postcss-selector-parser/selectors/types.js", "../../src/postcss-selector-parser/selectors/container.js", "../../src/postcss-selector-parser/selectors/root.js", "../../src/postcss-selector-parser/selectors/selector.js", "../../src/cssesc/index.js", "../../src/postcss-selector-parser/selectors/className.js", "../../src/postcss-selector-parser/selectors/comment.js", "../../src/postcss-selector-parser/selectors/id.js", "../../src/postcss-selector-parser/selectors/namespace.js", "../../src/postcss-selector-parser/selectors/tag.js", "../../src/postcss-selector-parser/selectors/string.js", "../../src/postcss-selector-parser/selectors/pseudo.js", "../../src/postcss-selector-parser/selectors/attribute.js", "../../src/postcss-selector-parser/selectors/universal.js", "../../src/postcss-selector-parser/selectors/combinator.js", "../../src/postcss-selector-parser/selectors/nesting.js", "../../src/postcss-selector-parser/sortAscending.js", "../../src/postcss-selector-parser/tokenTypes.js", "../../src/postcss-selector-parser/tokenize.js", "../../src/postcss-selector-parser/parser.js", "../../src/postcss-selector-parser/processor.js", "../../src/postcss-selector-parser/selectors/constructors.js", "../../src/postcss-selector-parser/selectors/guards.js", "../../src/postcss-selector-parser/selectors/index.js", "../../src/postcss-selector-parser/index.js", "../../src/postcss-discard-comments/index.js"],
  "sourcesContent": ["// Many thanks for this post which made this migration much easier.\n// https://mathiasbynens.be/notes/css-escapes\n\n/**\n * \n * @param {string} str \n * @returns {[string, number]|undefined}\n */\nfunction gobbleHex (str) {\n    const lower = str.toLowerCase();\n    let hex = '';\n    let spaceTerminated = false;\n    for (let i = 0; i < 6 && lower[i] !== undefined; i++) {\n        const code =  lower.charCodeAt(i);\n        // check to see if we are dealing with a valid hex char [a-f|0-9]\n        const valid = (code >= 97 && code <= 102) || (code >= 48 && code <= 57);\n        // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\n        spaceTerminated = code === 32;\n        if (!valid) {\n            break;\n        }\n        hex += lower[i];\n    }\n\n    if (hex.length === 0) {\n        return undefined;\n    }\n    const codePoint = parseInt(hex, 16);\n\n    const isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;\n    // Add special case for\n    // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\n    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\n    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\n        return ['\\uFFFD', hex.length + (spaceTerminated ? 1 : 0)];\n    }\n\n    return [\n        String.fromCodePoint(codePoint),\n        hex.length + (spaceTerminated ? 1 : 0),\n    ];\n}\n\nconst CONTAINS_ESCAPE = /\\\\/;\n\nexport default function unesc (str) {\n    let needToProcess = CONTAINS_ESCAPE.test(str);\n    if (!needToProcess) {\n        return str;\n    }\n    let ret = \"\";\n\n    for (let i = 0; i < str.length; i++) {\n        if ((str[i] === \"\\\\\")) {\n            const gobbled = gobbleHex(str.slice(i + 1, i + 7));\n            if (gobbled !== undefined) {\n                ret += gobbled[0];\n                i += gobbled[1];\n                continue;\n            }\n\n            // Retain a pair of \\\\ if double escaped `\\\\\\\\`\n            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\n            if (str[i + 1] === \"\\\\\") {\n                ret += \"\\\\\";\n                i++;\n                continue;\n            }\n\n            // if \\\\ is at the end of the string retain it\n            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\n            if (str.length === i + 1) {\n                ret += str[i];\n            }\n            continue;\n        }\n      \n        ret += str[i];\n    }\n\n    return ret;\n}\n", "export default function getProp (obj, ...props) {\n    while (props.length > 0) {\n        const prop = props.shift();\n\n        if (!obj[prop]) {\n            return undefined;\n        }\n\n        obj = obj[prop];\n    }\n\n    return obj;\n}\n", "export default function ensureObject (obj, ...props) {\n    while (props.length > 0) {\n        const prop = props.shift();\n\n        if (!obj[prop]) {\n            obj[prop] = {};\n        }\n\n        obj = obj[prop];\n    }\n}\n", "export default function stripComments (str) {\n    let s = \"\";\n    let commentStart = str.indexOf(\"/*\");\n    let lastEnd = 0;\n    while (commentStart >= 0) {\n        s = s + str.slice(lastEnd, commentStart);\n        let commentEnd = str.indexOf(\"*/\", commentStart + 2);\n        if (commentEnd < 0) {\n            return s;\n        }\n        lastEnd = commentEnd + 2;\n        commentStart = str.indexOf(\"/*\", lastEnd);\n    }\n    s = s + str.slice(lastEnd);\n    return s;\n}\n", "export {default as unesc} from './unesc';\nexport {default as getProp} from './getProp';\nexport {default as ensureObject} from './ensureObject';\nexport {default as stripComments} from './stripComments';\n", "import {ensureObject} from \"../util\";\n\nlet cloneNode = function (obj, parent) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    let cloned = new obj.constructor();\n\n    for ( let i in obj ) {\n        if ( !obj.hasOwnProperty(i) ) {\n            continue;\n        }\n        let value = obj[i];\n        let type  = typeof value;\n\n        if ( i === 'parent' && type === 'object' ) {\n            if (parent) {\n                cloned[i] = parent;\n            }\n        } else if ( value instanceof Array ) {\n            cloned[i] = value.map( j => cloneNode(j, cloned) );\n        } else {\n            cloned[i] = cloneNode(value, cloned);\n        }\n    }\n\n    return cloned;\n};\n\nexport default class Node {\n    constructor (opts = {}) {\n        Object.assign(this, opts);\n        this.spaces = this.spaces || {};\n        this.spaces.before = this.spaces.before || '';\n        this.spaces.after = this.spaces.after || '';\n    }\n\n    remove () {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n\n    replaceWith () {\n        if (this.parent) {\n            for (let index in arguments) {\n                this.parent.insertBefore(this, arguments[index]);\n            }\n            this.remove();\n        }\n        return this;\n    }\n\n    next () {\n        return this.parent.at(this.parent.index(this) + 1);\n    }\n\n    prev () {\n        return this.parent.at(this.parent.index(this) - 1);\n    }\n\n    clone (overrides = {}) {\n        let cloned = cloneNode(this);\n        for (let name in overrides) {\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows non standard syntax to be appended to an existing property\n     * by specifying the escaped value. By specifying the escaped value,\n     * illegal characters are allowed to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped optional. the escaped value of the property.\n     */\n    appendToPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        let originalValue = this[name];\n        let originalEscaped = this.raws[name];\n        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (originalEscaped || valueEscaped !== value) {\n            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\n        } else {\n            delete this.raws[name]; // delete any escaped value that was created by the setter.\n        }\n    }\n\n    /**\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\n     * This allows the escaped value to be specified directly, allowing illegal\n     * characters to be directly inserted into css output.\n     * @param {string} name the property to set\n     * @param {any} value the unescaped value of the property\n     * @param {string} valueEscaped the escaped value of the property.\n     */\n    setPropertyAndEscape (name, value, valueEscaped) {\n        if (!this.raws) {\n            this.raws = {};\n        }\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        this.raws[name] = valueEscaped;\n    }\n\n    /**\n     * When you want a value to passed through to CSS directly. This method\n     * deletes the corresponding raw value causing the stringifier to fallback\n     * to the unescaped value.\n     * @param {string} name the property to set.\n     * @param {any} value The value that is both escaped and unescaped.\n     */\n    setPropertyWithoutEscape (name, value) {\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n        if (this.raws) {\n            delete this.raws[name];\n        }\n    }\n\n    /**\n     *\n     * @param {number} line The number (starting with 1)\n     * @param {number} column The column number (starting with 1)\n     */\n    isAtPosition (line, column) {\n        if (this.source && this.source.start && this.source.end) {\n            if (this.source.start.line > line) {\n                return false;\n            }\n            if (this.source.end.line < line) {\n                return false;\n            }\n            if (this.source.start.line === line && this.source.start.column > column) {\n                return false;\n            }\n            if (this.source.end.line === line && this.source.end.column < column) {\n                return false;\n            }\n            return true;\n        }\n        return undefined;\n    }\n\n    stringifyProperty (name) {\n        return (this.raws && this.raws[name]) || this[name];\n    }\n\n    get rawSpaceBefore () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces && this.spaces.before;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceBefore (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.before = raw;\n    }\n\n    get rawSpaceAfter () {\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\n        if (rawSpace === undefined) {\n            rawSpace = this.spaces.after;\n        }\n        return rawSpace || \"\";\n    }\n\n    set rawSpaceAfter (raw) {\n        ensureObject(this, \"raws\", \"spaces\");\n        this.raws.spaces.after = raw;\n    }\n\n    valueToString () {\n        return String(this.stringifyProperty(\"value\"));\n    }\n\n    toString () {\n        return [\n            this.rawSpaceBefore,\n            this.valueToString(),\n            this.rawSpaceAfter,\n        ].join('');\n    }\n}\n", "export const TAG = 'tag';\nexport const STRING = 'string';\nexport const SELECTOR = 'selector';\nexport const ROOT = 'root';\nexport const PSEUDO = 'pseudo';\nexport const NESTING = 'nesting';\nexport const ID = 'id';\nexport const COMMENT = 'comment';\nexport const COMBINATOR = 'combinator';\nexport const CLASS = 'class';\nexport const ATTRIBUTE = 'attribute';\nexport const UNIVERSAL = 'universal';\n", "import Node from './node';\nimport * as types from './types';\n\nexport default class Container extends Node {\n    constructor (opts) {\n        super(opts);\n        if (!this.nodes) {\n            this.nodes = [];\n        }\n    }\n\n    append (selector) {\n        selector.parent = this;\n        this.nodes.push(selector);\n        return this;\n    }\n\n    prepend (selector) {\n        selector.parent = this;\n        this.nodes.unshift(selector);\n        for ( let id in this.indexes ) {\n            this.indexes[id]++;\n        }\n        return this;\n    }\n\n    at (index) {\n        return this.nodes[index];\n    }\n\n    index (child) {\n        if (typeof child === 'number') {\n            return child;\n        }\n        return this.nodes.indexOf(child);\n    }\n\n    get first () {\n        return this.at(0);\n    }\n\n    get last () {\n        return this.at(this.length - 1);\n    }\n\n    get length () {\n        return this.nodes.length;\n    }\n\n    removeChild (child) {\n        child = this.index(child);\n        this.at(child).parent = undefined;\n        this.nodes.splice(child, 1);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= child ) {\n                this.indexes[id] = index - 1;\n            }\n        }\n\n        return this;\n    }\n\n    removeAll () {\n        for (let node of this.nodes) {\n            node.parent = undefined;\n        }\n        this.nodes = [];\n        return this;\n    }\n\n    empty () {\n        return this.removeAll();\n    }\n\n    insertAfter (oldNode, newNode) {\n        newNode.parent = this;\n        let oldIndex = this.index(oldNode);\n        this.nodes.splice(oldIndex + 1, 0, newNode);\n\n        newNode.parent = this;\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( oldIndex < index ) {\n                this.indexes[id] = index + 1;\n            }\n        }\n\n        return this;\n    }\n\n    insertBefore (oldNode, newNode) {\n        newNode.parent = this;\n        let oldIndex = this.index(oldNode);\n        this.nodes.splice(oldIndex, 0, newNode);\n\n        newNode.parent = this;\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= oldIndex ) {\n                this.indexes[id] = index + 1;\n            }\n        }\n\n        return this;\n    }\n\n    _findChildAtPosition (line, col) {\n        let found = undefined;\n        this.each(node => {\n            if (node.atPosition) {\n                let foundChild = node.atPosition(line, col);\n                if (foundChild) {\n                    found = foundChild;\n                    return false;\n                }\n            } else if (node.isAtPosition(line, col)) {\n                found = node;\n                return false;\n            }\n        });\n        return found;\n    }\n\n    /**\n     * Return the most specific node at the line and column number given.\n     * The source location is based on the original parsed location, locations aren't\n     * updated as selector nodes are mutated.\n     * \n     * Note that this location is relative to the location of the first character\n     * of the selector, and not the location of the selector in the overall document\n     * when used in conjunction with postcss.\n     *\n     * If not found, returns undefined.\n     * @param {number} line The line number of the node to find. (1-based index)\n     * @param {number} col  The column number of the node to find. (1-based index)\n     */\n    atPosition (line, col) {\n        if (this.isAtPosition(line, col)) {\n            return this._findChildAtPosition(line, col) || this;\n        } else {\n            return undefined;\n        }\n    }\n\n    _inferEndPosition () {\n        if (this.last && this.last.source && this.last.source.end) {\n            this.source = this.source || {};\n            this.source.end = this.source.end || {};\n            Object.assign(this.source.end, this.last.source.end);\n        }\n    }\n\n    each (callback) {\n        if (!this.lastEach) {\n            this.lastEach = 0;\n        }\n        if (!this.indexes) {\n            this.indexes = {};\n        }\n\n        this.lastEach ++;\n        let id = this.lastEach;\n        this.indexes[id] = 0;\n\n        if (!this.length) {\n            return undefined;\n        }\n\n        let index, result;\n        while (this.indexes[id] < this.length) {\n            index = this.indexes[id];\n            result = callback(this.at(index), index);\n            if (result === false) {\n                break;\n            }\n\n            this.indexes[id] += 1;\n        }\n\n        delete this.indexes[id];\n\n        if (result === false) {\n            return false;\n        }\n    }\n\n    walk (callback) {\n        return this.each((node, i) => {\n            let result = callback(node, i);\n\n            if (result !== false && node.length) {\n                result = node.walk(callback);\n            }\n\n            if (result === false) {\n                return false;\n            }\n        });\n    }\n\n    walkAttributes (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.ATTRIBUTE) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkClasses (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.CLASS) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkCombinators (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.COMBINATOR) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkComments (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.COMMENT) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkIds (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.ID) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkNesting (callback) {\n        return this.walk(selector => {\n            if (selector.type === types.NESTING) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkPseudos (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.PSEUDO) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkTags (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.TAG) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    walkUniversals (callback) {\n        return this.walk((selector) => {\n            if (selector.type === types.UNIVERSAL) {\n                return callback.call(this, selector);\n            }\n        });\n    }\n\n    split (callback) {\n        let current = [];\n        return this.reduce((memo, node, index) => {\n            let split = callback.call(this, node);\n            current.push(node);\n            if (split) {\n                memo.push(current);\n                current = [];\n            } else if (index === this.length - 1) {\n                memo.push(current);\n            }\n            return memo;\n        }, []);\n    }\n\n    map (callback) {\n        return this.nodes.map(callback);\n    }\n\n    reduce (callback, memo) {\n        return this.nodes.reduce(callback, memo);\n    }\n\n    every (callback) {\n        return this.nodes.every(callback);\n    }\n\n    some (callback) {\n        return this.nodes.some(callback);\n    }\n\n    filter (callback) {\n        return this.nodes.filter(callback);\n    }\n\n    sort (callback) {\n        return this.nodes.sort(callback);\n    }\n\n    toString () {\n        return this.map(String).join('');\n    }\n}\n", "import Container from './container';\nimport {ROOT} from './types';\n\nexport default class Root extends Container {\n    constructor (opts) {\n        super(opts);\n        this.type = ROOT;\n    }\n\n    toString () {\n        let str = this.reduce((memo, selector) => {\n            memo.push(String(selector));\n            return memo;\n        }, []).join(',');\n        return this.trailingComma ? str + ',' : str;\n    }\n\n    error (message, options) {\n        if (this._error) {\n            return this._error(message, options);\n        } else {\n            return new Error(message);\n        }\n    }\n\n    set errorGenerator (handler) {\n        this._error = handler;\n    }\n}\n", "import Container from './container';\nimport {SELECTOR} from './types';\n\nexport default class Selector extends Container {\n    constructor (opts) {\n        super(opts);\n        this.type = SELECTOR;\n    }\n}\n", "\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst merge = (options, defaults) => {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tconst result = {};\n\tfor (const key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { \u2026 }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key)\n\t\t\t? options[key]\n\t\t\t: defaults[key];\n\t}\n\treturn result;\n};\n\nconst regexAnySingleEscape = /<%= anySingleEscape %>/;\nconst regexSingleEscape = /<%= singleEscapes %>/;\nconst regexAlwaysEscape = /['\"\\\\]/;\nconst regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n/*@__NO_SIDE_EFFECTS__*/\nconst cssesc = (string, options) => {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ? '\"' : '\\'';\n\tconst isIdentifier = options.isIdentifier;\n\n\tconst firstChar = string.charAt(0);\n\tlet output = '';\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst character = string.charAt(counter++);\n\t\tlet codePoint = character.charCodeAt();\n\t\tlet value;\n\t\t// If it\u2019s not a printable ASCII character\u2026\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It\u2019s a high surrogate, and there is a next character.\n\t\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It\u2019s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (\n\t\t\t\tcharacter == '\\\\' ||\n\t\t\t\t(\n\t\t\t\t\t!isIdentifier &&\n\t\t\t\t\t(\n\t\t\t\t\t\t(character == '\"' && quote == character) ||\n\t\t\t\t\t\t(character == '\\'' && quote == character)\n\t\t\t\t\t)\n\t\t\t\t) ||\n\t\t\t\t(isIdentifier && regexSingleEscape.test(character))\n\t\t\t) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they\u2019re redundant. Note that this is only possible if the escape\n\t// sequence isn\u2019t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, ($0, $1, $2) => {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It\u2019s not safe to remove the space, so don\u2019t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\nexport default cssesc;", "import cssesc from \"../../cssesc\";\nimport { ensureObject } from '../util';\nimport Node from './node';\nimport { CLASS } from './types';\n\nexport default class ClassName extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = CLASS;\n        this._constructed = true;\n    }\n\n    set value (v) {\n        if (this._constructed) {\n            const escaped = cssesc(v, {isIdentifier: true});\n            if (escaped !== v) {\n                ensureObject(this, \"raws\");\n                this.raws.value = escaped;\n            } else if (this.raws) {\n                delete this.raws.value;\n            }\n        }\n        this._value = v;\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    valueToString () {\n        return '.' + super.valueToString();\n    }\n}\n", "import Node from './node';\nimport {COMMENT} from './types';\n\nexport default class Comment extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = COMMENT;\n    }\n}\n", "import Node from './node';\nimport {ID as IDType} from './types';\n\nexport default class ID extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = IDType;\n    }\n\n    valueToString () {\n        return '#' + super.valueToString();\n    }\n}\n", "import cssesc from \"../../cssesc\";\nimport { ensureObject } from '../util';\nimport Node from './node';\n\nexport default class Namespace extends Node {\n    get namespace () {\n        return this._namespace;\n    }\n    set namespace (namespace) {\n        if (namespace === true || namespace === \"*\" || namespace === \"&\") {\n            this._namespace = namespace;\n            if (this.raws) {\n                delete this.raws.namespace;\n            }\n            return;\n        }\n\n        const escaped = cssesc(namespace, {isIdentifier: true});\n        this._namespace = namespace;\n        if (escaped !== namespace) {\n            ensureObject(this, \"raws\");\n            this.raws.namespace = escaped;\n        } else if (this.raws) {\n            delete this.raws.namespace;\n        }\n    }\n    get ns () {\n        return this._namespace;\n    }\n    set ns (namespace) {\n        this.namespace = namespace;\n    }\n\n    get namespaceString () {\n        if (this.namespace) {\n            const ns = this.stringifyProperty(\"namespace\");\n            if (ns === true) {\n                return '';\n            } else {\n                return ns;\n            }\n        } else {\n            return '';\n        }\n    }\n\n    qualifiedName (value) {\n        if (this.namespace) {\n            return `${this.namespaceString}|${value}`;\n        } else {\n            return value;\n        }\n    }\n\n    valueToString () {\n        return this.qualifiedName(super.valueToString());\n    }\n};\n", "import Namespace from './namespace';\nimport {TAG} from './types';\n\nexport default class Tag extends Namespace {\n    constructor (opts) {\n        super(opts);\n        this.type = TAG;\n    }\n}\n", "import Node from './node';\nimport {STRING} from './types';\n\nexport default class String extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = STRING;\n    }\n}\n", "import Container from './container';\nimport {PSEUDO} from './types';\n\nexport default class Pseudo extends Container {\n    constructor (opts) {\n        super(opts);\n        this.type = PSEUDO;\n    }\n\n    toString () {\n        let params = this.length ? '(' + this.map(String).join(',') + ')' : '';\n        return [\n            this.rawSpaceBefore,\n            this.stringifyProperty(\"value\"),\n            params,\n            this.rawSpaceAfter,\n        ].join('');\n    }\n}\n", "import cssesc from \"../../cssesc\";\nimport unesc from \"../util/unesc\";\nimport Namespace from './namespace';\nimport { ATTRIBUTE } from './types';\n\nconst WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\n\nexport function unescapeValue (value) {\n    let deprecatedUsage = false;\n    let quoteMark = null;\n    let unescaped = value;\n    const m = unescaped.match(WRAPPED_IN_QUOTES);\n    if (m) {\n        quoteMark = m[1];\n        unescaped = m[2];\n    }\n    unescaped = unesc(unescaped);\n    if (unescaped !== value) {\n        deprecatedUsage = true;\n    }\n    return {\n        deprecatedUsage,\n        unescaped,\n        quoteMark,\n    };\n}\n\nfunction handleDeprecatedContructorOpts (opts) {\n    if (opts.quoteMark !== undefined) {\n        return opts;\n    }\n    if (opts.value === undefined) {\n        return opts;\n    }\n    warnOfDeprecatedConstructor();\n    const {quoteMark, unescaped} = unescapeValue(opts.value);\n    if (!opts.raws) {\n        opts.raws = {};\n    }\n    if (opts.raws.value === undefined) {\n        opts.raws.value = opts.value;\n    }\n    opts.value = unescaped;\n    opts.quoteMark = quoteMark;\n    return opts;\n}\n\nexport default class Attribute extends Namespace {\n    static NO_QUOTE = null;\n    static SINGLE_QUOTE = \"'\";\n    static DOUBLE_QUOTE = '\"';\n    constructor (opts = {}) {\n        super(handleDeprecatedContructorOpts(opts));\n        this.type = ATTRIBUTE;\n        this.raws = this.raws || {};\n        this._constructed = true;\n    }\n\n    /**\n     * Returns the Attribute's value quoted such that it would be legal to use\n     * in the value of a css file. The original value's quotation setting\n     * used for stringification is left unchanged. See `setValue(value, options)`\n     * if you want to control the quote settings of a new value for the attribute.\n     *\n     * You can also change the quotation used for the current value by setting quoteMark.\n     *\n     * Options:\n     *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n     *     option is not set, the original value for quoteMark will be used. If\n     *     indeterminate, a double quote is used. The legal values are:\n     *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n     *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n     *     over the quoteMark option value.\n     *   * smart {boolean} - if true, will select a quote mark based on the value\n     *     and the other options specified here. See the `smartQuoteMark()`\n     *     method.\n     **/\n    getQuotedValue (options = {}) {\n        const quoteMark = this._determineQuoteMark(options);\n        const cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n        const escaped = cssesc(this._value, cssescopts);\n        return escaped;\n    }\n\n    _determineQuoteMark (options) {\n        return (options.smart) ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n    }\n\n    /**\n     * Set the unescaped value with the specified quotation options. The value\n     * provided must not include any wrapping quote marks -- those quotes will\n     * be interpreted as part of the value and escaped accordingly.\n     */\n    setValue (value, options = {}) {\n        this._value = value;\n        this._quoteMark = this._determineQuoteMark(options);\n        this._syncRawValue();\n    }\n\n    /**\n     * Intelligently select a quoteMark value based on the value's contents. If\n     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n     * mark will be picked that minimizes the number of escapes.\n     *\n     * If there's no clear winner, the quote mark from these options is used,\n     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n     * true). If the quoteMark is unspecified, a double quote is used.\n     *\n     * @param options This takes the quoteMark and preferCurrentQuoteMark options\n     * from the quoteValue method.\n     */\n    smartQuoteMark (options) {\n        const v = this.value;\n        const numSingleQuotes = v.replace(/[^']/g, '').length;\n        const numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n        if (numSingleQuotes + numDoubleQuotes === 0) {\n            const escaped = cssesc(v, {isIdentifier: true});\n            if (escaped === v) {\n                return Attribute.NO_QUOTE;\n            } else {\n                const pref = this.preferredQuoteMark(options);\n                if (pref === Attribute.NO_QUOTE) {\n                    // pick a quote mark that isn't none and see if it's smaller\n                    const quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n                    const opts = CSSESC_QUOTE_OPTIONS[quote];\n                    const quoteValue = cssesc(v, opts);\n                    if (quoteValue.length < escaped.length) {\n                        return quote;\n                    }\n                }\n                return pref;\n            }\n        } else if (numDoubleQuotes === numSingleQuotes) {\n            return this.preferredQuoteMark(options);\n        } else if ( numDoubleQuotes < numSingleQuotes) {\n            return Attribute.DOUBLE_QUOTE;\n        } else {\n            return Attribute.SINGLE_QUOTE;\n        }\n    }\n\n    /**\n     * Selects the preferred quote mark based on the options and the current quote mark value.\n     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n     * instead.\n     */\n    preferredQuoteMark (options) {\n        let quoteMark = (options.preferCurrentQuoteMark) ? this.quoteMark : options.quoteMark;\n\n        if (quoteMark === undefined) {\n            quoteMark = (options.preferCurrentQuoteMark) ? options.quoteMark : this.quoteMark;\n        }\n\n        if (quoteMark === undefined) {\n            quoteMark = Attribute.DOUBLE_QUOTE;\n        }\n\n        return quoteMark;\n    }\n\n    get quoted () {\n        const qm = this.quoteMark;\n        return qm === \"'\" || qm === '\"';\n    }\n\n    set quoted (value) {\n        warnOfDeprecatedQuotedAssignment();\n    }\n\n    /**\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n     * returns `null` if the value is not quoted.\n     * returns `undefined` if the quotation state is unknown (this can happen when\n     * the attribute is constructed without specifying a quote mark.)\n     */\n    get quoteMark () {\n        return this._quoteMark;\n    }\n\n    /**\n     * Set the quote mark to be used by this attribute's value.\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n     * value is updated accordingly.\n     *\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n     */\n    set quoteMark (quoteMark) {\n        if (!this._constructed) {\n            this._quoteMark = quoteMark;\n            return;\n        }\n        if (this._quoteMark !== quoteMark) {\n            this._quoteMark = quoteMark;\n            this._syncRawValue();\n        }\n    }\n\n    _syncRawValue () {\n        const rawValue = cssesc(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n        if (rawValue === this._value) {\n            if (this.raws) {\n                delete this.raws.value;\n            }\n        } else {\n            this.raws.value = rawValue;\n        }\n    }\n\n    get qualifiedAttribute () {\n        return this.qualifiedName(this.raws.attribute || this.attribute);\n    }\n\n    get insensitiveFlag () {\n        return this.insensitive ? 'i' : '';\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    get insensitive () {\n        return this._insensitive;\n    }\n\n    /**\n     * Set the case insensitive flag.\n     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`\n     * of the attribute is updated accordingly.\n     *\n     * @param {true | false} insensitive true if the attribute should match case-insensitively.\n     */\n    set insensitive (insensitive) {\n        if (!insensitive) {\n            this._insensitive = false;\n\n            // \"i\" and \"I\" can be used in \"this.raws.insensitiveFlag\" to store the original notation.\n            // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.\n            if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {\n                this.raws.insensitiveFlag = undefined;\n            }\n        }\n\n        this._insensitive = insensitive;\n    }\n\n    /**\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n     * is unescaped during parsing and any quote marks are removed.\n     *\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n     * a deprecation warning is raised when the new value contains any characters that would\n     * require escaping (including if it contains wrapped quotes).\n     *\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n     * how the new value is quoted.\n     */\n    set value (v) {\n        if (this._constructed) {\n            const {\n                deprecatedUsage,\n                unescaped,\n                quoteMark,\n            } = unescapeValue(v);\n            if (deprecatedUsage) {\n                warnOfDeprecatedValueAssignment();\n            }\n            if (unescaped === this._value && quoteMark === this._quoteMark) {\n                return;\n            }\n            this._value = unescaped;\n            this._quoteMark = quoteMark;\n            this._syncRawValue();\n        } else {\n            this._value = v;\n        }\n    }\n\n    get attribute () {\n        return this._attribute;\n    }\n\n    set attribute (name) {\n        this._handleEscapes(\"attribute\", name);\n        this._attribute = name;\n    }\n\n    _handleEscapes (prop, value) {\n        if (this._constructed) {\n            const escaped = cssesc(value, {isIdentifier: true});\n            if (escaped !== value) {\n                this.raws[prop] = escaped;\n            } else {\n                delete this.raws[prop];\n            }\n        }\n    }\n\n    _spacesFor (name) {\n        const attrSpaces = {before: '', after: ''};\n        const spaces = this.spaces[name] || {};\n        const rawSpaces = (this.raws.spaces && this.raws.spaces[name]) || {};\n        return Object.assign(attrSpaces, spaces, rawSpaces);\n    }\n\n    _stringFor (name, spaceName = name, concat = defaultAttrConcat) {\n        const attrSpaces = this._spacesFor(spaceName);\n        return concat(this.stringifyProperty(name), attrSpaces);\n    }\n\n    /**\n     * returns the offset of the attribute part specified relative to the\n     * start of the node of the output string.\n     *\n     * * \"ns\" - alias for \"namespace\"\n     * * \"namespace\" - the namespace if it exists.\n     * * \"attribute\" - the attribute name\n     * * \"attributeNS\" - the start of the attribute or its namespace\n     * * \"operator\" - the match operator of the attribute\n     * * \"value\" - The value (string or identifier)\n     * * \"insensitive\" - the case insensitivity flag;\n     * @param part One of the possible values inside an attribute.\n     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n     */\n    offsetOf (name) {\n        let count = 1;\n        const attributeSpaces = this._spacesFor(\"attribute\");\n        count += attributeSpaces.before.length;\n        if (name === \"namespace\" || name === \"ns\") {\n            return (this.namespace) ? count : -1;\n        }\n        if (name === \"attributeNS\") {\n            return count;\n        }\n\n        count += this.namespaceString.length;\n        if (this.namespace) {\n            count += 1;\n        }\n        if (name === \"attribute\") {\n            return count;\n        }\n\n        count += this.stringifyProperty(\"attribute\").length;\n        count += attributeSpaces.after.length;\n        const operatorSpaces = this._spacesFor(\"operator\");\n        count += operatorSpaces.before.length;\n        const operator = this.stringifyProperty(\"operator\");\n        if (name === \"operator\") {\n            return operator ? count : -1;\n        }\n\n        count += operator.length;\n        count += operatorSpaces.after.length;\n        const valueSpaces = this._spacesFor(\"value\");\n        count += valueSpaces.before.length;\n        const value = this.stringifyProperty(\"value\");\n        if (name === \"value\") {\n            return value ? count : -1;\n        }\n\n        count += value.length;\n        count += valueSpaces.after.length;\n        const insensitiveSpaces = this._spacesFor(\"insensitive\");\n        count += insensitiveSpaces.before.length;\n        if (name === \"insensitive\") {\n            return (this.insensitive) ? count : -1;\n        }\n        return -1;\n    }\n\n    toString () {\n        const selector = [\n            this.rawSpaceBefore,\n            '[',\n        ];\n\n        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n        if (this.operator && (this.value || this.value === '')) {\n            selector.push(this._stringFor('operator'));\n            selector.push(this._stringFor('value'));\n            selector.push(this._stringFor('insensitiveFlag', 'insensitive', (attrValue, attrSpaces) => {\n                if (attrValue.length > 0\n                    && !this.quoted\n                    && attrSpaces.before.length === 0\n                    && !(this.spaces.value && this.spaces.value.after)) {\n\n                    attrSpaces.before = \" \";\n                }\n                return defaultAttrConcat(attrValue, attrSpaces);\n            }));\n        }\n\n        selector.push(']');\n        selector.push(this.rawSpaceAfter);\n        return selector.join('');\n    }\n}\n\nconst CSSESC_QUOTE_OPTIONS = {\n    \"'\": {quotes: 'single', wrap: true},\n    '\"': {quotes: 'double', wrap: true},\n    [null]: {isIdentifier: true},\n};\n\nfunction defaultAttrConcat (attrValue, attrSpaces) {\n    return `${attrSpaces.before}${attrValue}${attrSpaces.after}`;\n}\n", "import Namespace from './namespace';\nimport {UNIVERSAL} from './types';\n\nexport default class Universal extends Namespace {\n    constructor (opts) {\n        super(opts);\n        this.type = UNIVERSAL;\n        this.value = '*';\n    }\n}\n", "import Node from './node';\nimport {COMBINATOR} from './types';\n\nexport default class Combinator extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = COMBINATOR;\n    }\n}\n", "import Node from './node';\nimport {NESTING} from './types';\n\nexport default class Nesting extends Node {\n    constructor (opts) {\n        super(opts);\n        this.type = NESTING;\n        this.value = '&';\n    }\n}\n", "export default function sortAscending (list) {\n    return list.sort((a, b) => a - b);\n};\n", "export const ampersand        = 38; // `&`.charCodeAt(0);\nexport const asterisk         = 42; // `*`.charCodeAt(0);\nexport const at               = 64; // `@`.charCodeAt(0);\nexport const comma            = 44; // `,`.charCodeAt(0);\nexport const colon            = 58; // `:`.charCodeAt(0);\nexport const semicolon        = 59; // `;`.charCodeAt(0);\nexport const openParenthesis  = 40; // `(`.charCodeAt(0);\nexport const closeParenthesis = 41; // `)`.charCodeAt(0);\nexport const openSquare       = 91; // `[`.charCodeAt(0);\nexport const closeSquare      = 93; // `]`.charCodeAt(0);\nexport const dollar           = 36; // `$`.charCodeAt(0);\nexport const tilde            = 126; // `~`.charCodeAt(0);\nexport const caret            = 94; // `^`.charCodeAt(0);\nexport const plus             = 43; // `+`.charCodeAt(0);\nexport const equals           = 61; // `=`.charCodeAt(0);\nexport const pipe             = 124; // `|`.charCodeAt(0);\nexport const greaterThan      = 62; // `>`.charCodeAt(0);\nexport const space            = 32; // ` `.charCodeAt(0);\nexport const singleQuote      = 39; // `'`.charCodeAt(0);\nexport const doubleQuote      = 34; // `\"`.charCodeAt(0);\nexport const slash            = 47; // `/`.charCodeAt(0);\nexport const bang             = 33; // `!`.charCodeAt(0);\n\nexport const backslash        = 92; // '\\\\'.charCodeAt(0);\nexport const cr               = 13; // '\\r'.charCodeAt(0);\nexport const feed             = 12; // '\\f'.charCodeAt(0);\nexport const newline          = 10; // '\\n'.charCodeAt(0);\nexport const tab              = 9; // '\\t'.charCodeAt(0);\n\n// Expose aliases primarily for readability.\nexport const str              = singleQuote;\n\n// No good single character representation!\nexport const comment          = -1;\nexport const word             = -2;\nexport const combinator       = -3;\n", "import * as t from './tokenTypes';\n\nconst unescapable = {\n    [t.tab]: true,\n    [t.newline]: true,\n    [t.cr]: true,\n    [t.feed]: true,\n};\nconst wordDelimiters = {\n    [t.space]: true,\n    [t.tab]: true,\n    [t.newline]: true,\n    [t.cr]: true,\n    [t.feed]: true,\n\n    [t.ampersand]: true,\n    [t.asterisk]: true,\n    [t.bang]: true,\n    [t.comma]: true,\n    [t.colon]: true,\n    [t.semicolon]: true,\n    [t.openParenthesis]: true,\n    [t.closeParenthesis]: true,\n    [t.openSquare]: true,\n    [t.closeSquare]: true,\n    [t.singleQuote]: true,\n    [t.doubleQuote]: true,\n    [t.plus]: true,\n    [t.pipe]: true,\n    [t.tilde]: true,\n    [t.greaterThan]: true,\n    [t.equals]: true,\n    [t.dollar]: true,\n    [t.caret]: true,\n    [t.slash]: true,\n};\n\n\nconst hex = {};\nconst hexChars = \"0123456789abcdefABCDEF\";\nfor (let i = 0; i < hexChars.length; i++) {\n    hex[hexChars.charCodeAt(i)] = true;\n}\n\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\nfunction consumeWord (css, start) {\n    let next = start;\n    let code;\n    do {\n        code = css.charCodeAt(next);\n        if (wordDelimiters[code]) {\n            return next - 1;\n        } else if (code === t.backslash) {\n            next = consumeEscape(css, next) + 1;\n        } else {\n            // All other characters are part of the word\n            next++;\n        }\n    } while (next < css.length);\n    return next - 1;\n}\n\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\nfunction consumeEscape (css, start) {\n    let next = start;\n    let code = css.charCodeAt(next + 1);\n    if (unescapable[code]) {\n        // just consume the escape char\n    } else if (hex[code]) {\n        let hexDigits = 0;\n        // consume up to 6 hex chars\n        do {\n            next++;\n            hexDigits++;\n            code = css.charCodeAt(next + 1);\n        } while (hex[code] && hexDigits < 6);\n        // if fewer than 6 hex chars, a trailing space ends the escape\n        if (hexDigits < 6 && code === t.space) {\n            next++;\n        }\n    } else {\n        // the next char is part of the current word\n        next++;\n    }\n    return next;\n}\n\nexport const FIELDS = {\n    TYPE: 0,\n    START_LINE: 1,\n    START_COL: 2,\n    END_LINE: 3,\n    END_COL: 4,\n    START_POS: 5,\n    END_POS: 6,\n};\n\nexport default function tokenize (input) {\n    const tokens   = [];\n    let css        = input.css.valueOf();\n    let {length}   = css;\n    let offset     = -1;\n    let line       =  1;\n    let start      =  0;\n    let end        =  0;\n\n    let code,\n        content,\n        endColumn,\n        endLine,\n        escaped,\n        escapePos,\n        last,\n        lines,\n        next,\n        nextLine,\n        nextOffset,\n        quote,\n        tokenType;\n\n    function unclosed (what, fix) {\n        if ( input.safe ) { // fyi: this is never set to true.\n            css += fix;\n            next = css.length - 1;\n        } else {\n            throw input.error('Unclosed ' + what, line, start - offset, start);\n        }\n    }\n\n    while ( start < length ) {\n        code = css.charCodeAt(start);\n\n        if ( code === t.newline ) {\n            offset = start;\n            line  += 1;\n        }\n\n        switch ( code ) {\n        case t.space:\n        case t.tab:\n        case t.newline:\n        case t.cr:\n        case t.feed:\n            next = start;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n                if ( code === t.newline ) {\n                    offset = next;\n                    line  += 1;\n                }\n            } while (\n                code === t.space   ||\n                code === t.newline ||\n                code === t.tab     ||\n                code === t.cr      ||\n                code === t.feed\n            );\n\n            tokenType = t.space;\n            endLine = line;\n            endColumn = next - offset - 1;\n            end = next;\n            break;\n\n        case t.plus:\n        case t.greaterThan:\n        case t.tilde:\n        case t.pipe:\n            next = start;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n            } while (\n                code === t.plus        ||\n                code === t.greaterThan ||\n                code === t.tilde       ||\n                code === t.pipe\n            );\n\n            tokenType = t.combinator;\n            endLine = line;\n            endColumn = start - offset;\n            end = next;\n            break;\n\n        // Consume these characters as single tokens.\n        case t.asterisk:\n        case t.ampersand:\n        case t.bang:\n        case t.comma:\n        case t.equals:\n        case t.dollar:\n        case t.caret:\n        case t.openSquare:\n        case t.closeSquare:\n        case t.colon:\n        case t.semicolon:\n        case t.openParenthesis:\n        case t.closeParenthesis:\n            next = start;\n            tokenType = code;\n            endLine = line;\n            endColumn = start - offset;\n            end = next + 1;\n            break;\n\n        case t.singleQuote:\n        case t.doubleQuote:\n            quote = code === t.singleQuote ? \"'\" : '\"';\n            next  = start;\n            do {\n                escaped = false;\n                next    = css.indexOf(quote, next + 1);\n                if ( next === -1 ) {\n                    unclosed('quote', quote);\n                }\n                escapePos = next;\n                while ( css.charCodeAt(escapePos - 1) === t.backslash ) {\n                    escapePos -= 1;\n                    escaped = !escaped;\n                }\n            } while ( escaped );\n\n            tokenType = t.str;\n            endLine = line;\n            endColumn = start - offset;\n            end = next + 1;\n            break;\n\n        default:\n            if ( code === t.slash && css.charCodeAt(start + 1) === t.asterisk ) {\n                next = css.indexOf('*/', start + 2) + 1;\n                if ( next === 0 ) {\n                    unclosed('comment', '*/');\n                }\n\n                content = css.slice(start, next + 1);\n                lines   = content.split('\\n');\n                last    = lines.length - 1;\n\n                if ( last > 0 ) {\n                    nextLine   = line + last;\n                    nextOffset = next - lines[last].length;\n                } else {\n                    nextLine   = line;\n                    nextOffset = offset;\n                }\n\n                tokenType = t.comment;\n                line   = nextLine;\n                endLine = nextLine;\n                endColumn = next - nextOffset;\n            } else if (code === t.slash) {\n                next = start;\n                tokenType = code;\n                endLine = line;\n                endColumn = start - offset;\n                end = next + 1;\n            } else {\n                next = consumeWord(css, start);\n                tokenType = t.word;\n                endLine = line;\n                endColumn = next - offset;\n            }\n\n            end = next + 1;\n            break;\n        }\n\n        // Ensure that the token structure remains consistent\n        tokens.push([\n            tokenType,              // [0] Token type\n            line,                   // [1] Starting line\n            start - offset,         // [2] Starting column\n            endLine,                // [3] Ending line\n            endColumn,              // [4] Ending column\n            start,                  // [5] Start position / Source index\n            end,                    // [6] End position\n        ]);\n\n        // Reset offset for the next token\n        if (nextOffset) {\n            offset = nextOffset;\n            nextOffset = null;\n        }\n\n        start = end;\n    }\n\n    return tokens;\n}\n", "import Root from './selectors/root';\nimport Selector from './selectors/selector';\nimport ClassName from './selectors/className';\nimport Comment from './selectors/comment';\nimport ID from './selectors/id';\nimport Tag from './selectors/tag';\nimport Str from './selectors/string';\nimport Pseudo from './selectors/pseudo';\nimport Attribute, {unescapeValue} from './selectors/attribute';\nimport Universal from './selectors/universal';\nimport Combinator from './selectors/combinator';\nimport Nesting from './selectors/nesting';\n\nimport sortAsc from './sortAscending';\nimport tokenize, {FIELDS as TOKEN} from './tokenize';\n\nimport * as tokens from './tokenTypes';\nimport * as types from './selectors/types';\nimport {unesc, getProp, ensureObject} from './util';\n\nconst WHITESPACE_TOKENS = {\n    [tokens.space]: true,\n    [tokens.cr]: true,\n    [tokens.feed]: true,\n    [tokens.newline]: true,\n    [tokens.tab]: true,\n};\n\nconst WHITESPACE_EQUIV_TOKENS = {\n    ...WHITESPACE_TOKENS,\n    [tokens.comment]: true,\n};\n\nfunction tokenStart (token) {\n    return {\n        line: token[TOKEN.START_LINE],\n        column: token[TOKEN.START_COL],\n    };\n}\n\nfunction tokenEnd (token) {\n    return {\n        line: token[TOKEN.END_LINE],\n        column: token[TOKEN.END_COL],\n    };\n}\n\n\nfunction getSource (startLine, startColumn, endLine, endColumn) {\n    return {\n        start: {\n            line: startLine,\n            column: startColumn,\n        },\n        end: {\n            line: endLine,\n            column: endColumn,\n        },\n    };\n}\n\nfunction getTokenSource (token) {\n    return getSource(\n        token[TOKEN.START_LINE],\n        token[TOKEN.START_COL],\n        token[TOKEN.END_LINE],\n        token[TOKEN.END_COL]\n    );\n}\n\nfunction getTokenSourceSpan (startToken, endToken) {\n    if (!startToken) {\n        return undefined;\n    }\n    return getSource(\n        startToken[TOKEN.START_LINE],\n        startToken[TOKEN.START_COL],\n        endToken[TOKEN.END_LINE],\n        endToken[TOKEN.END_COL]\n    );\n}\n\nfunction unescapeProp (node, prop) {\n    let value = node[prop];\n    if (typeof value !== \"string\") {\n        return;\n    }\n    if (value.indexOf(\"\\\\\") !== -1) {\n        ensureObject(node, 'raws');\n        node[prop] = unesc(value);\n        if (node.raws[prop] === undefined) {\n            node.raws[prop] = value;\n        }\n    }\n    return node;\n}\n\nfunction indexesOf (array, item) {\n    let i = -1;\n    const indexes = [];\n\n    while ((i = array.indexOf(item, i + 1)) !== -1) {\n        indexes.push(i);\n    }\n\n    return indexes;\n}\n\nfunction uniqs () {\n    const list = Array.prototype.concat.apply([], arguments);\n\n    return list.filter((item, i) => i === list.indexOf(item));\n}\n\nexport default class Parser {\n    constructor (rule, options = {}) {\n        this.rule = rule;\n        this.options = Object.assign({lossy: false, safe: false}, options);\n        this.position = 0;\n\n        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\n        this.tokens = tokenize({\n            css: this.css,\n            error: this._errorGenerator(),\n            safe: this.options.safe,\n        });\n\n        let rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n        this.root = new Root({source: rootSource});\n        this.root.errorGenerator = this._errorGenerator();\n\n\n        const selector = new Selector({\n            source: {start: {line: 1, column: 1}},\n            sourceIndex: 0,\n        });\n        this.root.append(selector);\n        this.current = selector;\n\n        this.loop();\n    }\n\n    _errorGenerator () {\n        return (message, errorOptions) => {\n            if (typeof this.rule === 'string') {\n                return new Error(message);\n            }\n            return this.rule.error(message, errorOptions);\n        };\n    }\n\n    attribute () {\n        const attr = [];\n        const startingToken = this.currToken;\n        this.position ++;\n        while (\n            this.position < this.tokens.length &&\n            this.currToken[TOKEN.TYPE] !== tokens.closeSquare\n        ) {\n            attr.push(this.currToken);\n            this.position ++;\n        }\n        if (this.currToken[TOKEN.TYPE] !== tokens.closeSquare) {\n            return this.expected('closing square bracket', this.currToken[TOKEN.START_POS]);\n        }\n\n        const len = attr.length;\n        const node = {\n            source: getSource(\n                startingToken[1],\n                startingToken[2],\n                this.currToken[3],\n                this.currToken[4]\n            ),\n            sourceIndex: startingToken[TOKEN.START_POS],\n        };\n\n        if (len === 1 && !~[tokens.word].indexOf(attr[0][TOKEN.TYPE])) {\n            return this.expected('attribute', attr[0][TOKEN.START_POS]);\n        }\n\n        let pos = 0;\n        let spaceBefore = '';\n        let commentBefore = '';\n        let lastAdded = null;\n        let spaceAfterMeaningfulToken = false;\n\n        while (pos < len) {\n            const token = attr[pos];\n            const content = this.content(token);\n            const next = attr[pos + 1];\n\n            switch (token[TOKEN.TYPE]) {\n            case tokens.space:\n                // if (\n                //     len === 1 ||\n                //     pos === 0 && this.content(next) === '|'\n                // ) {\n                //     return this.expected('attribute', token[TOKEN.START_POS], content);\n                // }\n                spaceAfterMeaningfulToken = true;\n                if (this.options.lossy) {\n                    break;\n                }\n                if (lastAdded) {\n                    ensureObject(node, 'spaces', lastAdded);\n                    const prevContent = node.spaces[lastAdded].after || '';\n                    node.spaces[lastAdded].after = prevContent + content;\n\n                    const existingComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n                    if (existingComment) {\n                        node.raws.spaces[lastAdded].after = existingComment + content;\n                    }\n                } else {\n                    spaceBefore = spaceBefore + content;\n                    commentBefore = commentBefore + content;\n                }\n                break;\n            case tokens.asterisk:\n                if (next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                } else if ((!node.namespace || (lastAdded === \"namespace\" && !spaceAfterMeaningfulToken)) && next) {\n                    if (spaceBefore) {\n                        ensureObject(node, 'spaces', 'attribute');\n                        node.spaces.attribute.before = spaceBefore;\n                        spaceBefore = '';\n                    }\n                    if (commentBefore) {\n                        ensureObject(node, 'raws', 'spaces', 'attribute');\n                        node.raws.spaces.attribute.before = spaceBefore;\n                        commentBefore = '';\n                    }\n                    node.namespace = (node.namespace || \"\") + content;\n                    const rawValue = getProp(node, 'raws', 'namespace') || null;\n                    if (rawValue) {\n                        node.raws.namespace += content;\n                    }\n                    lastAdded = 'namespace';\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.dollar:\n                if (lastAdded === \"value\") {\n                    let oldRawValue = getProp(node, 'raws', 'value');\n                    node.value += \"$\";\n                    if (oldRawValue) {\n                        node.raws.value = oldRawValue + \"$\";\n                    }\n                    break;\n                }\n                // Falls through\n            case tokens.caret:\n                if (next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.combinator:\n                if (content === '~' && next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                }\n                if (content !== '|') {\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                }\n                if (next[TOKEN.TYPE] === tokens.equals) {\n                    node.operator = content;\n                    lastAdded = 'operator';\n                } else if (!node.namespace && !node.attribute) {\n                    node.namespace = true;\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.word:\n                if (\n                    next &&\n                    this.content(next) === '|' &&\n                    (attr[pos + 2] && attr[pos + 2][TOKEN.TYPE] !== tokens.equals) && // this look-ahead probably fails with comment nodes involved.\n                    !node.operator &&\n                    !node.namespace\n                ) {\n                    node.namespace = content;\n                    lastAdded = 'namespace';\n                } else if (!node.attribute || (lastAdded === \"attribute\" && !spaceAfterMeaningfulToken)) {\n                    if (spaceBefore) {\n                        ensureObject(node, 'spaces', 'attribute');\n                        node.spaces.attribute.before = spaceBefore;\n\n                        spaceBefore = '';\n                    }\n                    if (commentBefore) {\n                        ensureObject(node, 'raws', 'spaces', 'attribute');\n                        node.raws.spaces.attribute.before = commentBefore;\n                        commentBefore = '';\n                    }\n                    node.attribute = (node.attribute || \"\") + content;\n                    const rawValue = getProp(node, 'raws', 'attribute') || null;\n                    if (rawValue) {\n                        node.raws.attribute += content;\n                    }\n                    lastAdded = 'attribute';\n                } else if ((!node.value && node.value !== \"\") || (lastAdded === \"value\" && !(spaceAfterMeaningfulToken || node.quoteMark))) {\n                    let unescaped = unesc(content);\n                    let oldRawValue = getProp(node, 'raws', 'value') || '';\n                    let oldValue = node.value || '';\n                    node.value = oldValue + unescaped;\n                    node.quoteMark = null;\n                    if (unescaped !== content || oldRawValue) {\n                        ensureObject(node, 'raws');\n                        node.raws.value = (oldRawValue || oldValue) + content;\n                    }\n                    lastAdded = 'value';\n                } else {\n                    let insensitive = (content === 'i' || content === \"I\");\n                    if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n                        node.insensitive = insensitive;\n                        if (!insensitive || content === \"I\") {\n                            ensureObject(node, 'raws');\n                            node.raws.insensitiveFlag = content;\n                        }\n                        lastAdded = 'insensitive';\n                        if (spaceBefore) {\n                            ensureObject(node, 'spaces', 'insensitive');\n                            node.spaces.insensitive.before = spaceBefore;\n\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            ensureObject(node, 'raws', 'spaces', 'insensitive');\n                            node.raws.spaces.insensitive.before = commentBefore;\n                            commentBefore = '';\n                        }\n                    } else if (node.value || node.value === '') {\n                        lastAdded = 'value';\n                        node.value += content;\n                        if (node.raws.value) {\n                            node.raws.value += content;\n                        }\n                    }\n                }\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.str:\n                if (!node.attribute || !node.operator) {\n                    return this.error(`Expected an attribute followed by an operator preceding the string.`, {\n                        index: token[TOKEN.START_POS],\n                    });\n                }\n                let {unescaped, quoteMark} = unescapeValue(content);\n                node.value = unescaped;\n                node.quoteMark = quoteMark;\n                lastAdded = 'value';\n\n                ensureObject(node, 'raws');\n                node.raws.value = content;\n\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.equals:\n                if (!node.attribute) {\n                    return this.expected('attribute', token[TOKEN.START_POS], content);\n                }\n                if (node.value) {\n                    return this.error('Unexpected \"=\" found; an operator was already defined.', {index: token[TOKEN.START_POS]});\n                }\n                node.operator = node.operator ? node.operator + content : content;\n                lastAdded = 'operator';\n                spaceAfterMeaningfulToken = false;\n                break;\n            case tokens.comment:\n                if (lastAdded) {\n                    if (spaceAfterMeaningfulToken || (next && next[TOKEN.TYPE] === tokens.space) ||\n                        lastAdded === 'insensitive'\n                    ) {\n                        const lastComment = getProp(node, 'spaces', lastAdded, 'after') || '';\n                        const rawLastComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n\n                        ensureObject(node, 'raws', 'spaces', lastAdded);\n                        node.raws.spaces[lastAdded].after = rawLastComment + content;\n                    } else {\n                        const lastValue = node[lastAdded] || '';\n                        const rawLastValue = getProp(node, 'raws', lastAdded) || lastValue;\n                        ensureObject(node, 'raws');\n                        node.raws[lastAdded] = rawLastValue + content;\n                    }\n                } else {\n                    commentBefore = commentBefore + content;\n                }\n                break;\n            default:\n                return this.error(`Unexpected \"${content}\" found.`, {index: token[TOKEN.START_POS]});\n            }\n            pos ++;\n        }\n        unescapeProp(node, \"attribute\");\n        unescapeProp(node, \"namespace\");\n        this.newNode(new Attribute(node));\n        this.position ++;\n    }\n\n    /**\n     * return a node containing meaningless garbage up to (but not including) the specified token position.\n     * if the token position is negative, all remaining tokens are consumed.\n     *\n     * This returns an array containing a single string node if all whitespace,\n     * otherwise an array of comment nodes with space before and after.\n     *\n     * These tokens are not added to the current selector, the caller can add them or use them to amend\n     * a previous node's space metadata.\n     *\n     * In lossy mode, this returns only comments.\n     */\n    parseWhitespaceEquivalentTokens (stopPosition) {\n        if (stopPosition < 0) {\n            stopPosition = this.tokens.length;\n        }\n        let startPosition = this.position;\n        let nodes = [];\n        let space = \"\";\n        let lastComment = undefined;\n        do {\n            if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\n                if (!this.options.lossy) {\n                    space += this.content();\n                }\n            } else if (this.currToken[TOKEN.TYPE] === tokens.comment) {\n                let spaces = {};\n                if (space) {\n                    spaces.before = space;\n                    space = \"\";\n                }\n                lastComment = new Comment({\n                    value: this.content(),\n                    source: getTokenSource(this.currToken),\n                    sourceIndex: this.currToken[TOKEN.START_POS],\n                    spaces,\n                });\n                nodes.push(lastComment);\n            }\n        } while (++this.position < stopPosition);\n\n        if (space) {\n            if (lastComment) {\n                lastComment.spaces.after = space;\n            } else if (!this.options.lossy) {\n                let firstToken = this.tokens[startPosition];\n                let lastToken = this.tokens[this.position - 1];\n                nodes.push(new Str({\n                    value: '',\n                    source: getSource(\n                        firstToken[TOKEN.START_LINE],\n                        firstToken[TOKEN.START_COL],\n                        lastToken[TOKEN.END_LINE],\n                        lastToken[TOKEN.END_COL],\n                    ),\n                    sourceIndex: firstToken[TOKEN.START_POS],\n                    spaces: {before: space, after: ''},\n                }));\n            }\n        }\n        return nodes;\n    }\n\n    /**\n     *\n     * @param {*} nodes\n     */\n    convertWhitespaceNodesToSpace (nodes, requiredSpace = false) {\n        let space = \"\";\n        let rawSpace = \"\";\n        nodes.forEach(n => {\n            let spaceBefore = this.lossySpace(n.spaces.before, requiredSpace);\n            let rawSpaceBefore = this.lossySpace(n.rawSpaceBefore, requiredSpace);\n            space += spaceBefore + this.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n            rawSpace += spaceBefore + n.value + this.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n        });\n        if (rawSpace === space) {\n            rawSpace = undefined;\n        }\n        let result = {space, rawSpace};\n        return result;\n    }\n\n    isNamedCombinator (position = this.position) {\n        return this.tokens[position + 0] && this.tokens[position + 0][TOKEN.TYPE] === tokens.slash &&\n               this.tokens[position + 1] && this.tokens[position + 1][TOKEN.TYPE] === tokens.word &&\n               this.tokens[position + 2] && this.tokens[position + 2][TOKEN.TYPE] === tokens.slash;\n\n    }\n    namedCombinator () {\n        if (this.isNamedCombinator()) {\n            let nameRaw = this.content(this.tokens[this.position + 1]);\n            let name = unesc(nameRaw).toLowerCase();\n            let raws = {};\n            if (name !== nameRaw) {\n                raws.value = `/${nameRaw}/`;\n            }\n            let node = new Combinator({\n                value: `/${name}/`,\n                source: getSource(\n                    this.currToken[TOKEN.START_LINE],\n                    this.currToken[TOKEN.START_COL],\n                    this.tokens[this.position + 2][TOKEN.END_LINE],\n                    this.tokens[this.position + 2][TOKEN.END_COL],\n                ),\n                sourceIndex: this.currToken[TOKEN.START_POS],\n                raws,\n            });\n            this.position = this.position + 3;\n            return node;\n        } else {\n            this.unexpected();\n        }\n    }\n\n    combinator () {\n        if (this.content() === '|') {\n            return this.namespace();\n        }\n        // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n        let nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.closeParenthesis) {\n            let nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n            if (nodes.length > 0) {\n                let last = this.current.last;\n                if (last) {\n                    let {space, rawSpace} = this.convertWhitespaceNodesToSpace(nodes);\n                    if (rawSpace !== undefined) {\n                        last.rawSpaceAfter += rawSpace;\n                    }\n                    last.spaces.after += space;\n                } else {\n                    nodes.forEach(n => this.newNode(n));\n                }\n            }\n            return;\n        }\n\n        let firstToken = this.currToken;\n        let spaceOrDescendantSelectorNodes = undefined;\n        if (nextSigTokenPos > this.position) {\n            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n        }\n\n        let node;\n        if (this.isNamedCombinator()) {\n            node = this.namedCombinator();\n        } else if (this.currToken[TOKEN.TYPE] === tokens.combinator) {\n            node = new Combinator({\n                value: this.content(),\n                source: getTokenSource(this.currToken),\n                sourceIndex: this.currToken[TOKEN.START_POS],\n            });\n            this.position++;\n        } else if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\n            // pass\n        } else if (!spaceOrDescendantSelectorNodes) {\n            this.unexpected();\n        }\n\n        if (node) {\n            if (spaceOrDescendantSelectorNodes) {\n                let {space, rawSpace} = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes);\n                node.spaces.before = space;\n                node.rawSpaceBefore = rawSpace;\n            }\n        } else {\n            // descendant combinator\n            let {space, rawSpace} = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true);\n            if (!rawSpace) {\n                rawSpace = space;\n            }\n            let spaces = {};\n            let raws = {spaces: {}};\n            if (space.endsWith(' ') && rawSpace.endsWith(' ')) {\n                spaces.before = space.slice(0, space.length - 1);\n                raws.spaces.before = rawSpace.slice(0, rawSpace.length - 1);\n            } else if (space.startsWith(' ') && rawSpace.startsWith(' ')) {\n                spaces.after = space.slice(1);\n                raws.spaces.after = rawSpace.slice(1);\n            } else {\n                raws.value = rawSpace;\n            }\n            node = new Combinator({\n                value: ' ',\n                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n                sourceIndex: firstToken[TOKEN.START_POS],\n                spaces,\n                raws,\n            });\n        }\n\n        if (this.currToken && this.currToken[TOKEN.TYPE] === tokens.space) {\n            node.spaces.after = this.optionalSpace(this.content());\n            this.position++;\n        }\n\n        return this.newNode(node);\n    }\n\n    comma () {\n        if (this.position === this.tokens.length - 1) {\n            this.root.trailingComma = true;\n            this.position ++;\n            return;\n        }\n        this.current._inferEndPosition();\n        const selector = new Selector({\n            source: {\n                start: tokenStart(this.tokens[this.position + 1]),\n            },\n            sourceIndex: this.tokens[this.position + 1][TOKEN.START_POS],\n        });\n        this.current.parent.append(selector);\n        this.current = selector;\n        this.position ++;\n    }\n\n    comment () {\n        const current = this.currToken;\n        this.newNode(new Comment({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }));\n        this.position ++;\n    }\n\n    error (message, opts) {\n        throw this.root.error(message, opts);\n    }\n\n    missingBackslash () {\n        return this.error('Expected a backslash preceding the semicolon.', {\n            index: this.currToken[TOKEN.START_POS],\n        });\n    }\n\n    missingParenthesis () {\n        return this.expected('opening parenthesis', this.currToken[TOKEN.START_POS]);\n    }\n\n    missingSquareBracket () {\n        return this.expected('opening square bracket', this.currToken[TOKEN.START_POS]);\n    }\n\n    unexpected () {\n        return this.error(`Unexpected '${this.content()}'. Escaping special characters with \\\\ may help.`, this.currToken[TOKEN.START_POS]);\n    }\n\n    unexpectedPipe () {\n        return this.error(`Unexpected '|'.`, this.currToken[TOKEN.START_POS]);\n    }\n\n    namespace () {\n        const before = this.prevToken && this.content(this.prevToken) || true;\n        if (this.nextToken[TOKEN.TYPE] === tokens.word) {\n            this.position ++;\n            return this.word(before);\n        } else if (this.nextToken[TOKEN.TYPE] === tokens.asterisk) {\n            this.position ++;\n            return this.universal(before);\n        }\n\n        this.unexpectedPipe();\n    }\n\n    nesting () {\n        if (this.nextToken) {\n            let nextContent = this.content(this.nextToken);\n            if (nextContent === \"|\") {\n                this.position++;\n                return;\n            }\n        }\n        const current = this.currToken;\n        this.newNode(new Nesting({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }));\n        this.position ++;\n    }\n\n    parentheses () {\n        let last = this.current.last;\n        let unbalanced = 1;\n        this.position ++;\n        if (last && last.type === types.PSEUDO) {\n            const selector = new Selector({\n                source: {start: tokenStart(this.tokens[this.position])},\n                sourceIndex: this.tokens[this.position][TOKEN.START_POS],\n            });\n            const cache = this.current;\n            last.append(selector);\n            this.current = selector;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\n                    unbalanced ++;\n                }\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\n                    unbalanced --;\n                }\n                if (unbalanced) {\n                    this.parse();\n                } else {\n                    this.current.source.end = tokenEnd(this.currToken);\n                    this.current.parent.source.end = tokenEnd(this.currToken);\n                    this.position ++;\n                }\n            }\n            this.current = cache;\n        } else {\n            // I think this case should be an error. It's used to implement a basic parse of media queries\n            // but I don't think it's a good idea.\n            let parenStart = this.currToken;\n            let parenValue = \"(\";\n            let parenEnd;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\n                    unbalanced ++;\n                }\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\n                    unbalanced --;\n                }\n                parenEnd = this.currToken;\n                parenValue += this.parseParenthesisToken(this.currToken);\n                this.position ++;\n            }\n            if (last) {\n                last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n            } else {\n                this.newNode(new Str({\n                    value: parenValue,\n                    source: getSource(\n                        parenStart[TOKEN.START_LINE],\n                        parenStart[TOKEN.START_COL],\n                        parenEnd[TOKEN.END_LINE],\n                        parenEnd[TOKEN.END_COL],\n                    ),\n                    sourceIndex: parenStart[TOKEN.START_POS],\n                }));\n            }\n        }\n        if (unbalanced) {\n            return this.expected('closing parenthesis', this.currToken[TOKEN.START_POS]);\n        }\n    }\n\n    pseudo () {\n        let pseudoStr = '';\n        let startingToken = this.currToken;\n        while (this.currToken && this.currToken[TOKEN.TYPE] === tokens.colon) {\n            pseudoStr += this.content();\n            this.position ++;\n        }\n        if (!this.currToken) {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n        }\n        if (this.currToken[TOKEN.TYPE] === tokens.word) {\n            this.splitWord(false, (first, length) => {\n                pseudoStr += first;\n                this.newNode(new Pseudo({\n                    value: pseudoStr,\n                    source: getTokenSourceSpan(startingToken, this.currToken),\n                    sourceIndex: startingToken[TOKEN.START_POS],\n                }));\n                if (\n                    length > 1 &&\n                    this.nextToken &&\n                    this.nextToken[TOKEN.TYPE] === tokens.openParenthesis\n                ) {\n                    this.error('Misplaced parenthesis.', {\n                        index: this.nextToken[TOKEN.START_POS],\n                    });\n                }\n            });\n        } else {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[TOKEN.START_POS]);\n        }\n    }\n\n    space () {\n        const content = this.content();\n        // Handle space before and after the selector\n        if (\n            this.position === 0 ||\n            this.prevToken[TOKEN.TYPE] === tokens.comma ||\n            this.prevToken[TOKEN.TYPE] === tokens.openParenthesis ||\n            (this.current.nodes.every((node) => node.type === 'comment'))\n        ) {\n            this.spaces = this.optionalSpace(content);\n            this.position ++;\n        } else if (\n            this.position === (this.tokens.length - 1) ||\n            this.nextToken[TOKEN.TYPE] === tokens.comma ||\n            this.nextToken[TOKEN.TYPE] === tokens.closeParenthesis\n        ) {\n            this.current.last.spaces.after = this.optionalSpace(content);\n            this.position ++;\n        } else {\n            this.combinator();\n        }\n    }\n\n    string () {\n        const current = this.currToken;\n        this.newNode(new Str({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }));\n        this.position ++;\n    }\n\n    universal (namespace) {\n        const nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position ++;\n            return this.namespace();\n        }\n        const current = this.currToken;\n        this.newNode(new Universal({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[TOKEN.START_POS],\n        }), namespace);\n        this.position ++;\n    }\n\n    splitWord (namespace, firstCallback) {\n        let nextToken = this.nextToken;\n        let word = this.content();\n        while (\n            nextToken &&\n            ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[TOKEN.TYPE])\n        ) {\n            this.position ++;\n            let current = this.content();\n            word += current;\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\n                let next = this.nextToken;\n                if (next && next[TOKEN.TYPE] === tokens.space) {\n                    word += this.requiredSpace(this.content(next));\n                    this.position ++;\n                }\n            }\n            nextToken = this.nextToken;\n        }\n        const hasClass = indexesOf(word, '.').filter(i => {\n            // Allow escaped dot within class name\n            const escapedDot = word[i - 1] === '\\\\';\n            // Allow decimal numbers percent in @keyframes\n            const isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n            return !escapedDot && !isKeyframesPercent;\n        });\n        let hasId = indexesOf(word, '#').filter(i => word[i - 1] !== '\\\\');\n        // Eliminate Sass interpolations from the list of id indexes\n        const interpolations = indexesOf(word, '#{');\n        if (interpolations.length) {\n            hasId = hasId.filter(hashIndex => !~interpolations.indexOf(hashIndex));\n        }\n        let indices = sortAsc(uniqs([0, ...hasClass, ...hasId]));\n        indices.forEach((ind, i) => {\n            const index = indices[i + 1] || word.length;\n            const value = word.slice(ind, index);\n            if (i === 0 && firstCallback) {\n                return firstCallback.call(this, value, indices.length);\n            }\n            let node;\n            const current = this.currToken;\n            const sourceIndex = current[TOKEN.START_POS] + indices[i];\n            const source = getSource(\n                current[1],\n                current[2] + ind,\n                current[3],\n                current[2] + (index - 1)\n            );\n            if (~hasClass.indexOf(ind)) {\n                let classNameOpts = {\n                    value: value.slice(1),\n                    source,\n                    sourceIndex,\n                };\n                node = new ClassName(unescapeProp(classNameOpts, \"value\"));\n            } else if (~hasId.indexOf(ind)) {\n                let idOpts = {\n                    value: value.slice(1),\n                    source,\n                    sourceIndex,\n                };\n                node = new ID(unescapeProp(idOpts, \"value\"));\n            } else {\n                let tagOpts = {\n                    value,\n                    source,\n                    sourceIndex,\n                };\n                unescapeProp(tagOpts, \"value\");\n                node = new Tag(tagOpts);\n            }\n            this.newNode(node, namespace);\n            // Ensure that the namespace is used only once\n            namespace = null;\n        });\n        this.position ++;\n    }\n\n    word (namespace) {\n        const nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position ++;\n            return this.namespace();\n        }\n        return this.splitWord(namespace);\n    }\n\n    loop () {\n        while (this.position < this.tokens.length) {\n            this.parse(true);\n        }\n        this.current._inferEndPosition();\n        return this.root;\n    }\n\n    parse (throwOnParenthesis) {\n        switch (this.currToken[TOKEN.TYPE]) {\n        case tokens.space:\n            this.space();\n            break;\n        case tokens.comment:\n            this.comment();\n            break;\n        case tokens.openParenthesis:\n            this.parentheses();\n            break;\n        case tokens.closeParenthesis:\n            if (throwOnParenthesis) {\n                this.missingParenthesis();\n            }\n            break;\n        case tokens.openSquare:\n            this.attribute();\n            break;\n        case tokens.dollar:\n        case tokens.caret:\n        case tokens.equals:\n        case tokens.word:\n            this.word();\n            break;\n        case tokens.colon:\n            this.pseudo();\n            break;\n        case tokens.comma:\n            this.comma();\n            break;\n        case tokens.asterisk:\n            this.universal();\n            break;\n        case tokens.ampersand:\n            this.nesting();\n            break;\n        case tokens.slash:\n        case tokens.combinator:\n            this.combinator();\n            break;\n        case tokens.str:\n            this.string();\n            break;\n        // These cases throw; no break needed.\n        case tokens.closeSquare:\n            this.missingSquareBracket();\n        case tokens.semicolon:\n            this.missingBackslash();\n        default:\n            this.unexpected();\n        }\n    }\n\n    /**\n     * Helpers\n     */\n\n    expected (description, index, found) {\n        if (Array.isArray(description)) {\n            const last = description.pop();\n            description = `${description.join(', ')} or ${last}`;\n        }\n        const an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n        if (!found) {\n            return this.error(\n                `Expected ${an} ${description}.`,\n                {index}\n            );\n        }\n        return this.error(\n            `Expected ${an} ${description}, found \"${found}\" instead.`,\n            {index}\n        );\n    }\n\n    requiredSpace (space) {\n        return this.options.lossy ? ' ' : space;\n    }\n\n    optionalSpace (space) {\n        return this.options.lossy ? '' : space;\n    }\n\n    lossySpace (space, required) {\n        if (this.options.lossy) {\n            return required ? ' ' : '';\n        } else {\n            return space;\n        }\n    }\n\n    parseParenthesisToken (token) {\n        const content = this.content(token);\n        if (token[TOKEN.TYPE] === tokens.space) {\n            return this.requiredSpace(content);\n        } else {\n            return content;\n        }\n    }\n\n    newNode (node, namespace) {\n        if (namespace) {\n            if (/^ +$/.test(namespace)) {\n                if (!this.options.lossy) {\n                    this.spaces = (this.spaces || '') + namespace;\n                }\n                namespace = true;\n            }\n            node.namespace = namespace;\n            unescapeProp(node, \"namespace\");\n        }\n        if (this.spaces) {\n            node.spaces.before = this.spaces;\n            this.spaces = '';\n        }\n        return this.current.append(node);\n    }\n\n    content (token = this.currToken) {\n        return this.css.slice(token[TOKEN.START_POS], token[TOKEN.END_POS]);\n    }\n\n    get currToken () {\n        return this.tokens[this.position];\n    }\n\n    get nextToken () {\n        return this.tokens[this.position + 1];\n    }\n\n    get prevToken () {\n        return this.tokens[this.position - 1];\n    }\n\n    /**\n     * returns the index of the next non-whitespace, non-comment token.\n     * returns -1 if no meaningful token is found.\n     */\n    locateNextMeaningfulToken (startPosition = this.position + 1) {\n        let searchPosition = startPosition;\n        while (searchPosition < this.tokens.length) {\n            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][TOKEN.TYPE]]) {\n                searchPosition++;\n                continue;\n            } else {\n                return searchPosition;\n            }\n        }\n        return -1;\n    }\n}\n", "import Parser from './parser';\n\nexport default class Processor {\n    constructor (func, options) {\n        this.func = func || function noop () {};\n        this.funcRes = null;\n        this.options = options;\n    }\n\n    _shouldUpdateSelector (rule, options = {}) {\n        let merged = Object.assign({}, this.options, options);\n        if (merged.updateSelector === false) {\n            return false;\n        } else {\n            return typeof rule !== \"string\";\n        }\n    }\n\n    _isLossy (options = {}) {\n        let merged = Object.assign({}, this.options, options);\n        if (merged.lossless === false) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    _root (rule, options = {}) {\n        let parser = new Parser(rule, this._parseOptions(options));\n        return parser.root;\n    }\n\n    _parseOptions (options) {\n        return {\n            lossy: this._isLossy(options),\n        };\n    }\n\n    _run (rule, options = {}) {\n        return new Promise((resolve, reject) => {\n            try {\n                let root = this._root(rule, options);\n                Promise.resolve(this.func(root)).then(transform => {\n                    let string = undefined;\n                    if (this._shouldUpdateSelector(rule, options)) {\n                        string = root.toString();\n                        rule.selector = string;\n                    }\n                    return {transform, root, string};\n                }).then(resolve, reject);\n            } catch (e) {\n                reject(e);\n                return;\n            }\n        });\n    }\n\n    _runSync (rule, options = {}) {\n        let root = this._root(rule, options);\n        let transform = this.func(root);\n        if (transform && typeof transform.then === \"function\") {\n            throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n        }\n        let string = undefined;\n        if (options.updateSelector && typeof rule !== \"string\") {\n            string = root.toString();\n            rule.selector = string;\n        }\n        return {transform, root, string};\n    }\n\n    /**\n     * Process rule into a selector AST.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n     */\n    ast (rule, options) {\n        return this._run(rule, options).then(result => result.root);\n    }\n\n    /**\n     * Process rule into a selector AST synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {parser.Root} The AST of the selector after processing it.\n     */\n    astSync (rule, options) {\n        return this._runSync(rule, options).root;\n    }\n\n    /**\n     * Process a selector into a transformed value asynchronously\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {Promise<any>} The value returned by the processor.\n     */\n    transform (rule, options) {\n        return this._run(rule, options).then(result => result.transform);\n    }\n\n    /**\n     * Process a selector into a transformed value synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {any} The value returned by the processor.\n     */\n    transformSync (rule, options) {\n        return this._runSync(rule, options).transform;\n    }\n\n    /**\n     * Process a selector into a new selector string asynchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {string} the selector after processing.\n     */\n    process (rule, options) {\n        return this._run(rule, options)\n            .then((result) => result.string || result.root.toString());\n    }\n\n    /**\n     * Process a selector into a new selector string synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {string} the selector after processing.\n     */\n    processSync (rule, options) {\n        let result = this._runSync(rule, options);\n        return result.string || result.root.toString();\n    }\n}\n", "import Attribute  from './attribute';\nimport ClassName  from './className';\nimport Combinator from './combinator';\nimport Comment    from './comment';\nimport Id         from './id';\nimport Nesting    from './nesting';\nimport Pseudo     from './pseudo';\nimport Root       from './root';\nimport Selector   from './selector';\nimport Str        from './string';\nimport Tag        from './tag';\nimport Universal  from './universal';\n\nexport const attribute = opts => new Attribute(opts);\nexport const className = opts => new ClassName(opts);\nexport const combinator = opts => new Combinator(opts);\nexport const comment = opts => new Comment(opts);\nexport const id = opts => new Id(opts);\nexport const nesting = opts => new Nesting(opts);\nexport const pseudo = opts => new Pseudo(opts);\nexport const root = opts => new Root(opts);\nexport const selector = opts => new Selector(opts);\nexport const string = opts => new Str(opts);\nexport const tag = opts => new Tag(opts);\nexport const universal = opts => new Universal(opts);\n", "import {\n    ATTRIBUTE,\n    CLASS,\n    COMBINATOR,\n    COMMENT,\n    ID,\n    NESTING,\n    PSEUDO,\n    ROOT,\n    SELECTOR,\n    STRING,\n    TAG,\n    UNIVERSAL,\n} from \"./types\";\n\nconst IS_TYPE = {\n    [ATTRIBUTE]: true,\n    [CLASS]: true,\n    [COMBINATOR]: true,\n    [COMMENT]: true,\n    [ID]: true,\n    [NESTING]: true,\n    [PSEUDO]: true,\n    [ROOT]: true,\n    [SELECTOR]: true,\n    [STRING]: true,\n    [TAG]: true,\n    [UNIVERSAL]: true,\n};\n\nexport function isNode (node) {\n    return (typeof node === \"object\" && IS_TYPE[node.type]);\n}\n\nfunction isNodeType (type, node) {\n    return isNode(node) && node.type === type;\n}\n\nexport const isAttribute = isNodeType.bind(null, ATTRIBUTE);\nexport const isClassName = isNodeType.bind(null, CLASS);\nexport const isCombinator = isNodeType.bind(null, COMBINATOR);\nexport const isComment = isNodeType.bind(null, COMMENT);\nexport const isIdentifier = isNodeType.bind(null, ID);\nexport const isNesting = isNodeType.bind(null, NESTING);\nexport const isPseudo = isNodeType.bind(null, PSEUDO);\nexport const isRoot = isNodeType.bind(null, ROOT);\nexport const isSelector = isNodeType.bind(null, SELECTOR);\nexport const isString = isNodeType.bind(null, STRING);\nexport const isTag = isNodeType.bind(null, TAG);\nexport const isUniversal = isNodeType.bind(null, UNIVERSAL);\n\nexport function isPseudoElement (node) {\n    return isPseudo(node)\n           && node.value\n           && (\n               node.value.startsWith(\"::\")\n             || node.value.toLowerCase() === \":before\"\n             || node.value.toLowerCase() === \":after\"\n             || node.value.toLowerCase() === \":first-letter\"\n             || node.value.toLowerCase() === \":first-line\"\n           );\n}\nexport function isPseudoClass (node) {\n    return isPseudo(node) && !isPseudoElement(node);\n}\n\nexport function isContainer (node) {\n    return !!(isNode(node) && node.walk);\n}\n\nexport function isNamespace (node) {\n    return isAttribute(node) || isTag(node);\n}\n", "export * from \"./types\";\nexport * from \"./constructors\";\nexport * from \"./guards\";\n", "import Processor from './processor';\nimport * as selectors from './selectors';\n\nconst parser = processor => new Processor(processor);\n\nObject.assign(parser, selectors);\n\nexport default parser;\n", "\nconst selectorParser = require('../postcss-selector-parser/index.js');\n\n'use strict';\n\nfunction CommentRemover(options) {\n  this.options = options;\n}\n\nCommentRemover.prototype.canRemove = function (comment) {\n  const remove = this.options.remove;\n\n  if (remove) {\n    return remove(comment);\n  } else {\n    const isImportant = comment.indexOf('!') === 0;\n\n    if (!isImportant) {\n      return true;\n    }\n\n    if (this.options.removeAll || this._hasFirst) {\n      return true;\n    } else if (this.options.removeAllButFirst && !this._hasFirst) {\n      this._hasFirst = true;\n      return false;\n    }\n  }\n};\n\nfunction commentParser(input) {\n  /** @type [number, number, number][] */\n  const tokens = [];\n  const length = input.length;\n  let pos = 0;\n  let next;\n\n  while (pos < length) {\n    next = input.indexOf('/*', pos);\n\n    if (~next) {\n      tokens.push([0, pos, next]);\n      pos = next;\n\n      next = input.indexOf('*/', pos + 2);\n      tokens.push([1, pos + 2, next]);\n      pos = next + 2;\n    } else {\n      tokens.push([0, pos, length]);\n      pos = length;\n    }\n  }\n\n  return tokens;\n};\n\n/** @typedef {object} Options\n *  @property {boolean=} removeAll\n *  @property {boolean=} removeAllButFirst\n *  @property {(s: string) => boolean=} remove\n */\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(opts = {}) {\n  const remover = new CommentRemover(opts);\n  const matcherCache = new Map();\n  const replacerCache = new Map();\n\n  /**\n   * @param {string} source\n   * @return {[number, number, number][]}\n   */\n  function matchesComments(source) {\n    if (matcherCache.has(source)) {\n      return matcherCache.get(source);\n    }\n\n    const result = commentParser(source).filter(([type]) => type);\n\n    matcherCache.set(source, result);\n\n    return result;\n  }\n\n  /**\n   * @param {string} source\n   * @param {(s: string) => string[]} space\n   * @return {string}\n   */\n  function replaceComments(source, space, separator = ' ') {\n    const key = source + '@|@' + separator;\n\n    if (replacerCache.has(key)) {\n      return replacerCache.get(key);\n    }\n    const parsed = commentParser(source).reduce((value, [type, start, end]) => {\n      const contents = source.slice(start, end);\n\n      if (!type) {\n        return value + contents;\n      }\n\n      if (remover.canRemove(contents)) {\n        return value + separator;\n      }\n\n      return `${value}/*${contents}*/`;\n    }, '');\n\n    const result = space(parsed).join(' ');\n\n    replacerCache.set(key, result);\n\n    return result;\n  }\n\n  /**\n   * @param {string} source\n   * @param {(s: string) => string[]} space\n   * @return {string}\n   */\n  function replaceCommentsInSelector(source, space) {\n    const key = source + '@|@';\n\n    if (replacerCache.has(key)) {\n      return replacerCache.get(key);\n    }\n    const processed = selectorParser((ast) => {\n      ast.walk((node) => {\n        if (node.type === 'comment') {\n          const contents = node.value.slice(2, -2);\n          if (remover.canRemove(contents)) {\n            node.remove();\n          }\n        }\n        const rawSpaceAfter = replaceComments(node.rawSpaceAfter, space, '');\n        const rawSpaceBefore = replaceComments(node.rawSpaceBefore, space, '');\n        // If comments are not removed, the result of trim will be returned,\n        // so if we compare and there are no changes, skip it.\n        if (rawSpaceAfter !== node.rawSpaceAfter.trim()) {\n          node.rawSpaceAfter = rawSpaceAfter;\n        }\n        if (rawSpaceBefore !== node.rawSpaceBefore.trim()) {\n          node.rawSpaceBefore = rawSpaceBefore;\n        }\n      });\n    }).processSync(source);\n\n    const result = space(processed).join(' ');\n\n    replacerCache.set(key, result);\n\n    return result;\n  }\n\n  return {\n    postcssPlugin: 'postcss-discard-comments',\n\n    OnceExit(css, { list }) {\n      css.walk((node) => {\n        if (node.type === 'comment' && remover.canRemove(node.text)) {\n          node.remove();\n\n          return;\n        }\n\n        if (typeof node.raws.between === 'string') {\n          node.raws.between = replaceComments(node.raws.between, list.space);\n        }\n\n        if (node.type === 'decl') {\n          if (node.raws.value && node.raws.value.raw) {\n            if (node.raws.value.value === node.value) {\n              node.value = replaceComments(node.raws.value.raw, list.space);\n            } else {\n              node.value = replaceComments(node.value, list.space);\n            }\n\n            /** @type {null | {value: string, raw: string}} */ (\n              node.raws.value\n            ) = null;\n          }\n\n          if (node.raws.important) {\n            node.raws.important = replaceComments(\n              node.raws.important,\n              list.space\n            );\n\n            const b = matchesComments(node.raws.important);\n\n            node.raws.important = b.length ? node.raws.important : '!important';\n          } else {\n            node.value = replaceComments(node.value, list.space);\n          }\n\n          return;\n        }\n\n        if (node.type === 'rule') {\n          if (node.raws.selector && node.raws.selector.raw) {\n            node.raws.selector.raw = replaceCommentsInSelector(\n              node.raws.selector.raw,\n              list.space\n            );\n          } else if (node.selector && node.selector.includes('/*')) {\n            node.selector = replaceCommentsInSelector(\n              node.selector,\n              list.space\n            );\n          }\n\n          return;\n        }\n\n        if (node.type === 'atrule') {\n          if (node.raws.afterName) {\n            const commentsReplaced = replaceComments(\n              node.raws.afterName,\n              list.space\n            );\n\n            if (!commentsReplaced.length) {\n              node.raws.afterName = commentsReplaced + ' ';\n            } else {\n              node.raws.afterName = ' ' + commentsReplaced + ' ';\n            }\n          }\n\n          if (node.raws.params && node.raws.params.raw) {\n            node.raws.params.raw = replaceComments(\n              node.raws.params.raw,\n              list.space\n            );\n          } else if (node.params && node.params.includes('/*')) {\n            node.params = replaceComments(node.params, list.space);\n          }\n        }\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;"],
  "mappings": "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",
  "names": ["str", "hex", "selector", "id", "str", "selector", "string", "isIdentifier", "ID", "String", "selector", "selector", "unescaped", "space", "String", "word", "ID", "parser", "root", "string", "combinator", "comment", "ID", "String", "combinator", "comment", "comment", "space"]
}
