{
  "version": 3,
  "sources": ["../src/postcss/css-syntax-error.js", "../src/postcss/stringifier.js", "../src/postcss/stringify.js", "../src/postcss/symbols.js", "../src/postcss/node.js", "../src/postcss/comment.js", "../src/postcss/declaration.js", "../src/postcss/container.js", "../src/postcss/at-rule.js", "../src/postcss/root.js", "../src/postcss/list.js", "../src/postcss/rule.js", "../src/postcss/input.js", "../src/postcss/tokenize.js", "../src/postcss/parser.js", "../src/postcss/parse.js", "../src/postcss/document.js", "../src/postcss/fromJSON.js", "../src/postcss/map-generator.js", "../src/postcss/warn-once.js", "../src/postcss/warning.js", "../src/postcss/result.js", "../src/postcss/no-work-result.js", "../src/postcss/lazy-result.js", "../src/postcss/processor.js", "../src/postcss/postcss.js", "../src/postcss-selector-parser/util/unesc.js", "../src/postcss-selector-parser/util/getProp.js", "../src/postcss-selector-parser/util/ensureObject.js", "../src/postcss-selector-parser/selectors/node.js", "../src/postcss-selector-parser/selectors/types.js", "../src/postcss-selector-parser/selectors/container.js", "../src/postcss-selector-parser/selectors/root.js", "../src/postcss-selector-parser/selectors/selector.js", "../src/cssesc/index.js", "../src/postcss-selector-parser/selectors/className.js", "../src/postcss-selector-parser/selectors/comment.js", "../src/postcss-selector-parser/selectors/id.js", "../src/postcss-selector-parser/selectors/namespace.js", "../src/postcss-selector-parser/selectors/tag.js", "../src/postcss-selector-parser/selectors/string.js", "../src/postcss-selector-parser/selectors/pseudo.js", "../src/postcss-selector-parser/selectors/attribute.js", "../src/postcss-selector-parser/selectors/universal.js", "../src/postcss-selector-parser/selectors/combinator.js", "../src/postcss-selector-parser/selectors/nesting.js", "../src/postcss-selector-parser/sortAscending.js", "../src/postcss-selector-parser/tokenTypes.js", "../src/postcss-selector-parser/tokenize.js", "../src/postcss-selector-parser/parser.js", "../src/postcss-selector-parser/processor.js", "../src/postcss-selector-parser/selectors/index.js", "../src/postcss-selector-parser/selectors/constructors.js", "../src/postcss-selector-parser/selectors/guards.js", "../src/postcss-selector-parser/index.js", "../src/ExtractorResultSets.ts", "../src/options.ts", "../src/VariablesStructure.ts", "../src/index.ts"],
  "sourcesContent": ["export class CssSyntaxError extends Error {\r\n    constructor(message, line, column, source, file, plugin) {\r\n        super(message);\r\n        this.name = 'CssSyntaxError';\r\n        this.reason = message;\r\n        if (file) {\r\n            this.file = file;\r\n        }\r\n        if (source) {\r\n            this.source = source;\r\n        }\r\n        if (plugin) {\r\n            this.plugin = plugin;\r\n        }\r\n        if (typeof line !== 'undefined' && typeof column !== 'undefined') {\r\n            if (typeof line === 'number') {\r\n                this.line = line;\r\n                this.column = column;\r\n            }\r\n            else {\r\n                this.line = line.line;\r\n                this.column = line.column;\r\n                this.endLine = column.line;\r\n                this.endColumn = column.column;\r\n            }\r\n        }\r\n        this.setMessage();\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, CssSyntaxError);\r\n        }\r\n    }\r\n    setMessage() {\r\n        this.message = this.plugin ? this.plugin + ': ' : '';\r\n        this.message += this.file ? this.file : '<css input>';\r\n        if (typeof this.line !== 'undefined') {\r\n            this.message += ':' + this.line + ':' + this.column;\r\n        }\r\n        this.message += ': ' + this.reason;\r\n    }\r\n    showSourceCode() {\r\n        return '';\r\n    }\r\n    toString() {\r\n        let code = this.showSourceCode();\r\n        if (code) {\r\n            code = '\\n\\n' + code + '\\n';\r\n        }\r\n        return this.name + ': ' + this.message + code;\r\n    }\r\n}\r\n", "const DEFAULT_RAW = {\r\n    after: '\\n',\r\n    beforeClose: '\\n',\r\n    beforeComment: '\\n',\r\n    beforeDecl: '\\n',\r\n    beforeOpen: ' ',\r\n    beforeRule: '\\n',\r\n    colon: ': ',\r\n    commentLeft: ' ',\r\n    commentRight: ' ',\r\n    emptyBody: '',\r\n    indent: '    ',\r\n    semicolon: false\r\n};\r\nfunction capitalize(str) {\r\n    return str[0].toUpperCase() + str.slice(1);\r\n}\r\nexport class Stringifier {\r\n    constructor(builder) {\r\n        this.builder = builder;\r\n    }\r\n    atrule(node, semicolon) {\r\n        let name = '@' + node.name;\r\n        const params = node.params ? this.rawValue(node, 'params') : '';\r\n        if (typeof node.raws.afterName !== 'undefined') {\r\n            name += node.raws.afterName;\r\n        }\r\n        else if (params) {\r\n            name += ' ';\r\n        }\r\n        if (node.nodes) {\r\n            this.block(node, name + params);\r\n        }\r\n        else {\r\n            const end = (node.raws.between || '') + (semicolon ? ';' : '');\r\n            this.builder(name + params + end, node);\r\n        }\r\n    }\r\n    beforeAfter(node, detect) {\r\n        let value;\r\n        if (node.type === 'decl') {\r\n            value = this.raw(node, null, 'beforeDecl');\r\n        }\r\n        else if (node.type === 'comment') {\r\n            value = this.raw(node, null, 'beforeComment');\r\n        }\r\n        else if (detect === 'before') {\r\n            value = this.raw(node, null, 'beforeRule');\r\n        }\r\n        else {\r\n            value = this.raw(node, null, 'beforeClose');\r\n        }\r\n        let buf = node.parent;\r\n        let depth = 0;\r\n        while (buf && buf.type !== 'root') {\r\n            depth += 1;\r\n            buf = buf.parent;\r\n        }\r\n        if (value.includes('\\n')) {\r\n            const indent = this.raw(node, null, 'indent');\r\n            if (indent.length) {\r\n                for (let step = 0; step < depth; step++)\r\n                    value += indent;\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n    block(node, start) {\r\n        const between = this.raw(node, 'between', 'beforeOpen');\r\n        this.builder(start + between + '{', node, 'start');\r\n        let after;\r\n        if (node.nodes && node.nodes.length) {\r\n            this.body(node);\r\n            after = this.raw(node, 'after');\r\n        }\r\n        else {\r\n            after = this.raw(node, 'after', 'emptyBody');\r\n        }\r\n        if (after)\r\n            this.builder(after);\r\n        this.builder('}', node, 'end');\r\n    }\r\n    body(node) {\r\n        let last = node.nodes.length - 1;\r\n        while (last > 0) {\r\n            if (node.nodes[last].type !== 'comment')\r\n                break;\r\n            last -= 1;\r\n        }\r\n        const semicolon = this.raw(node, 'semicolon');\r\n        for (let i = 0; i < node.nodes.length; i++) {\r\n            const child = node.nodes[i];\r\n            const before = this.raw(child, 'before');\r\n            if (before)\r\n                this.builder(before);\r\n            this.stringify(child, last !== i || semicolon);\r\n        }\r\n    }\r\n    comment(node) {\r\n        const left = this.raw(node, 'left', 'commentLeft');\r\n        const right = this.raw(node, 'right', 'commentRight');\r\n        this.builder('/*' + left + node.text + right + '*/', node);\r\n    }\r\n    decl(node, semicolon) {\r\n        const between = this.raw(node, 'between', 'colon');\r\n        let string = node.prop + between + this.rawValue(node, 'value');\r\n        if (node.important) {\r\n            string += node.raws.important || ' !important';\r\n        }\r\n        if (semicolon)\r\n            string += ';';\r\n        this.builder(string, node);\r\n    }\r\n    document(node) {\r\n        this.body(node);\r\n    }\r\n    raw(node, own, detect) {\r\n        let value;\r\n        if (!detect)\r\n            detect = own;\r\n        // Already had\r\n        if (own) {\r\n            value = node.raws[own];\r\n            if (typeof value !== 'undefined')\r\n                return value;\r\n        }\r\n        const parent = node.parent;\r\n        if (detect === 'before') {\r\n            // Hack for first rule in CSS\r\n            if (!parent || (parent.type === 'root' && parent.first === node)) {\r\n                return '';\r\n            }\r\n            // `root` nodes in `document` should use only their own raws\r\n            if (parent && parent.type === 'document') {\r\n                return '';\r\n            }\r\n        }\r\n        // Floating child without parent\r\n        if (!parent)\r\n            return DEFAULT_RAW[detect];\r\n        // Detect style by other nodes\r\n        const root = node.root();\r\n        if (!root.rawCache)\r\n            root.rawCache = {};\r\n        if (typeof root.rawCache[detect] !== 'undefined') {\r\n            return root.rawCache[detect];\r\n        }\r\n        if (detect === 'before' || detect === 'after') {\r\n            return this.beforeAfter(node, detect);\r\n        }\r\n        else {\r\n            const method = 'raw' + capitalize(detect);\r\n            if (this[method]) {\r\n                value = this[method](root, node);\r\n            }\r\n            else {\r\n                root.walk(i => {\r\n                    value = i.raws[own];\r\n                    if (typeof value !== 'undefined')\r\n                        return false;\r\n                });\r\n            }\r\n        }\r\n        if (typeof value === 'undefined')\r\n            value = DEFAULT_RAW[detect];\r\n        root.rawCache[detect] = value;\r\n        return value;\r\n    }\r\n    rawBeforeClose(root) {\r\n        let value;\r\n        root.walk(i => {\r\n            if (i.nodes && i.nodes.length > 0) {\r\n                if (typeof i.raws.after !== 'undefined') {\r\n                    value = i.raws.after;\r\n                    if (value.includes('\\n')) {\r\n                        value = value.replace(/[^\\n]+$/, '');\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n        });\r\n        if (value)\r\n            value = value.replace(/\\S/g, '');\r\n        return value;\r\n    }\r\n    rawBeforeComment(root, node) {\r\n        let value;\r\n        root.walkComments(i => {\r\n            if (typeof i.raws.before !== 'undefined') {\r\n                value = i.raws.before;\r\n                if (value.includes('\\n')) {\r\n                    value = value.replace(/[^\\n]+$/, '');\r\n                }\r\n                return false;\r\n            }\r\n        });\r\n        if (typeof value === 'undefined') {\r\n            value = this.raw(node, null, 'beforeDecl');\r\n        }\r\n        else if (value) {\r\n            value = value.replace(/\\S/g, '');\r\n        }\r\n        return value;\r\n    }\r\n    rawBeforeDecl(root, node) {\r\n        let value;\r\n        root.walkDecls(i => {\r\n            if (typeof i.raws.before !== 'undefined') {\r\n                value = i.raws.before;\r\n                if (value.includes('\\n')) {\r\n                    value = value.replace(/[^\\n]+$/, '');\r\n                }\r\n                return false;\r\n            }\r\n        });\r\n        if (typeof value === 'undefined') {\r\n            value = this.raw(node, null, 'beforeRule');\r\n        }\r\n        else if (value) {\r\n            value = value.replace(/\\S/g, '');\r\n        }\r\n        return value;\r\n    }\r\n    rawBeforeOpen(root) {\r\n        let value;\r\n        root.walk(i => {\r\n            if (i.type !== 'decl') {\r\n                value = i.raws.between;\r\n                if (typeof value !== 'undefined')\r\n                    return false;\r\n            }\r\n        });\r\n        return value;\r\n    }\r\n    rawBeforeRule(root) {\r\n        let value;\r\n        root.walk(i => {\r\n            if (i.nodes && (i.parent !== root || root.first !== i)) {\r\n                if (typeof i.raws.before !== 'undefined') {\r\n                    value = i.raws.before;\r\n                    if (value.includes('\\n')) {\r\n                        value = value.replace(/[^\\n]+$/, '');\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n        });\r\n        if (value)\r\n            value = value.replace(/\\S/g, '');\r\n        return value;\r\n    }\r\n    rawColon(root) {\r\n        let value;\r\n        root.walkDecls(i => {\r\n            if (typeof i.raws.between !== 'undefined') {\r\n                value = i.raws.between.replace(/[^\\s:]/g, '');\r\n                return false;\r\n            }\r\n        });\r\n        return value;\r\n    }\r\n    rawEmptyBody(root) {\r\n        let value;\r\n        root.walk(i => {\r\n            if (i.nodes && i.nodes.length === 0) {\r\n                value = i.raws.after;\r\n                if (typeof value !== 'undefined')\r\n                    return false;\r\n            }\r\n        });\r\n        return value;\r\n    }\r\n    rawIndent(root) {\r\n        if (root.raws.indent)\r\n            return root.raws.indent;\r\n        let value;\r\n        root.walk(i => {\r\n            const p = i.parent;\r\n            if (p && p !== root && p.parent && p.parent === root) {\r\n                if (typeof i.raws.before !== 'undefined') {\r\n                    const parts = i.raws.before.split('\\n');\r\n                    value = parts[parts.length - 1];\r\n                    value = value.replace(/\\S/g, '');\r\n                    return false;\r\n                }\r\n            }\r\n        });\r\n        return value;\r\n    }\r\n    rawSemicolon(root) {\r\n        let value;\r\n        root.walk(i => {\r\n            if (i.nodes && i.nodes.length && i.last.type === 'decl') {\r\n                value = i.raws.semicolon;\r\n                if (typeof value !== 'undefined')\r\n                    return false;\r\n            }\r\n        });\r\n        return value;\r\n    }\r\n    rawValue(node, prop) {\r\n        const value = node[prop];\r\n        const raw = node.raws[prop];\r\n        if (raw && raw.value === value) {\r\n            return raw.raw;\r\n        }\r\n        return value;\r\n    }\r\n    root(node) {\r\n        this.body(node);\r\n        if (node.raws.after)\r\n            this.builder(node.raws.after);\r\n    }\r\n    rule(node) {\r\n        this.block(node, this.rawValue(node, 'selector'));\r\n        if (node.raws.ownSemicolon) {\r\n            this.builder(node.raws.ownSemicolon, node, 'end');\r\n        }\r\n    }\r\n    stringify(node, semicolon) {\r\n        /* c8 ignore start */\r\n        if (!this[node.type]) {\r\n            throw new Error('Unknown AST node type ' +\r\n                node.type +\r\n                '. ' +\r\n                'Maybe you need to change PostCSS stringifier.');\r\n        }\r\n        /* c8 ignore stop */\r\n        this[node.type](node, semicolon);\r\n    }\r\n}\r\n", "import { Stringifier } from \"./stringifier\";\r\nexport function stringify(node, builder) {\r\n    const str = new Stringifier(builder);\r\n    str.stringify(node);\r\n}\r\n", "export const isClean = Symbol('isClean');\r\nexport const my = Symbol('my');\r\n", "import { CssSyntaxError } from \"./css-syntax-error\";\r\nimport { Stringifier } from \"./stringifier\";\r\nimport { stringify } from \"./stringify\";\r\nimport { isClean, my } from \"./symbols\";\r\nfunction cloneNode(obj, parent) {\r\n    const cloned = new obj.constructor();\r\n    for (const i in obj) {\r\n        if (!Object.prototype.hasOwnProperty.call(obj, i)) {\r\n            /* c8 ignore next 2 */\r\n            continue;\r\n        }\r\n        if (i === 'proxyCache')\r\n            continue;\r\n        let value = obj[i];\r\n        const type = typeof value;\r\n        if (i === 'parent' && type === 'object') {\r\n            if (parent)\r\n                cloned[i] = parent;\r\n        }\r\n        else if (i === 'source') {\r\n            cloned[i] = value;\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            cloned[i] = value.map(j => cloneNode(j, cloned));\r\n        }\r\n        else {\r\n            if (type === 'object' && value !== null)\r\n                value = cloneNode(value);\r\n            cloned[i] = value;\r\n        }\r\n    }\r\n    return cloned;\r\n}\r\nfunction sourceOffset(inputCSS, position) {\r\n    // Not all custom syntaxes support `offset` in `source.start` and `source.end`\r\n    if (position &&\r\n        typeof position.offset !== 'undefined') {\r\n        return position.offset;\r\n    }\r\n    let column = 1;\r\n    let line = 1;\r\n    let offset = 0;\r\n    for (let i = 0; i < inputCSS.length; i++) {\r\n        if (line === position.line && column === position.column) {\r\n            offset = i;\r\n            break;\r\n        }\r\n        if (inputCSS[i] === '\\n') {\r\n            column = 1;\r\n            line += 1;\r\n        }\r\n        else {\r\n            column += 1;\r\n        }\r\n    }\r\n    return offset;\r\n}\r\nexport class Node {\r\n    constructor(defaults = {}) {\r\n        this.raws = {};\r\n        this[isClean] = false;\r\n        this[my] = true;\r\n        for (const name in defaults) {\r\n            if (name === 'nodes') {\r\n                this.nodes = [];\r\n                for (const node of defaults[name]) {\r\n                    if (typeof node.clone === 'function') {\r\n                        this.append(node.clone());\r\n                    }\r\n                    else {\r\n                        this.append(node);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this[name] = defaults[name];\r\n            }\r\n        }\r\n    }\r\n    addToError(error) {\r\n        error.postcssNode = this;\r\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\r\n            const s = this.source;\r\n            error.stack = error.stack.replace(/\\n\\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);\r\n        }\r\n        return error;\r\n    }\r\n    after(add) {\r\n        this.parent.insertAfter(this, add);\r\n        return this;\r\n    }\r\n    assign(overrides = {}) {\r\n        for (const name in overrides) {\r\n            this[name] = overrides[name];\r\n        }\r\n        return this;\r\n    }\r\n    before(add) {\r\n        this.parent.insertBefore(this, add);\r\n        return this;\r\n    }\r\n    cleanRaws(keepBetween) {\r\n        delete this.raws.before;\r\n        delete this.raws.after;\r\n        if (!keepBetween)\r\n            delete this.raws.between;\r\n    }\r\n    clone(overrides = {}) {\r\n        const cloned = cloneNode(this);\r\n        for (const name in overrides) {\r\n            cloned[name] = overrides[name];\r\n        }\r\n        return cloned;\r\n    }\r\n    cloneAfter(overrides = {}) {\r\n        const cloned = this.clone(overrides);\r\n        this.parent.insertAfter(this, cloned);\r\n        return cloned;\r\n    }\r\n    cloneBefore(overrides = {}) {\r\n        const cloned = this.clone(overrides);\r\n        this.parent.insertBefore(this, cloned);\r\n        return cloned;\r\n    }\r\n    error(message, opts = {}) {\r\n        if (this.source) {\r\n            const { end, start } = this.rangeBy(opts);\r\n            return this.source.input.error(message, { column: start.column, line: start.line }, { column: end.column, line: end.line }, opts);\r\n        }\r\n        return new CssSyntaxError(message);\r\n    }\r\n    getProxyProcessor() {\r\n        return {\r\n            get(node, prop) {\r\n                if (prop === 'proxyOf') {\r\n                    return node;\r\n                }\r\n                else if (prop === 'root') {\r\n                    return () => node.root().toProxy();\r\n                }\r\n                else {\r\n                    return node[prop];\r\n                }\r\n            },\r\n            set(node, prop, value) {\r\n                if (node[prop] === value)\r\n                    return true;\r\n                node[prop] = value;\r\n                if (prop === 'prop' ||\r\n                    prop === 'value' ||\r\n                    prop === 'name' ||\r\n                    prop === 'params' ||\r\n                    prop === 'important' ||\r\n                    /* c8 ignore next */\r\n                    prop === 'text') {\r\n                    node.markDirty();\r\n                }\r\n                return true;\r\n            }\r\n        };\r\n    }\r\n    /* c8 ignore next 3 */\r\n    markClean() {\r\n        this[isClean] = true;\r\n    }\r\n    markDirty() {\r\n        if (this[isClean]) {\r\n            this[isClean] = false;\r\n            let next = this;\r\n            while ((next = next.parent)) {\r\n                next[isClean] = false;\r\n            }\r\n        }\r\n    }\r\n    next() {\r\n        if (!this.parent)\r\n            return undefined;\r\n        const index = this.parent.index(this);\r\n        return this.parent.nodes[index + 1];\r\n    }\r\n    positionBy(opts) {\r\n        let pos = this.source.start;\r\n        if (opts.index) {\r\n            pos = this.positionInside(opts.index);\r\n        }\r\n        else if (opts.word) {\r\n            const stringRepresentation = this.source.input.css.slice(sourceOffset(this.source.input.css, this.source.start), sourceOffset(this.source.input.css, this.source.end));\r\n            const index = stringRepresentation.indexOf(opts.word);\r\n            if (index !== -1)\r\n                pos = this.positionInside(index);\r\n        }\r\n        return pos;\r\n    }\r\n    positionInside(index) {\r\n        let column = this.source.start.column;\r\n        let line = this.source.start.line;\r\n        const offset = sourceOffset(this.source.input.css, this.source.start);\r\n        const end = offset + index;\r\n        for (let i = offset; i < end; i++) {\r\n            if (this.source.input.css[i] === '\\n') {\r\n                column = 1;\r\n                line += 1;\r\n            }\r\n            else {\r\n                column += 1;\r\n            }\r\n        }\r\n        return { column, line };\r\n    }\r\n    prev() {\r\n        if (!this.parent)\r\n            return undefined;\r\n        const index = this.parent.index(this);\r\n        return this.parent.nodes[index - 1];\r\n    }\r\n    rangeBy(opts) {\r\n        let start = {\r\n            column: this.source.start.column,\r\n            line: this.source.start.line\r\n        };\r\n        let end = this.source.end\r\n            ? {\r\n                column: this.source.end.column + 1,\r\n                line: this.source.end.line\r\n            }\r\n            : {\r\n                column: start.column + 1,\r\n                line: start.line\r\n            };\r\n        if (opts.word) {\r\n            const stringRepresentation = this.source.input.css.slice(sourceOffset(this.source.input.css, this.source.start), sourceOffset(this.source.input.css, this.source.end));\r\n            const index = stringRepresentation.indexOf(opts.word);\r\n            if (index !== -1) {\r\n                start = this.positionInside(index);\r\n                end = this.positionInside(index + opts.word.length);\r\n            }\r\n        }\r\n        else {\r\n            if (opts.start) {\r\n                start = {\r\n                    column: opts.start.column,\r\n                    line: opts.start.line\r\n                };\r\n            }\r\n            else if (opts.index) {\r\n                start = this.positionInside(opts.index);\r\n            }\r\n            if (opts.end) {\r\n                end = {\r\n                    column: opts.end.column,\r\n                    line: opts.end.line\r\n                };\r\n            }\r\n            else if (typeof opts.endIndex === 'number') {\r\n                end = this.positionInside(opts.endIndex);\r\n            }\r\n            else if (opts.index) {\r\n                end = this.positionInside(opts.index + 1);\r\n            }\r\n        }\r\n        if (end.line < start.line ||\r\n            (end.line === start.line && end.column <= start.column)) {\r\n            end = { column: start.column + 1, line: start.line };\r\n        }\r\n        return { end, start };\r\n    }\r\n    raw(prop, defaultType) {\r\n        const str = new Stringifier();\r\n        return str.raw(this, prop, defaultType);\r\n    }\r\n    remove() {\r\n        if (this.parent) {\r\n            this.parent.removeChild(this);\r\n        }\r\n        this.parent = undefined;\r\n        return this;\r\n    }\r\n    replaceWith(...nodes) {\r\n        if (this.parent) {\r\n            let bookmark = this;\r\n            let foundSelf = false;\r\n            for (const node of nodes) {\r\n                if (node === this) {\r\n                    foundSelf = true;\r\n                }\r\n                else if (foundSelf) {\r\n                    this.parent.insertAfter(bookmark, node);\r\n                    bookmark = node;\r\n                }\r\n                else {\r\n                    this.parent.insertBefore(bookmark, node);\r\n                }\r\n            }\r\n            if (!foundSelf) {\r\n                this.remove();\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    root() {\r\n        let result = this;\r\n        while (result.parent && result.parent.type !== 'document') {\r\n            result = result.parent;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON(_, inputs) {\r\n        const fixed = {};\r\n        const emitInputs = inputs == null;\r\n        inputs = inputs || new Map();\r\n        let inputsNextIndex = 0;\r\n        for (const name in this) {\r\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\r\n                /* c8 ignore next 2 */\r\n                continue;\r\n            }\r\n            if (name === 'parent' || name === 'proxyCache')\r\n                continue;\r\n            const value = this[name];\r\n            if (Array.isArray(value)) {\r\n                fixed[name] = value.map(i => {\r\n                    if (typeof i === 'object' && i.toJSON) {\r\n                        return i.toJSON(null, inputs);\r\n                    }\r\n                    else {\r\n                        return i;\r\n                    }\r\n                });\r\n            }\r\n            else if (typeof value === 'object' && value.toJSON) {\r\n                fixed[name] = value.toJSON(null, inputs);\r\n            }\r\n            else if (name === 'source') {\r\n                let inputId = inputs.get(value.input);\r\n                if (inputId == null) {\r\n                    inputId = inputsNextIndex;\r\n                    inputs.set(value.input, inputsNextIndex);\r\n                    inputsNextIndex++;\r\n                }\r\n                fixed[name] = {\r\n                    end: value.end,\r\n                    inputId,\r\n                    start: value.start\r\n                };\r\n            }\r\n            else {\r\n                fixed[name] = value;\r\n            }\r\n        }\r\n        if (emitInputs) {\r\n            fixed.inputs = [...inputs.keys()].map(input => input.toJSON());\r\n        }\r\n        return fixed;\r\n    }\r\n    toProxy() {\r\n        if (!this.proxyCache) {\r\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\r\n        }\r\n        return this.proxyCache;\r\n    }\r\n    toString(stringifier = stringify) {\r\n        if (stringifier.stringify)\r\n            stringifier = stringifier.stringify;\r\n        let result = '';\r\n        stringifier(this, i => {\r\n            result += i;\r\n        });\r\n        return result;\r\n    }\r\n    warn(result, text, opts) {\r\n        const data = { node: this };\r\n        for (const i in opts)\r\n            data[i] = opts[i];\r\n        return result.warn(text, data);\r\n    }\r\n    get proxyOf() {\r\n        return this;\r\n    }\r\n}\r\n", "import { Node } from './node';\r\nexport class Comment extends Node {\r\n    constructor(defaults) {\r\n        super(defaults);\r\n        this.type = 'comment';\r\n    }\r\n}\r\n", "import { Node } from \"./node.js\";\r\nexport class Declaration extends Node {\r\n    constructor(defaults) {\r\n        if (defaults &&\r\n            typeof defaults.value !== 'undefined' &&\r\n            typeof defaults.value !== 'string') {\r\n            defaults = { ...defaults, value: String(defaults.value) };\r\n        }\r\n        super(defaults);\r\n        this.type = 'decl';\r\n    }\r\n    get variable() {\r\n        return this.prop.startsWith('--') || this.prop[0] === '$';\r\n    }\r\n}\r\n", "import { Comment } from './comment';\r\nimport { Declaration } from './declaration';\r\nimport { isClean, my } from \"./symbols\";\r\nimport { Node } from \"./node\";\r\nlet AtRule, parse, Root, Rule;\r\nfunction cleanSource(nodes) {\r\n    return nodes.map(i => {\r\n        if (i.nodes)\r\n            i.nodes = cleanSource(i.nodes);\r\n        delete i.source;\r\n        return i;\r\n    });\r\n}\r\nfunction markTreeDirty(node) {\r\n    node[isClean] = false;\r\n    if (node.proxyOf.nodes) {\r\n        for (const i of node.proxyOf.nodes) {\r\n            markTreeDirty(i);\r\n        }\r\n    }\r\n}\r\nexport class Container extends Node {\r\n    append(...children) {\r\n        for (const child of children) {\r\n            const nodes = this.normalize(child, this.last);\r\n            for (const node of nodes)\r\n                this.proxyOf.nodes.push(node);\r\n        }\r\n        this.markDirty();\r\n        return this;\r\n    }\r\n    cleanRaws(keepBetween) {\r\n        super.cleanRaws(keepBetween);\r\n        if (this.nodes) {\r\n            for (const node of this.nodes)\r\n                node.cleanRaws(keepBetween);\r\n        }\r\n    }\r\n    each(callback) {\r\n        if (!this.proxyOf.nodes)\r\n            return undefined;\r\n        const iterator = this.getIterator();\r\n        let index, result;\r\n        while (this.indexes[iterator] < this.proxyOf.nodes.length) {\r\n            index = this.indexes[iterator];\r\n            result = callback(this.proxyOf.nodes[index], index);\r\n            if (result === false)\r\n                break;\r\n            this.indexes[iterator] += 1;\r\n        }\r\n        delete this.indexes[iterator];\r\n        return result;\r\n    }\r\n    every(condition) {\r\n        return this.nodes.every(condition);\r\n    }\r\n    getIterator() {\r\n        if (!this.lastEach)\r\n            this.lastEach = 0;\r\n        if (!this.indexes)\r\n            this.indexes = {};\r\n        this.lastEach += 1;\r\n        const iterator = this.lastEach;\r\n        this.indexes[iterator] = 0;\r\n        return iterator;\r\n    }\r\n    getProxyProcessor() {\r\n        return {\r\n            get(node, prop) {\r\n                if (prop === 'proxyOf') {\r\n                    return node;\r\n                }\r\n                else if (!node[prop]) {\r\n                    return node[prop];\r\n                }\r\n                else if (prop === 'each' ||\r\n                    (typeof prop === 'string' && prop.startsWith('walk'))) {\r\n                    return (...args) => {\r\n                        return node[prop](...args.map(i => {\r\n                            if (typeof i === 'function') {\r\n                                return (child, index) => i(child.toProxy(), index);\r\n                            }\r\n                            else {\r\n                                return i;\r\n                            }\r\n                        }));\r\n                    };\r\n                }\r\n                else if (prop === 'every' || prop === 'some') {\r\n                    return cb => {\r\n                        return node[prop]((child, ...other) => cb(child.toProxy(), ...other));\r\n                    };\r\n                }\r\n                else if (prop === 'root') {\r\n                    return () => node.root().toProxy();\r\n                }\r\n                else if (prop === 'nodes') {\r\n                    return node.nodes.map(i => i.toProxy());\r\n                }\r\n                else if (prop === 'first' || prop === 'last') {\r\n                    return node[prop].toProxy();\r\n                }\r\n                else {\r\n                    return node[prop];\r\n                }\r\n            },\r\n            set(node, prop, value) {\r\n                if (node[prop] === value)\r\n                    return true;\r\n                node[prop] = value;\r\n                if (prop === 'name' || prop === 'params' || prop === 'selector') {\r\n                    node.markDirty();\r\n                }\r\n                return true;\r\n            }\r\n        };\r\n    }\r\n    index(child) {\r\n        if (typeof child === 'number')\r\n            return child;\r\n        if (child.proxyOf)\r\n            child = child.proxyOf;\r\n        return this.proxyOf.nodes.indexOf(child);\r\n    }\r\n    insertAfter(exist, add) {\r\n        let existIndex = this.index(exist);\r\n        const nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\r\n        existIndex = this.index(exist);\r\n        for (const node of nodes)\r\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node);\r\n        let index;\r\n        for (const id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (existIndex < index) {\r\n                this.indexes[id] = index + nodes.length;\r\n            }\r\n        }\r\n        this.markDirty();\r\n        return this;\r\n    }\r\n    insertBefore(exist, add) {\r\n        let existIndex = this.index(exist);\r\n        const type = existIndex === 0 ? 'prepend' : false;\r\n        const nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\r\n        existIndex = this.index(exist);\r\n        for (const node of nodes)\r\n            this.proxyOf.nodes.splice(existIndex, 0, node);\r\n        let index;\r\n        for (const id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (existIndex <= index) {\r\n                this.indexes[id] = index + nodes.length;\r\n            }\r\n        }\r\n        this.markDirty();\r\n        return this;\r\n    }\r\n    normalize(nodes, sample) {\r\n        if (typeof nodes === 'string') {\r\n            nodes = cleanSource(parse(nodes).nodes);\r\n        }\r\n        else if (typeof nodes === 'undefined') {\r\n            nodes = [];\r\n        }\r\n        else if (Array.isArray(nodes)) {\r\n            nodes = nodes.slice(0);\r\n            for (const i of nodes) {\r\n                if (i.parent)\r\n                    i.parent.removeChild(i, 'ignore');\r\n            }\r\n        }\r\n        else if (nodes.type === 'root' && this.type !== 'document') {\r\n            nodes = nodes.nodes.slice(0);\r\n            for (const i of nodes) {\r\n                if (i.parent)\r\n                    i.parent.removeChild(i, 'ignore');\r\n            }\r\n        }\r\n        else if (nodes.type) {\r\n            nodes = [nodes];\r\n        }\r\n        else if (nodes.prop) {\r\n            if (typeof nodes.value === 'undefined') {\r\n                throw new Error('Value field is missed in node creation');\r\n            }\r\n            else if (typeof nodes.value !== 'string') {\r\n                nodes.value = String(nodes.value);\r\n            }\r\n            nodes = [new Declaration(nodes)];\r\n        }\r\n        else if (nodes.selector || nodes.selectors) {\r\n            nodes = [new Rule(nodes)];\r\n        }\r\n        else if (nodes.name) {\r\n            nodes = [new AtRule(nodes)];\r\n        }\r\n        else if (nodes.text) {\r\n            nodes = [new Comment(nodes)];\r\n        }\r\n        else {\r\n            throw new Error('Unknown node type in node creation');\r\n        }\r\n        const processed = nodes.map(i => {\r\n            /* c8 ignore next */\r\n            if (!i[my])\r\n                Container.rebuild(i);\r\n            i = i.proxyOf;\r\n            if (i.parent)\r\n                i.parent.removeChild(i);\r\n            if (i[isClean])\r\n                markTreeDirty(i);\r\n            if (!i.raws)\r\n                i.raws = {};\r\n            if (typeof i.raws.before === 'undefined') {\r\n                if (sample && typeof sample.raws.before !== 'undefined') {\r\n                    i.raws.before = sample.raws.before.replace(/\\S/g, '');\r\n                }\r\n            }\r\n            i.parent = this.proxyOf;\r\n            return i;\r\n        });\r\n        return processed;\r\n    }\r\n    prepend(...children) {\r\n        children = children.reverse();\r\n        for (const child of children) {\r\n            const nodes = this.normalize(child, this.first, 'prepend').reverse();\r\n            for (const node of nodes)\r\n                this.proxyOf.nodes.unshift(node);\r\n            for (const id in this.indexes) {\r\n                this.indexes[id] = this.indexes[id] + nodes.length;\r\n            }\r\n        }\r\n        this.markDirty();\r\n        return this;\r\n    }\r\n    push(child) {\r\n        child.parent = this;\r\n        this.proxyOf.nodes.push(child);\r\n        return this;\r\n    }\r\n    removeAll() {\r\n        for (const node of this.proxyOf.nodes)\r\n            node.parent = undefined;\r\n        this.proxyOf.nodes = [];\r\n        this.markDirty();\r\n        return this;\r\n    }\r\n    removeChild(child) {\r\n        child = this.index(child);\r\n        this.proxyOf.nodes[child].parent = undefined;\r\n        this.proxyOf.nodes.splice(child, 1);\r\n        let index;\r\n        for (const id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (index >= child) {\r\n                this.indexes[id] = index - 1;\r\n            }\r\n        }\r\n        this.markDirty();\r\n        return this;\r\n    }\r\n    replaceValues(pattern, opts, callback) {\r\n        if (!callback) {\r\n            callback = opts;\r\n            opts = {};\r\n        }\r\n        this.walkDecls(decl => {\r\n            if (opts.props && !opts.props.includes(decl.prop))\r\n                return;\r\n            if (opts.fast && !decl.value.includes(opts.fast))\r\n                return;\r\n            decl.value = decl.value.replace(pattern, callback);\r\n        });\r\n        this.markDirty();\r\n        return this;\r\n    }\r\n    some(condition) {\r\n        return this.nodes.some(condition);\r\n    }\r\n    walk(callback) {\r\n        return this.each((child, i) => {\r\n            let result;\r\n            try {\r\n                result = callback(child, i);\r\n            }\r\n            catch (e) {\r\n                throw child.addToError(e);\r\n            }\r\n            if (result !== false && child.walk) {\r\n                result = child.walk(callback);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    walkAtRules(name, callback) {\r\n        if (!callback) {\r\n            callback = name;\r\n            return this.walk((child, i) => {\r\n                if (child.type === 'atrule') {\r\n                    return callback(child, i);\r\n                }\r\n            });\r\n        }\r\n        if (name instanceof RegExp) {\r\n            return this.walk((child, i) => {\r\n                if (child.type === 'atrule' && name.test(child.name)) {\r\n                    return callback(child, i);\r\n                }\r\n            });\r\n        }\r\n        return this.walk((child, i) => {\r\n            if (child.type === 'atrule' && child.name === name) {\r\n                return callback(child, i);\r\n            }\r\n        });\r\n    }\r\n    walkComments(callback) {\r\n        return this.walk((child, i) => {\r\n            if (child.type === 'comment') {\r\n                return callback(child, i);\r\n            }\r\n        });\r\n    }\r\n    walkDecls(prop, callback) {\r\n        if (!callback) {\r\n            callback = prop;\r\n            return this.walk((child, i) => {\r\n                if (child.type === 'decl') {\r\n                    return callback(child, i);\r\n                }\r\n            });\r\n        }\r\n        if (prop instanceof RegExp) {\r\n            return this.walk((child, i) => {\r\n                if (child.type === 'decl' && prop.test(child.prop)) {\r\n                    return callback(child, i);\r\n                }\r\n            });\r\n        }\r\n        return this.walk((child, i) => {\r\n            if (child.type === 'decl' && child.prop === prop) {\r\n                return callback(child, i);\r\n            }\r\n        });\r\n    }\r\n    walkRules(selector, callback) {\r\n        if (!callback) {\r\n            callback = selector;\r\n            return this.walk((child, i) => {\r\n                if (child.type === 'rule') {\r\n                    return callback(child, i);\r\n                }\r\n            });\r\n        }\r\n        if (selector instanceof RegExp) {\r\n            return this.walk((child, i) => {\r\n                if (child.type === 'rule' && selector.test(child.selector)) {\r\n                    return callback(child, i);\r\n                }\r\n            });\r\n        }\r\n        return this.walk((child, i) => {\r\n            if (child.type === 'rule' && child.selector === selector) {\r\n                return callback(child, i);\r\n            }\r\n        });\r\n    }\r\n    get first() {\r\n        if (!this.proxyOf.nodes)\r\n            return undefined;\r\n        return this.proxyOf.nodes[0];\r\n    }\r\n    get last() {\r\n        if (!this.proxyOf.nodes)\r\n            return undefined;\r\n        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\r\n    }\r\n}\r\nContainer.registerParse = dependant => {\r\n    parse = dependant;\r\n};\r\nContainer.registerRule = dependant => {\r\n    Rule = dependant;\r\n};\r\nContainer.registerAtRule = dependant => {\r\n    AtRule = dependant;\r\n};\r\nContainer.registerRoot = dependant => {\r\n    Root = dependant;\r\n};\r\n/* c8 ignore start */\r\nContainer.rebuild = node => {\r\n    if (node.type === 'atrule') {\r\n        Object.setPrototypeOf(node, AtRule.prototype);\r\n    }\r\n    else if (node.type === 'rule') {\r\n        Object.setPrototypeOf(node, Rule.prototype);\r\n    }\r\n    else if (node.type === 'decl') {\r\n        Object.setPrototypeOf(node, Declaration.prototype);\r\n    }\r\n    else if (node.type === 'comment') {\r\n        Object.setPrototypeOf(node, Comment.prototype);\r\n    }\r\n    else if (node.type === 'root') {\r\n        Object.setPrototypeOf(node, Root.prototype);\r\n    }\r\n    node[my] = true;\r\n    if (node.nodes) {\r\n        node.nodes.forEach(child => {\r\n            Container.rebuild(child);\r\n        });\r\n    }\r\n};\r\n/* c8 ignore stop */\r\n", "import { Container } from './container';\r\nexport class AtRule extends Container {\r\n    constructor(defaults) {\r\n        super(defaults);\r\n        this.type = 'atrule';\r\n    }\r\n    append(...children) {\r\n        if (!this.proxyOf.nodes)\r\n            this.nodes = [];\r\n        return super.append(...children);\r\n    }\r\n    prepend(...children) {\r\n        if (!this.proxyOf.nodes)\r\n            this.nodes = [];\r\n        return super.prepend(...children);\r\n    }\r\n}\r\nContainer.registerAtRule(AtRule);\r\n", "import { Container } from \"./container\";\r\nlet LazyResult, Processor;\r\nexport class Root extends Container {\r\n    constructor(defaults) {\r\n        super(defaults);\r\n        this.type = 'root';\r\n        if (!this.nodes)\r\n            this.nodes = [];\r\n    }\r\n    normalize(child, sample, type) {\r\n        const nodes = super.normalize(child);\r\n        if (sample) {\r\n            if (type === 'prepend') {\r\n                if (this.nodes.length > 1) {\r\n                    sample.raws.before = this.nodes[1].raws.before;\r\n                }\r\n                else {\r\n                    delete sample.raws.before;\r\n                }\r\n            }\r\n            else if (this.first !== sample) {\r\n                for (const node of nodes) {\r\n                    node.raws.before = sample.raws.before;\r\n                }\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n    removeChild(child, ignore) {\r\n        const index = this.index(child);\r\n        if (!ignore && index === 0 && this.nodes.length > 1) {\r\n            this.nodes[1].raws.before = this.nodes[index].raws.before;\r\n        }\r\n        return super.removeChild(child);\r\n    }\r\n    toResult(opts = {}) {\r\n        const lazy = new LazyResult(new Processor(), this, opts);\r\n        return lazy.stringify();\r\n    }\r\n    static registerLazyResult = dependant => {\r\n        LazyResult = dependant;\r\n    };\r\n    static registerProcessor = dependant => {\r\n        Processor = dependant;\r\n    };\r\n}\r\nContainer.registerRoot(Root);\r\n", "export const list = {\r\n    comma(string) {\r\n        return list.split(string, [','], true);\r\n    },\r\n    space(string) {\r\n        const spaces = [' ', '\\n', '\\t'];\r\n        return list.split(string, spaces);\r\n    },\r\n    split(string, separators, last) {\r\n        const array = [];\r\n        let current = '';\r\n        let split = false;\r\n        let func = 0;\r\n        let inQuote = false;\r\n        let prevQuote = '';\r\n        let escape = false;\r\n        for (const letter of string) {\r\n            if (escape) {\r\n                escape = false;\r\n            }\r\n            else if (letter === '\\\\') {\r\n                escape = true;\r\n            }\r\n            else if (inQuote) {\r\n                if (letter === prevQuote) {\r\n                    inQuote = false;\r\n                }\r\n            }\r\n            else if (letter === '\"' || letter === \"'\") {\r\n                inQuote = true;\r\n                prevQuote = letter;\r\n            }\r\n            else if (letter === '(') {\r\n                func += 1;\r\n            }\r\n            else if (letter === ')') {\r\n                if (func > 0)\r\n                    func -= 1;\r\n            }\r\n            else if (func === 0) {\r\n                if (separators.includes(letter))\r\n                    split = true;\r\n            }\r\n            if (split) {\r\n                if (current !== '')\r\n                    array.push(current.trim());\r\n                current = '';\r\n                split = false;\r\n            }\r\n            else {\r\n                current += letter;\r\n            }\r\n        }\r\n        if (last || current !== '')\r\n            array.push(current.trim());\r\n        return array;\r\n    }\r\n};\r\n", "import { Container } from \"./container\";\r\nimport { list } from './list';\r\nexport class Rule extends Container {\r\n    constructor(defaults) {\r\n        super(defaults);\r\n        this.type = 'rule';\r\n        if (!this.nodes)\r\n            this.nodes = [];\r\n    }\r\n    get selectors() {\r\n        return list.comma(this.selector);\r\n    }\r\n    set selectors(values) {\r\n        const match = this.selector ? this.selector.match(/,\\s*/) : null;\r\n        const sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');\r\n        this.selector = values.join(sep);\r\n    }\r\n}\r\nContainer.registerRule(Rule);\r\n", "import { CssSyntaxError } from \"./css-syntax-error\";\r\nconst fromOffsetCache = Symbol('fromOffsetCache');\r\nexport class Input {\r\n    constructor(css, opts = {}) {\r\n        if (css === null ||\r\n            typeof css === 'undefined' ||\r\n            (typeof css === 'object' && !css.toString)) {\r\n            throw new Error(`PostCSS received ${css} instead of CSS string`);\r\n        }\r\n        this.css = css.toString();\r\n        if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\r\n            this.hasBOM = true;\r\n            this.css = this.css.slice(1);\r\n        }\r\n        else {\r\n            this.hasBOM = false;\r\n        }\r\n        if (this.map)\r\n            this.map.file = this.from;\r\n    }\r\n    error(message, line, column, opts = {}) {\r\n        let endColumn, endLine, result;\r\n        if (line && typeof line === 'object') {\r\n            const start = line;\r\n            const end = column;\r\n            if (typeof start.offset === 'number') {\r\n                const pos = this.fromOffset(start.offset);\r\n                line = pos.line;\r\n                column = pos.col;\r\n            }\r\n            else {\r\n                line = start.line;\r\n                column = start.column;\r\n            }\r\n            if (typeof end.offset === 'number') {\r\n                const pos = this.fromOffset(end.offset);\r\n                endLine = pos.line;\r\n                endColumn = pos.col;\r\n            }\r\n            else {\r\n                endLine = end.line;\r\n                endColumn = end.column;\r\n            }\r\n        }\r\n        else if (!column) {\r\n            const pos = this.fromOffset(line);\r\n            line = pos.line;\r\n            column = pos.col;\r\n        }\r\n        const origin = this.origin(line, column, endLine, endColumn);\r\n        if (origin) {\r\n            result = new CssSyntaxError(message, origin.endLine === undefined\r\n                ? origin.line\r\n                : { column: origin.column, line: origin.line }, origin.endLine === undefined\r\n                ? origin.column\r\n                : { column: origin.endColumn, line: origin.endLine }, origin.source, origin.file, opts.plugin);\r\n        }\r\n        else {\r\n            result = new CssSyntaxError(message, endLine === undefined ? line : { column, line }, endLine === undefined ? column : { column: endColumn, line: endLine }, this.css, this.file, opts.plugin);\r\n        }\r\n        result.input = { column, endColumn, endLine, line, source: this.css };\r\n        if (this.file) {\r\n            result.input.file = this.file;\r\n        }\r\n        return result;\r\n    }\r\n    fromOffset(offset) {\r\n        let lastLine, lineToIndex;\r\n        if (!this[fromOffsetCache]) {\r\n            const lines = this.css.split('\\n');\r\n            lineToIndex = new Array(lines.length);\r\n            let prevIndex = 0;\r\n            for (let i = 0, l = lines.length; i < l; i++) {\r\n                lineToIndex[i] = prevIndex;\r\n                prevIndex += lines[i].length + 1;\r\n            }\r\n            this[fromOffsetCache] = lineToIndex;\r\n        }\r\n        else {\r\n            lineToIndex = this[fromOffsetCache];\r\n        }\r\n        lastLine = lineToIndex[lineToIndex.length - 1];\r\n        let min = 0;\r\n        if (offset >= lastLine) {\r\n            min = lineToIndex.length - 1;\r\n        }\r\n        else {\r\n            let max = lineToIndex.length - 2;\r\n            let mid;\r\n            while (min < max) {\r\n                mid = min + ((max - min) >> 1);\r\n                if (offset < lineToIndex[mid]) {\r\n                    max = mid - 1;\r\n                }\r\n                else if (offset >= lineToIndex[mid + 1]) {\r\n                    min = mid + 1;\r\n                }\r\n                else {\r\n                    min = mid;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            col: offset - lineToIndex[min] + 1,\r\n            line: min + 1\r\n        };\r\n    }\r\n    origin(line, column, endLine, endColumn) {\r\n        if (!this.map)\r\n            return false;\r\n        const consumer = this.map.consumer();\r\n        const from = consumer.originalPositionFor({ column, line });\r\n        if (!from.source)\r\n            return false;\r\n        let to;\r\n        if (typeof endLine === 'number') {\r\n            to = consumer.originalPositionFor({ column: endColumn, line: endLine });\r\n        }\r\n        let fromUrl;\r\n        fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));\r\n        const result = {\r\n            column: from.column,\r\n            endColumn: to && to.column,\r\n            endLine: to && to.line,\r\n            line: from.line,\r\n            url: fromUrl.toString()\r\n        };\r\n        const source = consumer.sourceContentFor(from.source);\r\n        if (source)\r\n            result.source = source;\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const json = {};\r\n        for (const name of ['hasBOM', 'css', 'file', 'id']) {\r\n            if (this[name] != null) {\r\n                json[name] = this[name];\r\n            }\r\n        }\r\n        if (this.map) {\r\n            json.map = { ...this.map };\r\n            if (json.map.consumerCache) {\r\n                json.map.consumerCache = undefined;\r\n            }\r\n        }\r\n        return json;\r\n    }\r\n    get from() {\r\n        return this.file || this.id;\r\n    }\r\n}\r\n", "const SINGLE_QUOTE = \"'\".charCodeAt(0);\r\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\r\nconst BACKSLASH = '\\\\'.charCodeAt(0);\r\nconst SLASH = '/'.charCodeAt(0);\r\nconst NEWLINE = '\\n'.charCodeAt(0);\r\nconst SPACE = ' '.charCodeAt(0);\r\nconst FEED = '\\f'.charCodeAt(0);\r\nconst TAB = '\\t'.charCodeAt(0);\r\nconst CR = '\\r'.charCodeAt(0);\r\nconst OPEN_SQUARE = '['.charCodeAt(0);\r\nconst CLOSE_SQUARE = ']'.charCodeAt(0);\r\nconst OPEN_PARENTHESES = '('.charCodeAt(0);\r\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0);\r\nconst OPEN_CURLY = '{'.charCodeAt(0);\r\nconst CLOSE_CURLY = '}'.charCodeAt(0);\r\nconst SEMICOLON = ';'.charCodeAt(0);\r\nconst ASTERISK = '*'.charCodeAt(0);\r\nconst COLON = ':'.charCodeAt(0);\r\nconst AT = '@'.charCodeAt(0);\r\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\r\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\r\nconst RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/;\r\nconst RE_HEX_ESCAPE = /[\\da-f]/i;\r\nexport function tokenizer(input, options = {}) {\r\n    const css = input.css.valueOf();\r\n    const ignore = options.ignoreErrors;\r\n    let code, content, escape, next, quote;\r\n    let currentToken, escaped, escapePos, n, prev;\r\n    const length = css.length;\r\n    let pos = 0;\r\n    const buffer = [];\r\n    const returned = [];\r\n    function position() {\r\n        return pos;\r\n    }\r\n    function unclosed(what) {\r\n        throw input.error('Unclosed ' + what, pos);\r\n    }\r\n    function endOfFile() {\r\n        return returned.length === 0 && pos >= length;\r\n    }\r\n    function nextToken(opts) {\r\n        if (returned.length)\r\n            return returned.pop();\r\n        if (pos >= length)\r\n            return;\r\n        const ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\r\n        code = css.charCodeAt(pos);\r\n        switch (code) {\r\n            case NEWLINE:\r\n            case SPACE:\r\n            case TAB:\r\n            case CR:\r\n            case FEED: {\r\n                next = pos;\r\n                do {\r\n                    next += 1;\r\n                    code = css.charCodeAt(next);\r\n                } while (code === SPACE ||\r\n                    code === NEWLINE ||\r\n                    code === TAB ||\r\n                    code === CR ||\r\n                    code === FEED);\r\n                currentToken = ['space', css.slice(pos, next)];\r\n                pos = next - 1;\r\n                break;\r\n            }\r\n            case OPEN_SQUARE:\r\n            case CLOSE_SQUARE:\r\n            case OPEN_CURLY:\r\n            case CLOSE_CURLY:\r\n            case COLON:\r\n            case SEMICOLON:\r\n            case CLOSE_PARENTHESES: {\r\n                const controlChar = String.fromCharCode(code);\r\n                currentToken = [controlChar, controlChar, pos];\r\n                break;\r\n            }\r\n            case OPEN_PARENTHESES: {\r\n                prev = buffer.length ? buffer.pop()[1] : '';\r\n                n = css.charCodeAt(pos + 1);\r\n                if (prev === 'url' &&\r\n                    n !== SINGLE_QUOTE &&\r\n                    n !== DOUBLE_QUOTE &&\r\n                    n !== SPACE &&\r\n                    n !== NEWLINE &&\r\n                    n !== TAB &&\r\n                    n !== FEED &&\r\n                    n !== CR) {\r\n                    next = pos;\r\n                    do {\r\n                        escaped = false;\r\n                        next = css.indexOf(')', next + 1);\r\n                        if (next === -1) {\r\n                            if (ignore || ignoreUnclosed) {\r\n                                next = pos;\r\n                                break;\r\n                            }\r\n                            else {\r\n                                unclosed('bracket');\r\n                            }\r\n                        }\r\n                        escapePos = next;\r\n                        while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\r\n                            escapePos -= 1;\r\n                            escaped = !escaped;\r\n                        }\r\n                    } while (escaped);\r\n                    currentToken = ['brackets', css.slice(pos, next + 1), pos, next];\r\n                    pos = next;\r\n                }\r\n                else {\r\n                    next = css.indexOf(')', pos + 1);\r\n                    content = css.slice(pos, next + 1);\r\n                    if (next === -1 || RE_BAD_BRACKET.test(content)) {\r\n                        currentToken = ['(', '(', pos];\r\n                    }\r\n                    else {\r\n                        currentToken = ['brackets', content, pos, next];\r\n                        pos = next;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case SINGLE_QUOTE:\r\n            case DOUBLE_QUOTE: {\r\n                quote = code === SINGLE_QUOTE ? \"'\" : '\"';\r\n                next = pos;\r\n                do {\r\n                    escaped = false;\r\n                    next = css.indexOf(quote, next + 1);\r\n                    if (next === -1) {\r\n                        if (ignore || ignoreUnclosed) {\r\n                            next = pos + 1;\r\n                            break;\r\n                        }\r\n                        else {\r\n                            unclosed('string');\r\n                        }\r\n                    }\r\n                    escapePos = next;\r\n                    while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\r\n                        escapePos -= 1;\r\n                        escaped = !escaped;\r\n                    }\r\n                } while (escaped);\r\n                currentToken = ['string', css.slice(pos, next + 1), pos, next];\r\n                pos = next;\r\n                break;\r\n            }\r\n            case AT: {\r\n                RE_AT_END.lastIndex = pos + 1;\r\n                RE_AT_END.test(css);\r\n                if (RE_AT_END.lastIndex === 0) {\r\n                    next = css.length - 1;\r\n                }\r\n                else {\r\n                    next = RE_AT_END.lastIndex - 2;\r\n                }\r\n                currentToken = ['at-word', css.slice(pos, next + 1), pos, next];\r\n                pos = next;\r\n                break;\r\n            }\r\n            case BACKSLASH: {\r\n                next = pos;\r\n                escape = true;\r\n                while (css.charCodeAt(next + 1) === BACKSLASH) {\r\n                    next += 1;\r\n                    escape = !escape;\r\n                }\r\n                code = css.charCodeAt(next + 1);\r\n                if (escape &&\r\n                    code !== SLASH &&\r\n                    code !== SPACE &&\r\n                    code !== NEWLINE &&\r\n                    code !== TAB &&\r\n                    code !== CR &&\r\n                    code !== FEED) {\r\n                    next += 1;\r\n                    if (RE_HEX_ESCAPE.test(css.charAt(next))) {\r\n                        while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\r\n                            next += 1;\r\n                        }\r\n                        if (css.charCodeAt(next + 1) === SPACE) {\r\n                            next += 1;\r\n                        }\r\n                    }\r\n                }\r\n                currentToken = ['word', css.slice(pos, next + 1), pos, next];\r\n                pos = next;\r\n                break;\r\n            }\r\n            default: {\r\n                if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\r\n                    next = css.indexOf('*/', pos + 2) + 1;\r\n                    if (next === 0) {\r\n                        if (ignore || ignoreUnclosed) {\r\n                            next = css.length;\r\n                        }\r\n                        else {\r\n                            unclosed('comment');\r\n                        }\r\n                    }\r\n                    currentToken = ['comment', css.slice(pos, next + 1), pos, next];\r\n                    pos = next;\r\n                }\r\n                else {\r\n                    RE_WORD_END.lastIndex = pos + 1;\r\n                    RE_WORD_END.test(css);\r\n                    if (RE_WORD_END.lastIndex === 0) {\r\n                        next = css.length - 1;\r\n                    }\r\n                    else {\r\n                        next = RE_WORD_END.lastIndex - 2;\r\n                    }\r\n                    currentToken = ['word', css.slice(pos, next + 1), pos, next];\r\n                    buffer.push(currentToken);\r\n                    pos = next;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        pos++;\r\n        return currentToken;\r\n    }\r\n    function back(token) {\r\n        returned.push(token);\r\n    }\r\n    return {\r\n        back,\r\n        endOfFile,\r\n        nextToken,\r\n        position\r\n    };\r\n}\r\n", "import { AtRule } from './at-rule';\r\nimport { Comment } from './comment';\r\nimport { Declaration } from './declaration';\r\nimport { Root } from './root';\r\nimport { Rule } from './rule';\r\nimport { tokenizer } from \"./tokenize\";\r\nconst SAFE_COMMENT_NEIGHBOR = {\r\n    empty: true,\r\n    space: true\r\n};\r\nfunction findLastWithPosition(tokens) {\r\n    for (let i = tokens.length - 1; i >= 0; i--) {\r\n        const token = tokens[i];\r\n        const pos = token[3] || token[2];\r\n        if (pos)\r\n            return pos;\r\n    }\r\n}\r\nexport class Parser {\r\n    constructor(input) {\r\n        this.input = input;\r\n        this.root = new Root();\r\n        this.current = this.root;\r\n        this.spaces = '';\r\n        this.semicolon = false;\r\n        this.createTokenizer();\r\n        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };\r\n    }\r\n    atrule(token) {\r\n        const node = new AtRule();\r\n        node.name = token[1].slice(1);\r\n        if (node.name === '') {\r\n            this.unnamedAtrule(node, token);\r\n        }\r\n        this.init(node, token[2]);\r\n        let type;\r\n        let prev;\r\n        let shift;\r\n        let last = false;\r\n        let open = false;\r\n        const params = [];\r\n        const brackets = [];\r\n        while (!this.tokenizer.endOfFile()) {\r\n            token = this.tokenizer.nextToken();\r\n            type = token[0];\r\n            if (type === '(' || type === '[') {\r\n                brackets.push(type === '(' ? ')' : ']');\r\n            }\r\n            else if (type === '{' && brackets.length > 0) {\r\n                brackets.push('}');\r\n            }\r\n            else if (type === brackets[brackets.length - 1]) {\r\n                brackets.pop();\r\n            }\r\n            if (brackets.length === 0) {\r\n                if (type === ';') {\r\n                    node.source.end = this.getPosition(token[2]);\r\n                    node.source.end.offset++;\r\n                    this.semicolon = true;\r\n                    break;\r\n                }\r\n                else if (type === '{') {\r\n                    open = true;\r\n                    break;\r\n                }\r\n                else if (type === '}') {\r\n                    if (params.length > 0) {\r\n                        shift = params.length - 1;\r\n                        prev = params[shift];\r\n                        while (prev && prev[0] === 'space') {\r\n                            prev = params[--shift];\r\n                        }\r\n                        if (prev) {\r\n                            node.source.end = this.getPosition(prev[3] || prev[2]);\r\n                            node.source.end.offset++;\r\n                        }\r\n                    }\r\n                    this.end(token);\r\n                    break;\r\n                }\r\n                else {\r\n                    params.push(token);\r\n                }\r\n            }\r\n            else {\r\n                params.push(token);\r\n            }\r\n            if (this.tokenizer.endOfFile()) {\r\n                last = true;\r\n                break;\r\n            }\r\n        }\r\n        node.raws.between = this.spacesAndCommentsFromEnd(params);\r\n        if (params.length) {\r\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\r\n            this.raw(node, 'params', params);\r\n            if (last) {\r\n                token = params[params.length - 1];\r\n                node.source.end = this.getPosition(token[3] || token[2]);\r\n                node.source.end.offset++;\r\n                this.spaces = node.raws.between;\r\n                node.raws.between = '';\r\n            }\r\n        }\r\n        else {\r\n            node.raws.afterName = '';\r\n            node.params = '';\r\n        }\r\n        if (open) {\r\n            node.nodes = [];\r\n            this.current = node;\r\n        }\r\n    }\r\n    checkMissedSemicolon(tokens) {\r\n        const colon = this.colon(tokens);\r\n        if (colon === false)\r\n            return;\r\n        let founded = 0;\r\n        let token;\r\n        for (let j = colon - 1; j >= 0; j--) {\r\n            token = tokens[j];\r\n            if (token[0] !== 'space') {\r\n                founded += 1;\r\n                if (founded === 2)\r\n                    break;\r\n            }\r\n        }\r\n        // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\r\n        // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\r\n        // And because we need it after that one we do +1 to get the next one.\r\n        throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);\r\n    }\r\n    colon(tokens) {\r\n        let brackets = 0;\r\n        let prev, token, type;\r\n        for (const [i, element] of tokens.entries()) {\r\n            token = element;\r\n            type = token[0];\r\n            if (type === '(') {\r\n                brackets += 1;\r\n            }\r\n            if (type === ')') {\r\n                brackets -= 1;\r\n            }\r\n            if (brackets === 0 && type === ':') {\r\n                if (!prev) {\r\n                    this.doubleColon(token);\r\n                }\r\n                else if (prev[0] === 'word' && prev[1] === 'progid') {\r\n                    continue;\r\n                }\r\n                else {\r\n                    return i;\r\n                }\r\n            }\r\n            prev = token;\r\n        }\r\n        return false;\r\n    }\r\n    comment(token) {\r\n        const node = new Comment();\r\n        this.init(node, token[2]);\r\n        node.source.end = this.getPosition(token[3] || token[2]);\r\n        node.source.end.offset++;\r\n        const text = token[1].slice(2, -2);\r\n        if (/^\\s*$/.test(text)) {\r\n            node.text = '';\r\n            node.raws.left = text;\r\n            node.raws.right = '';\r\n        }\r\n        else {\r\n            const match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\r\n            node.text = match[2];\r\n            node.raws.left = match[1];\r\n            node.raws.right = match[3];\r\n        }\r\n    }\r\n    createTokenizer() {\r\n        this.tokenizer = tokenizer(this.input);\r\n    }\r\n    decl(tokens, customProperty) {\r\n        const node = new Declaration();\r\n        this.init(node, tokens[0][2]);\r\n        const last = tokens[tokens.length - 1];\r\n        if (last[0] === ';') {\r\n            this.semicolon = true;\r\n            tokens.pop();\r\n        }\r\n        node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\r\n        node.source.end.offset++;\r\n        while (tokens[0][0] !== 'word') {\r\n            if (tokens.length === 1)\r\n                this.unknownWord(tokens);\r\n            node.raws.before += tokens.shift()[1];\r\n        }\r\n        node.source.start = this.getPosition(tokens[0][2]);\r\n        node.prop = '';\r\n        while (tokens.length) {\r\n            const type = tokens[0][0];\r\n            if (type === ':' || type === 'space' || type === 'comment') {\r\n                break;\r\n            }\r\n            node.prop += tokens.shift()[1];\r\n        }\r\n        node.raws.between = '';\r\n        let token;\r\n        while (tokens.length) {\r\n            token = tokens.shift();\r\n            if (token[0] === ':') {\r\n                node.raws.between += token[1];\r\n                break;\r\n            }\r\n            else {\r\n                if (token[0] === 'word' && /\\w/.test(token[1])) {\r\n                    this.unknownWord([token]);\r\n                }\r\n                node.raws.between += token[1];\r\n            }\r\n        }\r\n        if (node.prop[0] === '_' || node.prop[0] === '*') {\r\n            node.raws.before += node.prop[0];\r\n            node.prop = node.prop.slice(1);\r\n        }\r\n        let firstSpaces = [];\r\n        let next;\r\n        while (tokens.length) {\r\n            next = tokens[0][0];\r\n            if (next !== 'space' && next !== 'comment')\r\n                break;\r\n            firstSpaces.push(tokens.shift());\r\n        }\r\n        this.precheckMissedSemicolon(tokens);\r\n        for (let i = tokens.length - 1; i >= 0; i--) {\r\n            token = tokens[i];\r\n            if (token[1].toLowerCase() === '!important') {\r\n                node.important = true;\r\n                let string = this.stringFrom(tokens, i);\r\n                string = this.spacesFromEnd(tokens) + string;\r\n                if (string !== ' !important')\r\n                    node.raws.important = string;\r\n                break;\r\n            }\r\n            else if (token[1].toLowerCase() === 'important') {\r\n                const cache = tokens.slice(0);\r\n                let str = '';\r\n                for (let j = i; j > 0; j--) {\r\n                    const type = cache[j][0];\r\n                    if (str.trim().startsWith('!') && type !== 'space') {\r\n                        break;\r\n                    }\r\n                    str = cache.pop()[1] + str;\r\n                }\r\n                if (str.trim().startsWith('!')) {\r\n                    node.important = true;\r\n                    node.raws.important = str;\r\n                    tokens = cache;\r\n                }\r\n            }\r\n            if (token[0] !== 'space' && token[0] !== 'comment') {\r\n                break;\r\n            }\r\n        }\r\n        const hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');\r\n        if (hasWord) {\r\n            node.raws.between += firstSpaces.map(i => i[1]).join('');\r\n            firstSpaces = [];\r\n        }\r\n        this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);\r\n        if (node.value.includes(':') && !customProperty) {\r\n            this.checkMissedSemicolon(tokens);\r\n        }\r\n    }\r\n    doubleColon(token) {\r\n        throw this.input.error('Double colon', { offset: token[2] }, { offset: token[2] + token[1].length });\r\n    }\r\n    emptyRule(token) {\r\n        const node = new Rule();\r\n        this.init(node, token[2]);\r\n        node.selector = '';\r\n        node.raws.between = '';\r\n        this.current = node;\r\n    }\r\n    end(token) {\r\n        if (this.current.nodes && this.current.nodes.length) {\r\n            this.current.raws.semicolon = this.semicolon;\r\n        }\r\n        this.semicolon = false;\r\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\r\n        this.spaces = '';\r\n        if (this.current.parent) {\r\n            this.current.source.end = this.getPosition(token[2]);\r\n            this.current.source.end.offset++;\r\n            this.current = this.current.parent;\r\n        }\r\n        else {\r\n            this.unexpectedClose(token);\r\n        }\r\n    }\r\n    endFile() {\r\n        if (this.current.parent)\r\n            this.unclosedBlock();\r\n        if (this.current.nodes && this.current.nodes.length) {\r\n            this.current.raws.semicolon = this.semicolon;\r\n        }\r\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\r\n        this.root.source.end = this.getPosition(this.tokenizer.position());\r\n    }\r\n    freeSemicolon(token) {\r\n        this.spaces += token[1];\r\n        if (this.current.nodes) {\r\n            const prev = this.current.nodes[this.current.nodes.length - 1];\r\n            if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\r\n                prev.raws.ownSemicolon = this.spaces;\r\n                this.spaces = '';\r\n            }\r\n        }\r\n    }\r\n    // Helpers\r\n    getPosition(offset) {\r\n        const pos = this.input.fromOffset(offset);\r\n        return {\r\n            column: pos.col,\r\n            line: pos.line,\r\n            offset\r\n        };\r\n    }\r\n    init(node, offset) {\r\n        this.current.push(node);\r\n        node.source = {\r\n            input: this.input,\r\n            start: this.getPosition(offset)\r\n        };\r\n        node.raws.before = this.spaces;\r\n        this.spaces = '';\r\n        if (node.type !== 'comment')\r\n            this.semicolon = false;\r\n    }\r\n    other(start) {\r\n        let end = false;\r\n        let type = null;\r\n        let colon = false;\r\n        let bracket = null;\r\n        const brackets = [];\r\n        const customProperty = start[1].startsWith('--');\r\n        const tokens = [];\r\n        let token = start;\r\n        while (token) {\r\n            type = token[0];\r\n            tokens.push(token);\r\n            if (type === '(' || type === '[') {\r\n                if (!bracket)\r\n                    bracket = token;\r\n                brackets.push(type === '(' ? ')' : ']');\r\n            }\r\n            else if (customProperty && colon && type === '{') {\r\n                if (!bracket)\r\n                    bracket = token;\r\n                brackets.push('}');\r\n            }\r\n            else if (brackets.length === 0) {\r\n                if (type === ';') {\r\n                    if (colon) {\r\n                        this.decl(tokens, customProperty);\r\n                        return;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                else if (type === '{') {\r\n                    this.rule(tokens);\r\n                    return;\r\n                }\r\n                else if (type === '}') {\r\n                    this.tokenizer.back(tokens.pop());\r\n                    end = true;\r\n                    break;\r\n                }\r\n                else if (type === ':') {\r\n                    colon = true;\r\n                }\r\n            }\r\n            else if (type === brackets[brackets.length - 1]) {\r\n                brackets.pop();\r\n                if (brackets.length === 0)\r\n                    bracket = null;\r\n            }\r\n            token = this.tokenizer.nextToken();\r\n        }\r\n        if (this.tokenizer.endOfFile())\r\n            end = true;\r\n        if (brackets.length > 0)\r\n            this.unclosedBracket(bracket);\r\n        if (end && colon) {\r\n            if (!customProperty) {\r\n                while (tokens.length) {\r\n                    token = tokens[tokens.length - 1][0];\r\n                    if (token !== 'space' && token !== 'comment')\r\n                        break;\r\n                    this.tokenizer.back(tokens.pop());\r\n                }\r\n            }\r\n            this.decl(tokens, customProperty);\r\n        }\r\n        else {\r\n            this.unknownWord(tokens);\r\n        }\r\n    }\r\n    parse() {\r\n        let token;\r\n        while (!this.tokenizer.endOfFile()) {\r\n            token = this.tokenizer.nextToken();\r\n            switch (token[0]) {\r\n                case 'space':\r\n                    this.spaces += token[1];\r\n                    break;\r\n                case ';':\r\n                    this.freeSemicolon(token);\r\n                    break;\r\n                case '}':\r\n                    this.end(token);\r\n                    break;\r\n                case 'comment':\r\n                    this.comment(token);\r\n                    break;\r\n                case 'at-word':\r\n                    this.atrule(token);\r\n                    break;\r\n                case '{':\r\n                    this.emptyRule(token);\r\n                    break;\r\n                default:\r\n                    this.other(token);\r\n                    break;\r\n            }\r\n        }\r\n        this.endFile();\r\n    }\r\n    precheckMissedSemicolon( /* tokens */) {\r\n        // Hook for Safe Parser\r\n    }\r\n    raw(node, prop, tokens, customProperty) {\r\n        let token, type;\r\n        const length = tokens.length;\r\n        let value = '';\r\n        let clean = true;\r\n        let next, prev;\r\n        for (let i = 0; i < length; i += 1) {\r\n            token = tokens[i];\r\n            type = token[0];\r\n            if (type === 'space' && i === length - 1 && !customProperty) {\r\n                clean = false;\r\n            }\r\n            else if (type === 'comment') {\r\n                prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';\r\n                next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';\r\n                if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\r\n                    if (value.slice(-1) === ',') {\r\n                        clean = false;\r\n                    }\r\n                    else {\r\n                        value += token[1];\r\n                    }\r\n                }\r\n                else {\r\n                    clean = false;\r\n                }\r\n            }\r\n            else {\r\n                value += token[1];\r\n            }\r\n        }\r\n        if (!clean) {\r\n            const raw = tokens.reduce((all, i) => all + i[1], '');\r\n            node.raws[prop] = { raw, value };\r\n        }\r\n        node[prop] = value;\r\n    }\r\n    rule(tokens) {\r\n        tokens.pop();\r\n        const node = new Rule();\r\n        this.init(node, tokens[0][2]);\r\n        node.raws.between = this.spacesAndCommentsFromEnd(tokens);\r\n        this.raw(node, 'selector', tokens);\r\n        this.current = node;\r\n    }\r\n    spacesAndCommentsFromEnd(tokens) {\r\n        let lastTokenType;\r\n        let spaces = '';\r\n        while (tokens.length) {\r\n            lastTokenType = tokens[tokens.length - 1][0];\r\n            if (lastTokenType !== 'space' && lastTokenType !== 'comment')\r\n                break;\r\n            spaces = tokens.pop()[1] + spaces;\r\n        }\r\n        return spaces;\r\n    }\r\n    // Errors\r\n    spacesAndCommentsFromStart(tokens) {\r\n        let next;\r\n        let spaces = '';\r\n        while (tokens.length) {\r\n            next = tokens[0][0];\r\n            if (next !== 'space' && next !== 'comment')\r\n                break;\r\n            spaces += tokens.shift()[1];\r\n        }\r\n        return spaces;\r\n    }\r\n    spacesFromEnd(tokens) {\r\n        let lastTokenType;\r\n        let spaces = '';\r\n        while (tokens.length) {\r\n            lastTokenType = tokens[tokens.length - 1][0];\r\n            if (lastTokenType !== 'space')\r\n                break;\r\n            spaces = tokens.pop()[1] + spaces;\r\n        }\r\n        return spaces;\r\n    }\r\n    stringFrom(tokens, from) {\r\n        let result = '';\r\n        for (let i = from; i < tokens.length; i++) {\r\n            result += tokens[i][1];\r\n        }\r\n        tokens.splice(from, tokens.length - from);\r\n        return result;\r\n    }\r\n    unclosedBlock() {\r\n        const pos = this.current.source.start;\r\n        throw this.input.error('Unclosed block', pos.line, pos.column);\r\n    }\r\n    unclosedBracket(bracket) {\r\n        throw this.input.error('Unclosed bracket', { offset: bracket[2] }, { offset: bracket[2] + 1 });\r\n    }\r\n    unexpectedClose(token) {\r\n        throw this.input.error('Unexpected }', { offset: token[2] }, { offset: token[2] + 1 });\r\n    }\r\n    unknownWord(tokens) {\r\n        throw this.input.error('Unknown word', { offset: tokens[0][2] }, { offset: tokens[0][2] + tokens[0][1].length });\r\n    }\r\n    unnamedAtrule(node, token) {\r\n        throw this.input.error('At-rule without name', { offset: token[2] }, { offset: token[2] + token[1].length });\r\n    }\r\n}\r\n", "import { Container } from \"./container\";\r\nimport { Input } from './input';\r\nimport { Parser } from './parser';\r\nexport function parse(css, opts) {\r\n    const input = new Input(css, opts);\r\n    const parser = new Parser(input);\r\n    try {\r\n        parser.parse();\r\n    }\r\n    catch (e) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (e.name === 'CssSyntaxError' && opts && opts.from) {\r\n                if (/\\.scss$/i.test(opts.from)) {\r\n                    e.message +=\r\n                        '\\nYou tried to parse SCSS with ' +\r\n                            'the standard CSS parser; ' +\r\n                            'try again with the postcss-scss parser';\r\n                }\r\n                else if (/\\.sass/i.test(opts.from)) {\r\n                    e.message +=\r\n                        '\\nYou tried to parse Sass with ' +\r\n                            'the standard CSS parser; ' +\r\n                            'try again with the postcss-sass parser';\r\n                }\r\n                else if (/\\.less$/i.test(opts.from)) {\r\n                    e.message +=\r\n                        '\\nYou tried to parse Less with ' +\r\n                            'the standard CSS parser; ' +\r\n                            'try again with the postcss-less parser';\r\n                }\r\n            }\r\n        }\r\n        throw e;\r\n    }\r\n    return parser.root;\r\n}\r\nContainer.registerParse(parse);\r\n", "import { Container } from \"./container\";\r\nlet LazyResult, Processor;\r\nexport class Document extends Container {\r\n    constructor(defaults) {\r\n        // type needs to be passed to super, otherwise child roots won't be normalized correctly\r\n        super({ type: 'document', ...defaults });\r\n        if (!this.nodes) {\r\n            this.nodes = [];\r\n        }\r\n    }\r\n    toResult(opts = {}) {\r\n        const lazy = new LazyResult(new Processor(), this, opts);\r\n        return lazy.stringify();\r\n    }\r\n}\r\nDocument.registerLazyResult = dependant => {\r\n    LazyResult = dependant;\r\n};\r\nDocument.registerProcessor = dependant => {\r\n    Processor = dependant;\r\n};\r\n", "import { AtRule } from './at-rule';\r\nimport { Comment } from './comment';\r\nimport { Declaration } from './declaration';\r\nimport { Root } from './root';\r\nimport { Rule } from './rule';\r\nimport { Input } from './input';\r\nexport function fromJSON(json, inputs) {\r\n    if (Array.isArray(json))\r\n        return json.map(n => fromJSON(n));\r\n    const { inputs: ownInputs, ...defaults } = json;\r\n    if (ownInputs) {\r\n        inputs = [];\r\n        for (const input of ownInputs) {\r\n            const inputHydrated = { ...input, __proto__: Input.prototype };\r\n            if (inputHydrated.map) {\r\n                inputHydrated.map = {\r\n                    ...inputHydrated.map,\r\n                };\r\n            }\r\n            inputs.push(inputHydrated);\r\n        }\r\n    }\r\n    if (defaults.nodes) {\r\n        defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));\r\n    }\r\n    if (defaults.source) {\r\n        const { inputId, ...source } = defaults.source;\r\n        defaults.source = source;\r\n        if (inputId != null) {\r\n            defaults.source.input = inputs[inputId];\r\n        }\r\n    }\r\n    if (defaults.type === 'root') {\r\n        return new Root(defaults);\r\n    }\r\n    else if (defaults.type === 'decl') {\r\n        return new Declaration(defaults);\r\n    }\r\n    else if (defaults.type === 'rule') {\r\n        return new Rule(defaults);\r\n    }\r\n    else if (defaults.type === 'comment') {\r\n        return new Comment(defaults);\r\n    }\r\n    else if (defaults.type === 'atrule') {\r\n        return new AtRule(defaults);\r\n    }\r\n    else {\r\n        throw new Error('Unknown node type: ' + json.type);\r\n    }\r\n}\r\n", "import { Input } from './input';\r\nexport class MapGenerator {\r\n    constructor(stringify, root, opts, cssString) {\r\n        this.stringify = stringify;\r\n        this.mapOpts = opts.map || {};\r\n        this.root = root;\r\n        this.opts = opts;\r\n        this.css = cssString;\r\n        this.originalCSS = cssString;\r\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\r\n        this.memoizedFileURLs = new Map();\r\n        this.memoizedPaths = new Map();\r\n        this.memoizedURLs = new Map();\r\n    }\r\n    addAnnotation() {\r\n        let content;\r\n        if (this.isInline()) {\r\n            content =\r\n                'data:application/json;base64,' + this.toBase64(this.map.toString());\r\n        }\r\n        else if (typeof this.mapOpts.annotation === 'string') {\r\n            content = this.mapOpts.annotation;\r\n        }\r\n        else if (typeof this.mapOpts.annotation === 'function') {\r\n            content = this.mapOpts.annotation(this.opts.to, this.root);\r\n        }\r\n        else {\r\n            content = this.outputFile() + '.map';\r\n        }\r\n        let eol = '\\n';\r\n        if (this.css.includes('\\r\\n'))\r\n            eol = '\\r\\n';\r\n        this.css += eol + '/*# sourceMappingURL=' + content + ' */';\r\n    }\r\n    applyPrevMaps() {\r\n    }\r\n    clearAnnotation() {\r\n        if (this.mapOpts.annotation === false)\r\n            return;\r\n        if (this.root) {\r\n            let node;\r\n            for (let i = this.root.nodes.length - 1; i >= 0; i--) {\r\n                node = this.root.nodes[i];\r\n                if (node.type !== 'comment')\r\n                    continue;\r\n                if (node.text.startsWith('# sourceMappingURL=')) {\r\n                    this.root.removeChild(i);\r\n                }\r\n            }\r\n        }\r\n        else if (this.css) {\r\n            this.css = this.css.replace(/\\n*\\/\\*#[\\S\\s]*?\\*\\/$/gm, '');\r\n        }\r\n    }\r\n    generate() {\r\n        this.clearAnnotation();\r\n        let result = '';\r\n        this.stringify(this.root, i => {\r\n            result += i;\r\n        });\r\n        return [result];\r\n    }\r\n    generateMap() {\r\n        if (this.root) {\r\n            this.generateString();\r\n        }\r\n        else if (this.previous().length === 1) {\r\n            const prev = this.previous()[0].consumer();\r\n            prev.file = this.outputFile();\r\n            this.map = SourceMapGenerator.fromSourceMap(prev, {\r\n                ignoreInvalidMapping: true\r\n            });\r\n        }\r\n        else {\r\n            this.map = new SourceMapGenerator({\r\n                file: this.outputFile(),\r\n                ignoreInvalidMapping: true\r\n            });\r\n            this.map.addMapping({\r\n                generated: { column: 0, line: 1 },\r\n                original: { column: 0, line: 1 },\r\n                source: this.opts.from\r\n                    ? this.toUrl(this.path(this.opts.from))\r\n                    : '<no source>'\r\n            });\r\n        }\r\n        if (this.isSourcesContent())\r\n            this.setSourcesContent();\r\n        if (this.root && this.previous().length > 0)\r\n            this.applyPrevMaps();\r\n        if (this.isAnnotation())\r\n            this.addAnnotation();\r\n        if (this.isInline()) {\r\n            return [this.css];\r\n        }\r\n        else {\r\n            return [this.css, this.map];\r\n        }\r\n    }\r\n    generateString() {\r\n        this.css = '';\r\n        this.map = new SourceMapGenerator({\r\n            file: this.outputFile(),\r\n            ignoreInvalidMapping: true\r\n        });\r\n        let line = 1;\r\n        let column = 1;\r\n        const noSource = '<no source>';\r\n        const mapping = {\r\n            generated: { column: 0, line: 0 },\r\n            original: { column: 0, line: 0 },\r\n            source: ''\r\n        };\r\n        let last, lines;\r\n        this.stringify(this.root, (str, node, type) => {\r\n            this.css += str;\r\n            if (node && type !== 'end') {\r\n                mapping.generated.line = line;\r\n                mapping.generated.column = column - 1;\r\n                if (node.source && node.source.start) {\r\n                    mapping.source = this.sourcePath(node);\r\n                    mapping.original.line = node.source.start.line;\r\n                    mapping.original.column = node.source.start.column - 1;\r\n                    this.map.addMapping(mapping);\r\n                }\r\n                else {\r\n                    mapping.source = noSource;\r\n                    mapping.original.line = 1;\r\n                    mapping.original.column = 0;\r\n                    this.map.addMapping(mapping);\r\n                }\r\n            }\r\n            lines = str.match(/\\n/g);\r\n            if (lines) {\r\n                line += lines.length;\r\n                last = str.lastIndexOf('\\n');\r\n                column = str.length - last;\r\n            }\r\n            else {\r\n                column += str.length;\r\n            }\r\n            if (node && type !== 'start') {\r\n                const p = node.parent || { raws: {} };\r\n                const childless = node.type === 'decl' || (node.type === 'atrule' && !node.nodes);\r\n                if (!childless || node !== p.last || p.raws.semicolon) {\r\n                    if (node.source && node.source.end) {\r\n                        mapping.source = this.sourcePath(node);\r\n                        mapping.original.line = node.source.end.line;\r\n                        mapping.original.column = node.source.end.column - 1;\r\n                        mapping.generated.line = line;\r\n                        mapping.generated.column = column - 2;\r\n                        this.map.addMapping(mapping);\r\n                    }\r\n                    else {\r\n                        mapping.source = noSource;\r\n                        mapping.original.line = 1;\r\n                        mapping.original.column = 0;\r\n                        mapping.generated.line = line;\r\n                        mapping.generated.column = column - 1;\r\n                        this.map.addMapping(mapping);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    isAnnotation() {\r\n        if (this.isInline()) {\r\n            return true;\r\n        }\r\n        if (typeof this.mapOpts.annotation !== 'undefined') {\r\n            return this.mapOpts.annotation;\r\n        }\r\n        if (this.previous().length) {\r\n            return this.previous().some(i => i.annotation);\r\n        }\r\n        return true;\r\n    }\r\n    isInline() {\r\n        if (typeof this.mapOpts.inline !== 'undefined') {\r\n            return this.mapOpts.inline;\r\n        }\r\n        const annotation = this.mapOpts.annotation;\r\n        if (typeof annotation !== 'undefined' && annotation !== true) {\r\n            return false;\r\n        }\r\n        if (this.previous().length) {\r\n            return this.previous().some(i => i.inline);\r\n        }\r\n        return true;\r\n    }\r\n    isMap() {\r\n        if (typeof this.opts.map !== 'undefined') {\r\n            return !!this.opts.map;\r\n        }\r\n        return this.previous().length > 0;\r\n    }\r\n    isSourcesContent() {\r\n        if (typeof this.mapOpts.sourcesContent !== 'undefined') {\r\n            return this.mapOpts.sourcesContent;\r\n        }\r\n        if (this.previous().length) {\r\n            return this.previous().some(i => i.withContent());\r\n        }\r\n        return true;\r\n    }\r\n    outputFile() {\r\n        if (this.opts.to) {\r\n            return this.path(this.opts.to);\r\n        }\r\n        else if (this.opts.from) {\r\n            return this.path(this.opts.from);\r\n        }\r\n        else {\r\n            return 'to.css';\r\n        }\r\n    }\r\n    path(file) {\r\n        return file;\r\n    }\r\n    previous() {\r\n        if (!this.previousMaps) {\r\n            this.previousMaps = [];\r\n            if (this.root) {\r\n                this.root.walk(node => {\r\n                    if (node.source && node.source.input.map) {\r\n                        const map = node.source.input.map;\r\n                        if (!this.previousMaps.includes(map)) {\r\n                            this.previousMaps.push(map);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                const input = new Input(this.originalCSS, this.opts);\r\n                if (input.map)\r\n                    this.previousMaps.push(input.map);\r\n            }\r\n        }\r\n        return this.previousMaps;\r\n    }\r\n    setSourcesContent() {\r\n        throw new Error(`setSourcesContent isnt implemented`);\r\n    }\r\n    sourcePath(node) {\r\n        if (this.mapOpts.from) {\r\n            return this.toUrl(this.mapOpts.from);\r\n        }\r\n        else if (this.usesFileUrls) {\r\n            return this.toFileUrl(node.source.input.from);\r\n        }\r\n        else {\r\n            return this.toUrl(this.path(node.source.input.from));\r\n        }\r\n    }\r\n    toBase64(str) {\r\n        if (Buffer) {\r\n            return Buffer.from(str).toString('base64');\r\n        }\r\n        else {\r\n            return window.btoa(unescape(encodeURIComponent(str)));\r\n        }\r\n    }\r\n    toFileUrl(path) {\r\n        const cached = this.memoizedFileURLs.get(path);\r\n        if (cached)\r\n            return cached;\r\n        throw new Error('`map.absolute` option is not available in this PostCSS build');\r\n    }\r\n    toUrl(path) {\r\n        const cached = this.memoizedURLs.get(path);\r\n        if (cached)\r\n            return cached;\r\n        path = path.replace(/\\\\/g, '/');\r\n        const url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\r\n        this.memoizedURLs.set(path, url);\r\n        return url;\r\n    }\r\n}\r\n", "const printed = {};\r\nexport function warnOnce(message) {\r\n    if (printed[message])\r\n        return;\r\n    printed[message] = true;\r\n    if (typeof console !== 'undefined' && console.warn) {\r\n        console.warn(message);\r\n    }\r\n}\r\n", "export class Warning {\r\n    constructor(text, opts = {}) {\r\n        this.type = 'warning';\r\n        this.text = text;\r\n        if (opts.node && opts.node.source) {\r\n            const range = opts.node.rangeBy(opts);\r\n            this.line = range.start.line;\r\n            this.column = range.start.column;\r\n            this.endLine = range.end.line;\r\n            this.endColumn = range.end.column;\r\n        }\r\n        for (const opt in opts)\r\n            this[opt] = opts[opt];\r\n    }\r\n    toString() {\r\n        if (this.node) {\r\n            return this.node.error(this.text, {\r\n                index: this.index,\r\n                plugin: this.plugin,\r\n                word: this.word\r\n            }).message;\r\n        }\r\n        if (this.plugin) {\r\n            return this.plugin + ': ' + this.text;\r\n        }\r\n        return this.text;\r\n    }\r\n}\r\n", "import { Warning } from './warning';\r\nexport class Result {\r\n    constructor(processor, root, opts) {\r\n        this.processor = processor;\r\n        this.messages = [];\r\n        this.root = root;\r\n        this.opts = opts;\r\n        this.css = undefined;\r\n        this.map = undefined;\r\n    }\r\n    toString() {\r\n        return this.css;\r\n    }\r\n    warn(text, opts = {}) {\r\n        if (!opts.plugin) {\r\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\r\n                opts.plugin = this.lastPlugin.postcssPlugin;\r\n            }\r\n        }\r\n        const warning = new Warning(text, opts);\r\n        this.messages.push(warning);\r\n        return warning;\r\n    }\r\n    warnings() {\r\n        return this.messages.filter(i => i.type === 'warning');\r\n    }\r\n    get content() {\r\n        return this.css;\r\n    }\r\n}\r\n", "import { MapGenerator } from './map-generator';\r\nimport { warnOnce } from './warn-once';\r\nimport { parse } from './parse';\r\nimport { Result } from './result';\r\nimport { stringify } from \"./stringify\";\r\nexport class NoWorkResult {\r\n    constructor(processor, css, opts) {\r\n        css = css.toString();\r\n        this.stringified = false;\r\n        this._processor = processor;\r\n        this._css = css;\r\n        this._opts = opts;\r\n        this._map = undefined;\r\n        let root;\r\n        const str = stringify;\r\n        this.result = new Result(this._processor, root, this._opts);\r\n        this.result.css = css;\r\n        const self = this;\r\n        Object.defineProperty(this.result, 'root', {\r\n            get() {\r\n                return self.root;\r\n            }\r\n        });\r\n        const map = new MapGenerator(str, root, this._opts, css);\r\n        if (map.isMap()) {\r\n            const [generatedCSS, generatedMap] = map.generate();\r\n            if (generatedCSS) {\r\n                this.result.css = generatedCSS;\r\n            }\r\n            if (generatedMap) {\r\n                this.result.map = generatedMap;\r\n            }\r\n        }\r\n        else {\r\n            map.clearAnnotation();\r\n            this.result.css = map.css;\r\n        }\r\n    }\r\n    async() {\r\n        if (this.error)\r\n            return Promise.reject(this.error);\r\n        return Promise.resolve(this.result);\r\n    }\r\n    catch(onRejected) {\r\n        return this.async().catch(onRejected);\r\n    }\r\n    finally(onFinally) {\r\n        return this.async().then(onFinally, onFinally);\r\n    }\r\n    sync() {\r\n        if (this.error)\r\n            throw this.error;\r\n        return this.result;\r\n    }\r\n    then(onFulfilled, onRejected) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!('from' in this._opts)) {\r\n                warnOnce('Without `from` option PostCSS could generate wrong source map ' +\r\n                    'and will not find Browserslist config. Set it to CSS file path ' +\r\n                    'or to `undefined` to prevent this warning.');\r\n            }\r\n        }\r\n        return this.async().then(onFulfilled, onRejected);\r\n    }\r\n    toString() {\r\n        return this._css;\r\n    }\r\n    warnings() {\r\n        return [];\r\n    }\r\n    get content() {\r\n        return this.result.css;\r\n    }\r\n    get css() {\r\n        return this.result.css;\r\n    }\r\n    get map() {\r\n        return this.result.map;\r\n    }\r\n    get messages() {\r\n        return [];\r\n    }\r\n    get opts() {\r\n        return this.result.opts;\r\n    }\r\n    get processor() {\r\n        return this.result.processor;\r\n    }\r\n    get root() {\r\n        if (this._root) {\r\n            return this._root;\r\n        }\r\n        let root;\r\n        const parser = parse;\r\n        try {\r\n            root = parser(this._css, this._opts);\r\n        }\r\n        catch (error) {\r\n            this.error = error;\r\n        }\r\n        if (this.error) {\r\n            throw this.error;\r\n        }\r\n        else {\r\n            this._root = root;\r\n            return root;\r\n        }\r\n    }\r\n    get [Symbol.toStringTag]() {\r\n        return 'NoWorkResult';\r\n    }\r\n}\r\n", "import { Container } from \"./container.js\";\r\nimport { Document } from \"./document.js\";\r\nimport { MapGenerator } from \"./map-generator.js\";\r\nimport { parse } from \"./parse.js\";\r\nimport { Result } from \"./result.js\";\r\nimport { stringify } from \"./stringify.js\";\r\nimport { isClean, my } from \"./symbols.js\";\r\nimport { warnOnce } from \"./warn-once.js\";\r\nimport { Root } from './root';\r\nconst TYPE_TO_CLASS_NAME = {\r\n    atrule: 'AtRule',\r\n    comment: 'Comment',\r\n    decl: 'Declaration',\r\n    document: 'Document',\r\n    root: 'Root',\r\n    rule: 'Rule'\r\n};\r\nconst PLUGIN_PROPS = {\r\n    AtRule: true,\r\n    AtRuleExit: true,\r\n    Comment: true,\r\n    CommentExit: true,\r\n    Declaration: true,\r\n    DeclarationExit: true,\r\n    Document: true,\r\n    DocumentExit: true,\r\n    Once: true,\r\n    OnceExit: true,\r\n    postcssPlugin: true,\r\n    prepare: true,\r\n    Root: true,\r\n    RootExit: true,\r\n    Rule: true,\r\n    RuleExit: true\r\n};\r\nconst NOT_VISITORS = {\r\n    Once: true,\r\n    postcssPlugin: true,\r\n    prepare: true\r\n};\r\nconst CHILDREN = 0;\r\nfunction isPromise(obj) {\r\n    return typeof obj === 'object' && typeof obj.then === 'function';\r\n}\r\nfunction getEvents(node) {\r\n    let key = false;\r\n    const type = TYPE_TO_CLASS_NAME[node.type];\r\n    if (node.type === 'decl') {\r\n        key = node.prop.toLowerCase();\r\n    }\r\n    else if (node.type === 'atrule') {\r\n        key = node.name.toLowerCase();\r\n    }\r\n    if (key && node.append) {\r\n        return [\r\n            type,\r\n            type + '-' + key,\r\n            CHILDREN,\r\n            type + 'Exit',\r\n            type + 'Exit-' + key\r\n        ];\r\n    }\r\n    else if (key) {\r\n        return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];\r\n    }\r\n    else if (node.append) {\r\n        return [type, CHILDREN, type + 'Exit'];\r\n    }\r\n    else {\r\n        return [type, type + 'Exit'];\r\n    }\r\n}\r\nfunction toStack(node) {\r\n    let events;\r\n    if (node.type === 'document') {\r\n        events = ['Document', CHILDREN, 'DocumentExit'];\r\n    }\r\n    else if (node.type === 'root') {\r\n        events = ['Root', CHILDREN, 'RootExit'];\r\n    }\r\n    else {\r\n        events = getEvents(node);\r\n    }\r\n    return {\r\n        eventIndex: 0,\r\n        events,\r\n        iterator: 0,\r\n        node,\r\n        visitorIndex: 0,\r\n        visitors: []\r\n    };\r\n}\r\nfunction cleanMarks(node) {\r\n    node[isClean] = false;\r\n    if (node.nodes)\r\n        node.nodes.forEach(i => cleanMarks(i));\r\n    return node;\r\n}\r\nlet postcss = {};\r\nexport class LazyResult {\r\n    constructor(processor, css, opts) {\r\n        this.stringified = false;\r\n        this.processed = false;\r\n        let root;\r\n        if (typeof css === 'object' &&\r\n            css !== null &&\r\n            (css.type === 'root' || css.type === 'document')) {\r\n            root = cleanMarks(css);\r\n        }\r\n        else if (css instanceof LazyResult || css instanceof Result) {\r\n            root = cleanMarks(css.root);\r\n            if (css.map) {\r\n                if (typeof opts.map === 'undefined')\r\n                    opts.map = {};\r\n                if (!opts.map.inline)\r\n                    opts.map.inline = false;\r\n                opts.map.prev = css.map;\r\n            }\r\n        }\r\n        else {\r\n            let parser = parse;\r\n            if (opts.syntax)\r\n                parser = opts.syntax.parse;\r\n            if (opts.parser)\r\n                parser = opts.parser;\r\n            if (parser.parse)\r\n                parser = parser.parse;\r\n            try {\r\n                root = parser(css, opts);\r\n            }\r\n            catch (error) {\r\n                this.processed = true;\r\n                this.error = error;\r\n            }\r\n            if (root && !root[my]) {\r\n                /* c8 ignore next 2 */\r\n                Container.rebuild(root);\r\n            }\r\n        }\r\n        this.result = new Result(processor, root, opts);\r\n        this.helpers = { ...postcss, postcss, result: this.result };\r\n        this.plugins = this.processor.plugins.map(plugin => {\r\n            if (typeof plugin === 'object' && plugin.prepare) {\r\n                return { ...plugin, ...plugin.prepare(this.result) };\r\n            }\r\n            else {\r\n                return plugin;\r\n            }\r\n        });\r\n    }\r\n    async() {\r\n        if (this.error)\r\n            return Promise.reject(this.error);\r\n        if (this.processed)\r\n            return Promise.resolve(this.result);\r\n        if (!this.processing) {\r\n            this.processing = this.runAsync();\r\n        }\r\n        return this.processing;\r\n    }\r\n    catch(onRejected) {\r\n        return this.async().catch(onRejected);\r\n    }\r\n    finally(onFinally) {\r\n        return this.async().then(onFinally, onFinally);\r\n    }\r\n    getAsyncError() {\r\n        throw new Error('Use process(css).then(cb) to work with async plugins');\r\n    }\r\n    handleError(error, node) {\r\n        const plugin = this.result.lastPlugin;\r\n        try {\r\n            if (node)\r\n                node.addToError(error);\r\n            this.error = error;\r\n            if (error.name === 'CssSyntaxError' && !error.plugin) {\r\n                error.plugin = plugin.postcssPlugin;\r\n                error.setMessage();\r\n            }\r\n            else if (plugin.postcssVersion) {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    const pluginName = plugin.postcssPlugin;\r\n                    const pluginVer = plugin.postcssVersion;\r\n                    const runtimeVer = this.result.processor.version;\r\n                    const a = pluginVer.split('.');\r\n                    const b = runtimeVer.split('.');\r\n                    if (a[0] !== b[0] || Number.parseInt(a[1]) > Number.parseInt(b[1])) {\r\n                        // eslint-disable-next-line no-console\r\n                        console.error('Unknown error from PostCSS plugin. Your current PostCSS ' +\r\n                            'version is ' +\r\n                            runtimeVer +\r\n                            ', but ' +\r\n                            pluginName +\r\n                            ' uses ' +\r\n                            pluginVer +\r\n                            '. Perhaps this is the source of the error below.');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            /* c8 ignore next 3 */\r\n            // eslint-disable-next-line no-console\r\n            if (console && console.error)\r\n                console.error(err);\r\n        }\r\n        return error;\r\n    }\r\n    prepareVisitors() {\r\n        this.listeners = {};\r\n        const add = (plugin, type, cb) => {\r\n            if (!this.listeners[type])\r\n                this.listeners[type] = [];\r\n            this.listeners[type].push([plugin, cb]);\r\n        };\r\n        for (const plugin of this.plugins) {\r\n            if (typeof plugin === 'object') {\r\n                for (const event in plugin) {\r\n                    if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\r\n                        throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. ` +\r\n                            `Try to update PostCSS (${this.processor.version} now).`);\r\n                    }\r\n                    if (!NOT_VISITORS[event]) {\r\n                        if (typeof plugin[event] === 'object') {\r\n                            for (const filter in plugin[event]) {\r\n                                if (filter === '*') {\r\n                                    add(plugin, event, plugin[event][filter]);\r\n                                }\r\n                                else {\r\n                                    add(plugin, event + '-' + filter.toLowerCase(), plugin[event][filter]);\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (typeof plugin[event] === 'function') {\r\n                            add(plugin, event, plugin[event]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.hasListener = Object.keys(this.listeners).length > 0;\r\n    }\r\n    async runAsync() {\r\n        this.plugin = 0;\r\n        for (let i = 0; i < this.plugins.length; i++) {\r\n            const plugin = this.plugins[i];\r\n            const promise = this.runOnRoot(plugin);\r\n            if (isPromise(promise)) {\r\n                try {\r\n                    await promise;\r\n                }\r\n                catch (error) {\r\n                    throw this.handleError(error);\r\n                }\r\n            }\r\n        }\r\n        this.prepareVisitors();\r\n        if (this.hasListener) {\r\n            const root = this.result.root;\r\n            while (!root[isClean]) {\r\n                root[isClean] = true;\r\n                const stack = [toStack(root)];\r\n                while (stack.length > 0) {\r\n                    const promise = this.visitTick(stack);\r\n                    if (isPromise(promise)) {\r\n                        try {\r\n                            await promise;\r\n                        }\r\n                        catch (e) {\r\n                            const node = stack[stack.length - 1].node;\r\n                            throw this.handleError(e, node);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (this.listeners.OnceExit) {\r\n                for (const [plugin, visitor] of this.listeners.OnceExit) {\r\n                    this.result.lastPlugin = plugin;\r\n                    try {\r\n                        if (root.type === 'document') {\r\n                            const roots = root.nodes.map(subRoot => visitor(subRoot, this.helpers));\r\n                            await Promise.all(roots);\r\n                        }\r\n                        else {\r\n                            await visitor(root, this.helpers);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        throw this.handleError(e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.processed = true;\r\n        return this.stringify();\r\n    }\r\n    runOnRoot(plugin) {\r\n        this.result.lastPlugin = plugin;\r\n        try {\r\n            if (typeof plugin === 'object' && plugin.Once) {\r\n                if (this.result.root.type === 'document') {\r\n                    const roots = this.result.root.nodes.map(root => plugin.Once(root, this.helpers));\r\n                    if (isPromise(roots[0])) {\r\n                        return Promise.all(roots);\r\n                    }\r\n                    return roots;\r\n                }\r\n                return plugin.Once(this.result.root, this.helpers);\r\n            }\r\n            else if (typeof plugin === 'function') {\r\n                return plugin(this.result.root, this.result);\r\n            }\r\n        }\r\n        catch (error) {\r\n            throw this.handleError(error);\r\n        }\r\n    }\r\n    stringify() {\r\n        if (this.error)\r\n            throw this.error;\r\n        if (this.stringified)\r\n            return this.result;\r\n        this.stringified = true;\r\n        this.sync();\r\n        const opts = this.result.opts;\r\n        let str = stringify;\r\n        if (opts.syntax)\r\n            str = opts.syntax.stringify;\r\n        if (opts.stringifier)\r\n            str = opts.stringifier;\r\n        if (str.stringify)\r\n            str = str.stringify;\r\n        const map = new MapGenerator(str, this.result.root, this.result.opts);\r\n        const data = map.generate();\r\n        this.result.css = data[0];\r\n        this.result.map = data[1];\r\n        return this.result;\r\n    }\r\n    sync() {\r\n        if (this.error)\r\n            throw this.error;\r\n        if (this.processed)\r\n            return this.result;\r\n        this.processed = true;\r\n        if (this.processing) {\r\n            throw this.getAsyncError();\r\n        }\r\n        for (const plugin of this.plugins) {\r\n            const promise = this.runOnRoot(plugin);\r\n            if (isPromise(promise)) {\r\n                throw this.getAsyncError();\r\n            }\r\n        }\r\n        this.prepareVisitors();\r\n        if (this.hasListener) {\r\n            const root = this.result.root;\r\n            while (!root[isClean]) {\r\n                root[isClean] = true;\r\n                this.walkSync(root);\r\n            }\r\n            if (this.listeners.OnceExit) {\r\n                if (root.type === 'document') {\r\n                    for (const subRoot of root.nodes) {\r\n                        this.visitSync(this.listeners.OnceExit, subRoot);\r\n                    }\r\n                }\r\n                else {\r\n                    this.visitSync(this.listeners.OnceExit, root);\r\n                }\r\n            }\r\n        }\r\n        return this.result;\r\n    }\r\n    then(onFulfilled, onRejected) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!('from' in this.opts)) {\r\n                warnOnce('Without `from` option PostCSS could generate wrong source map ' +\r\n                    'and will not find Browserslist config. Set it to CSS file path ' +\r\n                    'or to `undefined` to prevent this warning.');\r\n            }\r\n        }\r\n        return this.async().then(onFulfilled, onRejected);\r\n    }\r\n    toString() {\r\n        return this.css;\r\n    }\r\n    visitSync(visitors, node) {\r\n        for (const [plugin, visitor] of visitors) {\r\n            this.result.lastPlugin = plugin;\r\n            let promise;\r\n            try {\r\n                promise = visitor(node, this.helpers);\r\n            }\r\n            catch (e) {\r\n                throw this.handleError(e, node.proxyOf);\r\n            }\r\n            if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\r\n                return true;\r\n            }\r\n            if (isPromise(promise)) {\r\n                throw this.getAsyncError();\r\n            }\r\n        }\r\n    }\r\n    visitTick(stack) {\r\n        const visit = stack[stack.length - 1];\r\n        const { node, visitors } = visit;\r\n        if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\r\n            stack.pop();\r\n            return;\r\n        }\r\n        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\r\n            const [plugin, visitor] = visitors[visit.visitorIndex];\r\n            visit.visitorIndex += 1;\r\n            if (visit.visitorIndex === visitors.length) {\r\n                visit.visitors = [];\r\n                visit.visitorIndex = 0;\r\n            }\r\n            this.result.lastPlugin = plugin;\r\n            try {\r\n                return visitor(node.toProxy(), this.helpers);\r\n            }\r\n            catch (e) {\r\n                throw this.handleError(e, node);\r\n            }\r\n        }\r\n        if (visit.iterator !== 0) {\r\n            const iterator = visit.iterator;\r\n            let child;\r\n            while ((child = node.nodes[node.indexes[iterator]])) {\r\n                node.indexes[iterator] += 1;\r\n                if (!child[isClean]) {\r\n                    child[isClean] = true;\r\n                    stack.push(toStack(child));\r\n                    return;\r\n                }\r\n            }\r\n            visit.iterator = 0;\r\n            delete node.indexes[iterator];\r\n        }\r\n        const events = visit.events;\r\n        while (visit.eventIndex < events.length) {\r\n            const event = events[visit.eventIndex];\r\n            visit.eventIndex += 1;\r\n            if (event === CHILDREN) {\r\n                if (node.nodes && node.nodes.length) {\r\n                    node[isClean] = true;\r\n                    visit.iterator = node.getIterator();\r\n                }\r\n                return;\r\n            }\r\n            else if (this.listeners[event]) {\r\n                visit.visitors = this.listeners[event];\r\n                return;\r\n            }\r\n        }\r\n        stack.pop();\r\n    }\r\n    walkSync(node) {\r\n        node[isClean] = true;\r\n        const events = getEvents(node);\r\n        for (const event of events) {\r\n            if (event === CHILDREN) {\r\n                if (node.nodes) {\r\n                    node.each(child => {\r\n                        if (!child[isClean])\r\n                            this.walkSync(child);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                const visitors = this.listeners[event];\r\n                if (visitors) {\r\n                    if (this.visitSync(visitors, node.toProxy()))\r\n                        return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    warnings() {\r\n        return this.sync().warnings();\r\n    }\r\n    get content() {\r\n        return this.stringify().content;\r\n    }\r\n    get css() {\r\n        return this.stringify().css;\r\n    }\r\n    get map() {\r\n        return this.stringify().map;\r\n    }\r\n    get messages() {\r\n        return this.sync().messages;\r\n    }\r\n    get opts() {\r\n        return this.result.opts;\r\n    }\r\n    get processor() {\r\n        return this.result.processor;\r\n    }\r\n    get root() {\r\n        return this.sync().root;\r\n    }\r\n    get [Symbol.toStringTag]() {\r\n        return 'LazyResult';\r\n    }\r\n}\r\nLazyResult.registerPostcss = dependant => {\r\n    postcss = dependant;\r\n};\r\nRoot.registerLazyResult(LazyResult);\r\nDocument.registerLazyResult(LazyResult);\r\n", "import { Document } from \"./document\";\r\nimport { Root } from './root';\r\nimport { NoWorkResult } from './no-work-result';\r\nimport { LazyResult } from './lazy-result';\r\nexport class Processor {\r\n    constructor(plugins = []) {\r\n        this.version = '8.4.49';\r\n        this.plugins = this.normalize(plugins);\r\n    }\r\n    normalize(plugins) {\r\n        let normalized = [];\r\n        for (let i of plugins) {\r\n            if (i.postcss === true) {\r\n                i = i();\r\n            }\r\n            else if (i.postcss) {\r\n                i = i.postcss;\r\n            }\r\n            if (typeof i === 'object' && Array.isArray(i.plugins)) {\r\n                normalized = normalized.concat(i.plugins);\r\n            }\r\n            else if (typeof i === 'object' && i.postcssPlugin) {\r\n                normalized.push(i);\r\n            }\r\n            else if (typeof i === 'function') {\r\n                normalized.push(i);\r\n            }\r\n            else if (typeof i === 'object' && (i.parse || i.stringify)) {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' +\r\n                        'one of the syntax/parser/stringifier options as outlined ' +\r\n                        'in your PostCSS runner documentation.');\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(i + ' is not a PostCSS plugin');\r\n            }\r\n        }\r\n        return normalized;\r\n    }\r\n    process(css, opts = {}) {\r\n        if (!this.plugins.length &&\r\n            !opts.parser &&\r\n            !opts.stringifier &&\r\n            !opts.syntax) {\r\n            return new NoWorkResult(this, css, opts);\r\n        }\r\n        else {\r\n            return new LazyResult(this, css, opts);\r\n        }\r\n    }\r\n    use(plugin) {\r\n        this.plugins = this.plugins.concat(this.normalize([plugin]));\r\n        return this;\r\n    }\r\n}\r\nRoot.registerProcessor(Processor);\r\nDocument.registerProcessor(Processor);\r\n", "import { AtRule } from './at-rule';\r\nimport { Comment } from './comment';\r\nimport { Declaration } from './declaration';\r\nimport { Root } from './root';\r\nimport { Rule } from './rule';\r\nimport { parse } from \"./parse\";\r\nimport { list } from \"./list\";\r\nimport { Input } from './input';\r\nimport { stringify } from \"./stringify\";\r\nimport { CssSyntaxError } from \"./css-syntax-error\";\r\nimport { Container } from \"./container\";\r\nimport { Document } from \"./document\";\r\nimport { Node } from \"./node\";\r\nimport { fromJSON } from \"./fromJSON\";\r\nimport { Processor } from \"./processor\";\r\nimport { Warning } from \"./warning\";\r\nimport { Result } from \"./result\";\r\nimport { LazyResult } from \"./lazy-result\";\r\nLazyResult.registerPostcss(postcss);\r\nfunction postcss(...plugins) {\r\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\r\n        plugins = plugins[0];\r\n    }\r\n    return new Processor(plugins);\r\n}\r\npostcss.plugin = function plugin(name, initializer) {\r\n    let warningPrinted = false;\r\n    function creator(...args) {\r\n        // eslint-disable-next-line no-console\r\n        const transformer = initializer(...args);\r\n        transformer.postcssPlugin = name;\r\n        transformer.postcssVersion = new Processor().version;\r\n        return transformer;\r\n    }\r\n    let cache;\r\n    Object.defineProperty(creator, 'postcss', {\r\n        get() {\r\n            if (!cache)\r\n                cache = creator();\r\n            return cache;\r\n        }\r\n    });\r\n    creator.process = (css, processOpts, pluginOpts) => postcss([creator(pluginOpts)]).process(css, processOpts);\r\n    return creator;\r\n};\r\npostcss.stringify = stringify;\r\npostcss.parse = parse;\r\npostcss.fromJSON = fromJSON;\r\npostcss.list = list;\r\npostcss.comment = defaults => new Comment(defaults);\r\npostcss.atRule = defaults => new AtRule(defaults);\r\npostcss.decl = defaults => new Declaration(defaults);\r\npostcss.rule = defaults => new Rule(defaults);\r\npostcss.root = defaults => new Root(defaults);\r\npostcss.document = defaults => new Document(defaults);\r\npostcss.CssSyntaxError = CssSyntaxError;\r\npostcss.Declaration = Declaration;\r\npostcss.Container = Container;\r\npostcss.Processor = Processor;\r\npostcss.Document = Document;\r\npostcss.Comment = Comment;\r\npostcss.Warning = Warning;\r\npostcss.AtRule = AtRule;\r\npostcss.Result = Result;\r\npostcss.Input = Input;\r\npostcss.Rule = Rule;\r\npostcss.Root = Root;\r\npostcss.Node = Node;\r\nexport default postcss;\r\n", "// Many thanks for this post which made this migration much easier.\r\n// https://mathiasbynens.be/notes/css-escapes\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {[string, number]|undefined}\r\n */\r\nfunction gobbleHex(str) {\r\n    const lower = str.toLowerCase();\r\n    let hex = '';\r\n    let spaceTerminated = false;\r\n    for (let i = 0; i < 6 && lower[i] !== undefined; i++) {\r\n        const code = lower.charCodeAt(i);\r\n        // check to see if we are dealing with a valid hex char [a-f|0-9]\r\n        const valid = (code >= 97 && code <= 102) || (code >= 48 && code <= 57);\r\n        // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\r\n        spaceTerminated = code === 32;\r\n        if (!valid) {\r\n            break;\r\n        }\r\n        hex += lower[i];\r\n    }\r\n    if (hex.length === 0) {\r\n        return undefined;\r\n    }\r\n    const codePoint = parseInt(hex, 16);\r\n    const isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;\r\n    // Add special case for\r\n    // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\r\n    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\r\n    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\r\n        return ['\\uFFFD', hex.length + (spaceTerminated ? 1 : 0)];\r\n    }\r\n    return [\r\n        String.fromCodePoint(codePoint),\r\n        hex.length + (spaceTerminated ? 1 : 0),\r\n    ];\r\n}\r\nconst CONTAINS_ESCAPE = /\\\\/;\r\nexport default function unesc(str) {\r\n    let needToProcess = CONTAINS_ESCAPE.test(str);\r\n    if (!needToProcess) {\r\n        return str;\r\n    }\r\n    let ret = \"\";\r\n    for (let i = 0; i < str.length; i++) {\r\n        if ((str[i] === \"\\\\\")) {\r\n            const gobbled = gobbleHex(str.slice(i + 1, i + 7));\r\n            if (gobbled !== undefined) {\r\n                ret += gobbled[0];\r\n                i += gobbled[1];\r\n                continue;\r\n            }\r\n            // Retain a pair of \\\\ if double escaped `\\\\\\\\`\r\n            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\r\n            if (str[i + 1] === \"\\\\\") {\r\n                ret += \"\\\\\";\r\n                i++;\r\n                continue;\r\n            }\r\n            // if \\\\ is at the end of the string retain it\r\n            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\r\n            if (str.length === i + 1) {\r\n                ret += str[i];\r\n            }\r\n            continue;\r\n        }\r\n        ret += str[i];\r\n    }\r\n    return ret;\r\n}\r\n", "export default function getProp(obj, ...props) {\r\n    while (props.length > 0) {\r\n        const prop = props.shift();\r\n        if (!obj[prop]) {\r\n            return undefined;\r\n        }\r\n        obj = obj[prop];\r\n    }\r\n    return obj;\r\n}\r\n", "export default function ensureObject(obj, ...props) {\r\n    while (props.length > 0) {\r\n        const prop = props.shift();\r\n        if (!obj[prop]) {\r\n            obj[prop] = {};\r\n        }\r\n        obj = obj[prop];\r\n    }\r\n}\r\n", "import { ensureObject } from \"../util\";\r\nlet cloneNode = function (obj, parent) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n    let cloned = new obj.constructor();\r\n    for (let i in obj) {\r\n        if (!obj.hasOwnProperty(i)) {\r\n            continue;\r\n        }\r\n        let value = obj[i];\r\n        let type = typeof value;\r\n        if (i === 'parent' && type === 'object') {\r\n            if (parent) {\r\n                cloned[i] = parent;\r\n            }\r\n        }\r\n        else if (value instanceof Array) {\r\n            cloned[i] = value.map(j => cloneNode(j, cloned));\r\n        }\r\n        else {\r\n            cloned[i] = cloneNode(value, cloned);\r\n        }\r\n    }\r\n    return cloned;\r\n};\r\nexport default class Node {\r\n    constructor(opts = {}) {\r\n        Object.assign(this, opts);\r\n        this.spaces = this.spaces || {};\r\n        this.spaces.before = this.spaces.before || '';\r\n        this.spaces.after = this.spaces.after || '';\r\n    }\r\n    remove() {\r\n        if (this.parent) {\r\n            this.parent.removeChild(this);\r\n        }\r\n        this.parent = undefined;\r\n        return this;\r\n    }\r\n    replaceWith() {\r\n        if (this.parent) {\r\n            for (let index in arguments) {\r\n                this.parent.insertBefore(this, arguments[index]);\r\n            }\r\n            this.remove();\r\n        }\r\n        return this;\r\n    }\r\n    next() {\r\n        return this.parent.at(this.parent.index(this) + 1);\r\n    }\r\n    prev() {\r\n        return this.parent.at(this.parent.index(this) - 1);\r\n    }\r\n    clone(overrides = {}) {\r\n        let cloned = cloneNode(this);\r\n        for (let name in overrides) {\r\n            cloned[name] = overrides[name];\r\n        }\r\n        return cloned;\r\n    }\r\n    /**\r\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\r\n     * This allows non standard syntax to be appended to an existing property\r\n     * by specifying the escaped value. By specifying the escaped value,\r\n     * illegal characters are allowed to be directly inserted into css output.\r\n     * @param {string} name the property to set\r\n     * @param {any} value the unescaped value of the property\r\n     * @param {string} valueEscaped optional. the escaped value of the property.\r\n     */\r\n    appendToPropertyAndEscape(name, value, valueEscaped) {\r\n        if (!this.raws) {\r\n            this.raws = {};\r\n        }\r\n        let originalValue = this[name];\r\n        let originalEscaped = this.raws[name];\r\n        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        if (originalEscaped || valueEscaped !== value) {\r\n            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\r\n        }\r\n        else {\r\n            delete this.raws[name]; // delete any escaped value that was created by the setter.\r\n        }\r\n    }\r\n    /**\r\n     * Some non-standard syntax doesn't follow normal escaping rules for css.\r\n     * This allows the escaped value to be specified directly, allowing illegal\r\n     * characters to be directly inserted into css output.\r\n     * @param {string} name the property to set\r\n     * @param {any} value the unescaped value of the property\r\n     * @param {string} valueEscaped the escaped value of the property.\r\n     */\r\n    setPropertyAndEscape(name, value, valueEscaped) {\r\n        if (!this.raws) {\r\n            this.raws = {};\r\n        }\r\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        this.raws[name] = valueEscaped;\r\n    }\r\n    /**\r\n     * When you want a value to passed through to CSS directly. This method\r\n     * deletes the corresponding raw value causing the stringifier to fallback\r\n     * to the unescaped value.\r\n     * @param {string} name the property to set.\r\n     * @param {any} value The value that is both escaped and unescaped.\r\n     */\r\n    setPropertyWithoutEscape(name, value) {\r\n        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\r\n        if (this.raws) {\r\n            delete this.raws[name];\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @param {number} line The number (starting with 1)\r\n     * @param {number} column The column number (starting with 1)\r\n     */\r\n    isAtPosition(line, column) {\r\n        if (this.source && this.source.start && this.source.end) {\r\n            if (this.source.start.line > line) {\r\n                return false;\r\n            }\r\n            if (this.source.end.line < line) {\r\n                return false;\r\n            }\r\n            if (this.source.start.line === line && this.source.start.column > column) {\r\n                return false;\r\n            }\r\n            if (this.source.end.line === line && this.source.end.column < column) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return undefined;\r\n    }\r\n    stringifyProperty(name) {\r\n        return (this.raws && this.raws[name]) || this[name];\r\n    }\r\n    get rawSpaceBefore() {\r\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\r\n        if (rawSpace === undefined) {\r\n            rawSpace = this.spaces && this.spaces.before;\r\n        }\r\n        return rawSpace || \"\";\r\n    }\r\n    set rawSpaceBefore(raw) {\r\n        ensureObject(this, \"raws\", \"spaces\");\r\n        this.raws.spaces.before = raw;\r\n    }\r\n    get rawSpaceAfter() {\r\n        let rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\r\n        if (rawSpace === undefined) {\r\n            rawSpace = this.spaces.after;\r\n        }\r\n        return rawSpace || \"\";\r\n    }\r\n    set rawSpaceAfter(raw) {\r\n        ensureObject(this, \"raws\", \"spaces\");\r\n        this.raws.spaces.after = raw;\r\n    }\r\n    valueToString() {\r\n        return String(this.stringifyProperty(\"value\"));\r\n    }\r\n    toString() {\r\n        return [\r\n            this.rawSpaceBefore,\r\n            this.valueToString(),\r\n            this.rawSpaceAfter,\r\n        ].join('');\r\n    }\r\n}\r\n", "export const TAG = 'tag';\r\nexport const STRING = 'string';\r\nexport const SELECTOR = 'selector';\r\nexport const ROOT = 'root';\r\nexport const PSEUDO = 'pseudo';\r\nexport const NESTING = 'nesting';\r\nexport const ID = 'id';\r\nexport const COMMENT = 'comment';\r\nexport const COMBINATOR = 'combinator';\r\nexport const CLASS = 'class';\r\nexport const ATTRIBUTE = 'attribute';\r\nexport const UNIVERSAL = 'universal';\r\n", "import Node from './node';\r\nimport * as types from './types';\r\nexport default class Container extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        if (!this.nodes) {\r\n            this.nodes = [];\r\n        }\r\n    }\r\n    append(selector) {\r\n        selector.parent = this;\r\n        this.nodes.push(selector);\r\n        return this;\r\n    }\r\n    prepend(selector) {\r\n        selector.parent = this;\r\n        this.nodes.unshift(selector);\r\n        for (let id in this.indexes) {\r\n            this.indexes[id]++;\r\n        }\r\n        return this;\r\n    }\r\n    at(index) {\r\n        return this.nodes[index];\r\n    }\r\n    index(child) {\r\n        if (typeof child === 'number') {\r\n            return child;\r\n        }\r\n        return this.nodes.indexOf(child);\r\n    }\r\n    get first() {\r\n        return this.at(0);\r\n    }\r\n    get last() {\r\n        return this.at(this.length - 1);\r\n    }\r\n    get length() {\r\n        return this.nodes.length;\r\n    }\r\n    removeChild(child) {\r\n        child = this.index(child);\r\n        this.at(child).parent = undefined;\r\n        this.nodes.splice(child, 1);\r\n        let index;\r\n        for (let id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (index >= child) {\r\n                this.indexes[id] = index - 1;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    removeAll() {\r\n        for (let node of this.nodes) {\r\n            node.parent = undefined;\r\n        }\r\n        this.nodes = [];\r\n        return this;\r\n    }\r\n    empty() {\r\n        return this.removeAll();\r\n    }\r\n    insertAfter(oldNode, newNode) {\r\n        newNode.parent = this;\r\n        let oldIndex = this.index(oldNode);\r\n        this.nodes.splice(oldIndex + 1, 0, newNode);\r\n        newNode.parent = this;\r\n        let index;\r\n        for (let id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (oldIndex < index) {\r\n                this.indexes[id] = index + 1;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    insertBefore(oldNode, newNode) {\r\n        newNode.parent = this;\r\n        let oldIndex = this.index(oldNode);\r\n        this.nodes.splice(oldIndex, 0, newNode);\r\n        newNode.parent = this;\r\n        let index;\r\n        for (let id in this.indexes) {\r\n            index = this.indexes[id];\r\n            if (index >= oldIndex) {\r\n                this.indexes[id] = index + 1;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    _findChildAtPosition(line, col) {\r\n        let found = undefined;\r\n        this.each(node => {\r\n            if (node.atPosition) {\r\n                let foundChild = node.atPosition(line, col);\r\n                if (foundChild) {\r\n                    found = foundChild;\r\n                    return false;\r\n                }\r\n            }\r\n            else if (node.isAtPosition(line, col)) {\r\n                found = node;\r\n                return false;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n    /**\r\n     * Return the most specific node at the line and column number given.\r\n     * The source location is based on the original parsed location, locations aren't\r\n     * updated as selector nodes are mutated.\r\n     *\r\n     * Note that this location is relative to the location of the first character\r\n     * of the selector, and not the location of the selector in the overall document\r\n     * when used in conjunction with postcss.\r\n     *\r\n     * If not found, returns undefined.\r\n     * @param {number} line The line number of the node to find. (1-based index)\r\n     * @param {number} col  The column number of the node to find. (1-based index)\r\n     */\r\n    atPosition(line, col) {\r\n        if (this.isAtPosition(line, col)) {\r\n            return this._findChildAtPosition(line, col) || this;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    _inferEndPosition() {\r\n        if (this.last && this.last.source && this.last.source.end) {\r\n            this.source = this.source || {};\r\n            this.source.end = this.source.end || {};\r\n            Object.assign(this.source.end, this.last.source.end);\r\n        }\r\n    }\r\n    each(callback) {\r\n        if (!this.lastEach) {\r\n            this.lastEach = 0;\r\n        }\r\n        if (!this.indexes) {\r\n            this.indexes = {};\r\n        }\r\n        this.lastEach++;\r\n        let id = this.lastEach;\r\n        this.indexes[id] = 0;\r\n        if (!this.length) {\r\n            return undefined;\r\n        }\r\n        let index, result;\r\n        while (this.indexes[id] < this.length) {\r\n            index = this.indexes[id];\r\n            result = callback(this.at(index), index);\r\n            if (result === false) {\r\n                break;\r\n            }\r\n            this.indexes[id] += 1;\r\n        }\r\n        delete this.indexes[id];\r\n        if (result === false) {\r\n            return false;\r\n        }\r\n    }\r\n    walk(callback) {\r\n        return this.each((node, i) => {\r\n            let result = callback(node, i);\r\n            if (result !== false && node.length) {\r\n                result = node.walk(callback);\r\n            }\r\n            if (result === false) {\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    walkAttributes(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.ATTRIBUTE) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkClasses(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.CLASS) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkCombinators(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.COMBINATOR) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkComments(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.COMMENT) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkIds(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.ID) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkNesting(callback) {\r\n        return this.walk(selector => {\r\n            if (selector.type === types.NESTING) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkPseudos(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.PSEUDO) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkTags(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.TAG) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    walkUniversals(callback) {\r\n        return this.walk((selector) => {\r\n            if (selector.type === types.UNIVERSAL) {\r\n                return callback.call(this, selector);\r\n            }\r\n        });\r\n    }\r\n    split(callback) {\r\n        let current = [];\r\n        return this.reduce((memo, node, index) => {\r\n            let split = callback.call(this, node);\r\n            current.push(node);\r\n            if (split) {\r\n                memo.push(current);\r\n                current = [];\r\n            }\r\n            else if (index === this.length - 1) {\r\n                memo.push(current);\r\n            }\r\n            return memo;\r\n        }, []);\r\n    }\r\n    map(callback) {\r\n        return this.nodes.map(callback);\r\n    }\r\n    reduce(callback, memo) {\r\n        return this.nodes.reduce(callback, memo);\r\n    }\r\n    every(callback) {\r\n        return this.nodes.every(callback);\r\n    }\r\n    some(callback) {\r\n        return this.nodes.some(callback);\r\n    }\r\n    filter(callback) {\r\n        return this.nodes.filter(callback);\r\n    }\r\n    sort(callback) {\r\n        return this.nodes.sort(callback);\r\n    }\r\n    toString() {\r\n        return this.map(String).join('');\r\n    }\r\n}\r\n", "import Container from './container';\r\nimport { ROOT } from './types';\r\nexport default class Root extends Container {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = ROOT;\r\n    }\r\n    toString() {\r\n        let str = this.reduce((memo, selector) => {\r\n            memo.push(String(selector));\r\n            return memo;\r\n        }, []).join(',');\r\n        return this.trailingComma ? str + ',' : str;\r\n    }\r\n    error(message, options) {\r\n        if (this._error) {\r\n            return this._error(message, options);\r\n        }\r\n        else {\r\n            return new Error(message);\r\n        }\r\n    }\r\n    set errorGenerator(handler) {\r\n        this._error = handler;\r\n    }\r\n}\r\n", "import Container from './container';\r\nimport { SELECTOR } from './types';\r\nexport default class Selector extends Container {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = SELECTOR;\r\n    }\r\n}\r\n", "const object = {};\r\nconst hasOwnProperty = object.hasOwnProperty;\r\nconst merge = (options, defaults) => {\r\n    if (!options) {\r\n        return defaults;\r\n    }\r\n    const result = {};\r\n    for (const key in defaults) {\r\n        // `if (defaults.hasOwnProperty(key) { \u2026 }` is not needed here, since\r\n        // only recognized option names are used.\r\n        result[key] = hasOwnProperty.call(options, key)\r\n            ? options[key]\r\n            : defaults[key];\r\n    }\r\n    return result;\r\n};\r\nconst regexAnySingleEscape = /<%= anySingleEscape %>/;\r\nconst regexSingleEscape = /<%= singleEscapes %>/;\r\nconst regexAlwaysEscape = /['\"\\\\]/;\r\nconst regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\r\n/*@__NO_SIDE_EFFECTS__*/\r\nconst cssesc = (string, options) => {\r\n    options = merge(options, cssesc.options);\r\n    if (options.quotes != 'single' && options.quotes != 'double') {\r\n        options.quotes = 'single';\r\n    }\r\n    const quote = options.quotes == 'double' ? '\"' : '\\'';\r\n    const isIdentifier = options.isIdentifier;\r\n    const firstChar = string.charAt(0);\r\n    let output = '';\r\n    let counter = 0;\r\n    const length = string.length;\r\n    while (counter < length) {\r\n        const character = string.charAt(counter++);\r\n        let codePoint = character.charCodeAt();\r\n        let value;\r\n        // If it\u2019s not a printable ASCII character\u2026\r\n        if (codePoint < 0x20 || codePoint > 0x7E) {\r\n            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\r\n                // It\u2019s a high surrogate, and there is a next character.\r\n                const extra = string.charCodeAt(counter++);\r\n                if ((extra & 0xFC00) == 0xDC00) { // next character is low surrogate\r\n                    codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\r\n                }\r\n                else {\r\n                    // It\u2019s an unmatched surrogate; only append this code unit, in case\r\n                    // the next code unit is the high surrogate of a surrogate pair.\r\n                    counter--;\r\n                }\r\n            }\r\n            value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n        }\r\n        else {\r\n            if (options.escapeEverything) {\r\n                if (regexAnySingleEscape.test(character)) {\r\n                    value = '\\\\' + character;\r\n                }\r\n                else {\r\n                    value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n                }\r\n            }\r\n            else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\r\n                value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\r\n            }\r\n            else if (character == '\\\\' ||\r\n                (!isIdentifier &&\r\n                    ((character == '\"' && quote == character) ||\r\n                        (character == '\\'' && quote == character))) ||\r\n                (isIdentifier && regexSingleEscape.test(character))) {\r\n                value = '\\\\' + character;\r\n            }\r\n            else {\r\n                value = character;\r\n            }\r\n        }\r\n        output += value;\r\n    }\r\n    if (isIdentifier) {\r\n        if (/^-[-\\d]/.test(output)) {\r\n            output = '\\\\-' + output.slice(1);\r\n        }\r\n        else if (/\\d/.test(firstChar)) {\r\n            output = '\\\\3' + firstChar + ' ' + output.slice(1);\r\n        }\r\n    }\r\n    // Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\r\n    // since they\u2019re redundant. Note that this is only possible if the escape\r\n    // sequence isn\u2019t preceded by an odd number of backslashes.\r\n    output = output.replace(regexExcessiveSpaces, ($0, $1, $2) => {\r\n        if ($1 && $1.length % 2) {\r\n            // It\u2019s not safe to remove the space, so don\u2019t.\r\n            return $0;\r\n        }\r\n        // Strip the space.\r\n        return ($1 || '') + $2;\r\n    });\r\n    if (!isIdentifier && options.wrap) {\r\n        return quote + output + quote;\r\n    }\r\n    return output;\r\n};\r\n// Expose default options (so they can be overridden globally).\r\ncssesc.options = {\r\n    'escapeEverything': false,\r\n    'isIdentifier': false,\r\n    'quotes': 'single',\r\n    'wrap': false\r\n};\r\nexport default cssesc;\r\n", "import cssesc from \"../../cssesc\";\r\nimport { ensureObject } from '../util';\r\nimport Node from './node';\r\nimport { CLASS } from './types';\r\nexport default class ClassName extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = CLASS;\r\n        this._constructed = true;\r\n    }\r\n    set value(v) {\r\n        if (this._constructed) {\r\n            const escaped = cssesc(v, { isIdentifier: true });\r\n            if (escaped !== v) {\r\n                ensureObject(this, \"raws\");\r\n                this.raws.value = escaped;\r\n            }\r\n            else if (this.raws) {\r\n                delete this.raws.value;\r\n            }\r\n        }\r\n        this._value = v;\r\n    }\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    valueToString() {\r\n        return '.' + super.valueToString();\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { COMMENT } from './types';\r\nexport default class Comment extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = COMMENT;\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { ID as IDType } from './types';\r\nexport default class ID extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = IDType;\r\n    }\r\n    valueToString() {\r\n        return '#' + super.valueToString();\r\n    }\r\n}\r\n", "import cssesc from \"../../cssesc\";\r\nimport { ensureObject } from '../util';\r\nimport Node from './node';\r\nexport default class Namespace extends Node {\r\n    get namespace() {\r\n        return this._namespace;\r\n    }\r\n    set namespace(namespace) {\r\n        if (namespace === true || namespace === \"*\" || namespace === \"&\") {\r\n            this._namespace = namespace;\r\n            if (this.raws) {\r\n                delete this.raws.namespace;\r\n            }\r\n            return;\r\n        }\r\n        const escaped = cssesc(namespace, { isIdentifier: true });\r\n        this._namespace = namespace;\r\n        if (escaped !== namespace) {\r\n            ensureObject(this, \"raws\");\r\n            this.raws.namespace = escaped;\r\n        }\r\n        else if (this.raws) {\r\n            delete this.raws.namespace;\r\n        }\r\n    }\r\n    get ns() {\r\n        return this._namespace;\r\n    }\r\n    set ns(namespace) {\r\n        this.namespace = namespace;\r\n    }\r\n    get namespaceString() {\r\n        if (this.namespace) {\r\n            const ns = this.stringifyProperty(\"namespace\");\r\n            if (ns === true) {\r\n                return '';\r\n            }\r\n            else {\r\n                return ns;\r\n            }\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    qualifiedName(value) {\r\n        if (this.namespace) {\r\n            return `${this.namespaceString}|${value}`;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n    valueToString() {\r\n        return this.qualifiedName(super.valueToString());\r\n    }\r\n}\r\n;\r\n", "import Namespace from './namespace';\r\nimport { TAG } from './types';\r\nexport default class Tag extends Namespace {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = TAG;\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { STRING } from './types';\r\nexport default class String extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = STRING;\r\n    }\r\n}\r\n", "import Container from './container';\r\nimport { PSEUDO } from './types';\r\nexport default class Pseudo extends Container {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = PSEUDO;\r\n    }\r\n    toString() {\r\n        let params = this.length ? '(' + this.map(String).join(',') + ')' : '';\r\n        return [\r\n            this.rawSpaceBefore,\r\n            this.stringifyProperty(\"value\"),\r\n            params,\r\n            this.rawSpaceAfter,\r\n        ].join('');\r\n    }\r\n}\r\n", "import cssesc from \"../../cssesc\";\r\nimport unesc from \"../util/unesc\";\r\nimport Namespace from './namespace';\r\nimport { ATTRIBUTE } from './types';\r\nconst WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\r\nexport function unescapeValue(value) {\r\n    let deprecatedUsage = false;\r\n    let quoteMark = null;\r\n    let unescaped = value;\r\n    const m = unescaped.match(WRAPPED_IN_QUOTES);\r\n    if (m) {\r\n        quoteMark = m[1];\r\n        unescaped = m[2];\r\n    }\r\n    unescaped = unesc(unescaped);\r\n    if (unescaped !== value) {\r\n        deprecatedUsage = true;\r\n    }\r\n    return {\r\n        deprecatedUsage,\r\n        unescaped,\r\n        quoteMark,\r\n    };\r\n}\r\nfunction handleDeprecatedContructorOpts(opts) {\r\n    if (opts.quoteMark !== undefined) {\r\n        return opts;\r\n    }\r\n    if (opts.value === undefined) {\r\n        return opts;\r\n    }\r\n    warnOfDeprecatedConstructor();\r\n    const { quoteMark, unescaped } = unescapeValue(opts.value);\r\n    if (!opts.raws) {\r\n        opts.raws = {};\r\n    }\r\n    if (opts.raws.value === undefined) {\r\n        opts.raws.value = opts.value;\r\n    }\r\n    opts.value = unescaped;\r\n    opts.quoteMark = quoteMark;\r\n    return opts;\r\n}\r\nexport default class Attribute extends Namespace {\r\n    static NO_QUOTE = null;\r\n    static SINGLE_QUOTE = \"'\";\r\n    static DOUBLE_QUOTE = '\"';\r\n    constructor(opts = {}) {\r\n        super(handleDeprecatedContructorOpts(opts));\r\n        this.type = ATTRIBUTE;\r\n        this.raws = this.raws || {};\r\n        this._constructed = true;\r\n    }\r\n    /**\r\n     * Returns the Attribute's value quoted such that it would be legal to use\r\n     * in the value of a css file. The original value's quotation setting\r\n     * used for stringification is left unchanged. See `setValue(value, options)`\r\n     * if you want to control the quote settings of a new value for the attribute.\r\n     *\r\n     * You can also change the quotation used for the current value by setting quoteMark.\r\n     *\r\n     * Options:\r\n     *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\r\n     *     option is not set, the original value for quoteMark will be used. If\r\n     *     indeterminate, a double quote is used. The legal values are:\r\n     *     * `null` - the value will be unquoted and characters will be escaped as necessary.\r\n     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\r\n     *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\r\n     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\r\n     *     over the quoteMark option value.\r\n     *   * smart {boolean} - if true, will select a quote mark based on the value\r\n     *     and the other options specified here. See the `smartQuoteMark()`\r\n     *     method.\r\n     **/\r\n    getQuotedValue(options = {}) {\r\n        const quoteMark = this._determineQuoteMark(options);\r\n        const cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\r\n        const escaped = cssesc(this._value, cssescopts);\r\n        return escaped;\r\n    }\r\n    _determineQuoteMark(options) {\r\n        return (options.smart) ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\r\n    }\r\n    /**\r\n     * Set the unescaped value with the specified quotation options. The value\r\n     * provided must not include any wrapping quote marks -- those quotes will\r\n     * be interpreted as part of the value and escaped accordingly.\r\n     */\r\n    setValue(value, options = {}) {\r\n        this._value = value;\r\n        this._quoteMark = this._determineQuoteMark(options);\r\n        this._syncRawValue();\r\n    }\r\n    /**\r\n     * Intelligently select a quoteMark value based on the value's contents. If\r\n     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\r\n     * mark will be picked that minimizes the number of escapes.\r\n     *\r\n     * If there's no clear winner, the quote mark from these options is used,\r\n     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\r\n     * true). If the quoteMark is unspecified, a double quote is used.\r\n     *\r\n     * @param options This takes the quoteMark and preferCurrentQuoteMark options\r\n     * from the quoteValue method.\r\n     */\r\n    smartQuoteMark(options) {\r\n        const v = this.value;\r\n        const numSingleQuotes = v.replace(/[^']/g, '').length;\r\n        const numDoubleQuotes = v.replace(/[^\"]/g, '').length;\r\n        if (numSingleQuotes + numDoubleQuotes === 0) {\r\n            const escaped = cssesc(v, { isIdentifier: true });\r\n            if (escaped === v) {\r\n                return Attribute.NO_QUOTE;\r\n            }\r\n            else {\r\n                const pref = this.preferredQuoteMark(options);\r\n                if (pref === Attribute.NO_QUOTE) {\r\n                    // pick a quote mark that isn't none and see if it's smaller\r\n                    const quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\r\n                    const opts = CSSESC_QUOTE_OPTIONS[quote];\r\n                    const quoteValue = cssesc(v, opts);\r\n                    if (quoteValue.length < escaped.length) {\r\n                        return quote;\r\n                    }\r\n                }\r\n                return pref;\r\n            }\r\n        }\r\n        else if (numDoubleQuotes === numSingleQuotes) {\r\n            return this.preferredQuoteMark(options);\r\n        }\r\n        else if (numDoubleQuotes < numSingleQuotes) {\r\n            return Attribute.DOUBLE_QUOTE;\r\n        }\r\n        else {\r\n            return Attribute.SINGLE_QUOTE;\r\n        }\r\n    }\r\n    /**\r\n     * Selects the preferred quote mark based on the options and the current quote mark value.\r\n     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\r\n     * instead.\r\n     */\r\n    preferredQuoteMark(options) {\r\n        let quoteMark = (options.preferCurrentQuoteMark) ? this.quoteMark : options.quoteMark;\r\n        if (quoteMark === undefined) {\r\n            quoteMark = (options.preferCurrentQuoteMark) ? options.quoteMark : this.quoteMark;\r\n        }\r\n        if (quoteMark === undefined) {\r\n            quoteMark = Attribute.DOUBLE_QUOTE;\r\n        }\r\n        return quoteMark;\r\n    }\r\n    get quoted() {\r\n        const qm = this.quoteMark;\r\n        return qm === \"'\" || qm === '\"';\r\n    }\r\n    set quoted(value) {\r\n        warnOfDeprecatedQuotedAssignment();\r\n    }\r\n    /**\r\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\r\n     * returns `null` if the value is not quoted.\r\n     * returns `undefined` if the quotation state is unknown (this can happen when\r\n     * the attribute is constructed without specifying a quote mark.)\r\n     */\r\n    get quoteMark() {\r\n        return this._quoteMark;\r\n    }\r\n    /**\r\n     * Set the quote mark to be used by this attribute's value.\r\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\r\n     * value is updated accordingly.\r\n     *\r\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\r\n     */\r\n    set quoteMark(quoteMark) {\r\n        if (!this._constructed) {\r\n            this._quoteMark = quoteMark;\r\n            return;\r\n        }\r\n        if (this._quoteMark !== quoteMark) {\r\n            this._quoteMark = quoteMark;\r\n            this._syncRawValue();\r\n        }\r\n    }\r\n    _syncRawValue() {\r\n        const rawValue = cssesc(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\r\n        if (rawValue === this._value) {\r\n            if (this.raws) {\r\n                delete this.raws.value;\r\n            }\r\n        }\r\n        else {\r\n            this.raws.value = rawValue;\r\n        }\r\n    }\r\n    get qualifiedAttribute() {\r\n        return this.qualifiedName(this.raws.attribute || this.attribute);\r\n    }\r\n    get insensitiveFlag() {\r\n        return this.insensitive ? 'i' : '';\r\n    }\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    get insensitive() {\r\n        return this._insensitive;\r\n    }\r\n    /**\r\n     * Set the case insensitive flag.\r\n     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`\r\n     * of the attribute is updated accordingly.\r\n     *\r\n     * @param {true | false} insensitive true if the attribute should match case-insensitively.\r\n     */\r\n    set insensitive(insensitive) {\r\n        if (!insensitive) {\r\n            this._insensitive = false;\r\n            // \"i\" and \"I\" can be used in \"this.raws.insensitiveFlag\" to store the original notation.\r\n            // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.\r\n            if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {\r\n                this.raws.insensitiveFlag = undefined;\r\n            }\r\n        }\r\n        this._insensitive = insensitive;\r\n    }\r\n    /**\r\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\r\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\r\n     * is unescaped during parsing and any quote marks are removed.\r\n     *\r\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\r\n     * a deprecation warning is raised when the new value contains any characters that would\r\n     * require escaping (including if it contains wrapped quotes).\r\n     *\r\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\r\n     * how the new value is quoted.\r\n     */\r\n    set value(v) {\r\n        if (this._constructed) {\r\n            const { deprecatedUsage, unescaped, quoteMark, } = unescapeValue(v);\r\n            if (deprecatedUsage) {\r\n                warnOfDeprecatedValueAssignment();\r\n            }\r\n            if (unescaped === this._value && quoteMark === this._quoteMark) {\r\n                return;\r\n            }\r\n            this._value = unescaped;\r\n            this._quoteMark = quoteMark;\r\n            this._syncRawValue();\r\n        }\r\n        else {\r\n            this._value = v;\r\n        }\r\n    }\r\n    get attribute() {\r\n        return this._attribute;\r\n    }\r\n    set attribute(name) {\r\n        this._handleEscapes(\"attribute\", name);\r\n        this._attribute = name;\r\n    }\r\n    _handleEscapes(prop, value) {\r\n        if (this._constructed) {\r\n            const escaped = cssesc(value, { isIdentifier: true });\r\n            if (escaped !== value) {\r\n                this.raws[prop] = escaped;\r\n            }\r\n            else {\r\n                delete this.raws[prop];\r\n            }\r\n        }\r\n    }\r\n    _spacesFor(name) {\r\n        const attrSpaces = { before: '', after: '' };\r\n        const spaces = this.spaces[name] || {};\r\n        const rawSpaces = (this.raws.spaces && this.raws.spaces[name]) || {};\r\n        return Object.assign(attrSpaces, spaces, rawSpaces);\r\n    }\r\n    _stringFor(name, spaceName = name, concat = defaultAttrConcat) {\r\n        const attrSpaces = this._spacesFor(spaceName);\r\n        return concat(this.stringifyProperty(name), attrSpaces);\r\n    }\r\n    /**\r\n     * returns the offset of the attribute part specified relative to the\r\n     * start of the node of the output string.\r\n     *\r\n     * * \"ns\" - alias for \"namespace\"\r\n     * * \"namespace\" - the namespace if it exists.\r\n     * * \"attribute\" - the attribute name\r\n     * * \"attributeNS\" - the start of the attribute or its namespace\r\n     * * \"operator\" - the match operator of the attribute\r\n     * * \"value\" - The value (string or identifier)\r\n     * * \"insensitive\" - the case insensitivity flag;\r\n     * @param part One of the possible values inside an attribute.\r\n     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\r\n     */\r\n    offsetOf(name) {\r\n        let count = 1;\r\n        const attributeSpaces = this._spacesFor(\"attribute\");\r\n        count += attributeSpaces.before.length;\r\n        if (name === \"namespace\" || name === \"ns\") {\r\n            return (this.namespace) ? count : -1;\r\n        }\r\n        if (name === \"attributeNS\") {\r\n            return count;\r\n        }\r\n        count += this.namespaceString.length;\r\n        if (this.namespace) {\r\n            count += 1;\r\n        }\r\n        if (name === \"attribute\") {\r\n            return count;\r\n        }\r\n        count += this.stringifyProperty(\"attribute\").length;\r\n        count += attributeSpaces.after.length;\r\n        const operatorSpaces = this._spacesFor(\"operator\");\r\n        count += operatorSpaces.before.length;\r\n        const operator = this.stringifyProperty(\"operator\");\r\n        if (name === \"operator\") {\r\n            return operator ? count : -1;\r\n        }\r\n        count += operator.length;\r\n        count += operatorSpaces.after.length;\r\n        const valueSpaces = this._spacesFor(\"value\");\r\n        count += valueSpaces.before.length;\r\n        const value = this.stringifyProperty(\"value\");\r\n        if (name === \"value\") {\r\n            return value ? count : -1;\r\n        }\r\n        count += value.length;\r\n        count += valueSpaces.after.length;\r\n        const insensitiveSpaces = this._spacesFor(\"insensitive\");\r\n        count += insensitiveSpaces.before.length;\r\n        if (name === \"insensitive\") {\r\n            return (this.insensitive) ? count : -1;\r\n        }\r\n        return -1;\r\n    }\r\n    toString() {\r\n        const selector = [\r\n            this.rawSpaceBefore,\r\n            '[',\r\n        ];\r\n        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\r\n        if (this.operator && (this.value || this.value === '')) {\r\n            selector.push(this._stringFor('operator'));\r\n            selector.push(this._stringFor('value'));\r\n            selector.push(this._stringFor('insensitiveFlag', 'insensitive', (attrValue, attrSpaces) => {\r\n                if (attrValue.length > 0\r\n                    && !this.quoted\r\n                    && attrSpaces.before.length === 0\r\n                    && !(this.spaces.value && this.spaces.value.after)) {\r\n                    attrSpaces.before = \" \";\r\n                }\r\n                return defaultAttrConcat(attrValue, attrSpaces);\r\n            }));\r\n        }\r\n        selector.push(']');\r\n        selector.push(this.rawSpaceAfter);\r\n        return selector.join('');\r\n    }\r\n}\r\nconst CSSESC_QUOTE_OPTIONS = {\r\n    \"'\": { quotes: 'single', wrap: true },\r\n    '\"': { quotes: 'double', wrap: true },\r\n    [null]: { isIdentifier: true },\r\n};\r\nfunction defaultAttrConcat(attrValue, attrSpaces) {\r\n    return `${attrSpaces.before}${attrValue}${attrSpaces.after}`;\r\n}\r\n", "import Namespace from './namespace';\r\nimport { UNIVERSAL } from './types';\r\nexport default class Universal extends Namespace {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = UNIVERSAL;\r\n        this.value = '*';\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { COMBINATOR } from './types';\r\nexport default class Combinator extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = COMBINATOR;\r\n    }\r\n}\r\n", "import Node from './node';\r\nimport { NESTING } from './types';\r\nexport default class Nesting extends Node {\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.type = NESTING;\r\n        this.value = '&';\r\n    }\r\n}\r\n", "export default function sortAscending(list) {\r\n    return list.sort((a, b) => a - b);\r\n}\r\n;\r\n", "export const ampersand = 38; // `&`.charCodeAt(0);\r\nexport const asterisk = 42; // `*`.charCodeAt(0);\r\nexport const at = 64; // `@`.charCodeAt(0);\r\nexport const comma = 44; // `,`.charCodeAt(0);\r\nexport const colon = 58; // `:`.charCodeAt(0);\r\nexport const semicolon = 59; // `;`.charCodeAt(0);\r\nexport const openParenthesis = 40; // `(`.charCodeAt(0);\r\nexport const closeParenthesis = 41; // `)`.charCodeAt(0);\r\nexport const openSquare = 91; // `[`.charCodeAt(0);\r\nexport const closeSquare = 93; // `]`.charCodeAt(0);\r\nexport const dollar = 36; // `$`.charCodeAt(0);\r\nexport const tilde = 126; // `~`.charCodeAt(0);\r\nexport const caret = 94; // `^`.charCodeAt(0);\r\nexport const plus = 43; // `+`.charCodeAt(0);\r\nexport const equals = 61; // `=`.charCodeAt(0);\r\nexport const pipe = 124; // `|`.charCodeAt(0);\r\nexport const greaterThan = 62; // `>`.charCodeAt(0);\r\nexport const space = 32; // ` `.charCodeAt(0);\r\nexport const singleQuote = 39; // `'`.charCodeAt(0);\r\nexport const doubleQuote = 34; // `\"`.charCodeAt(0);\r\nexport const slash = 47; // `/`.charCodeAt(0);\r\nexport const bang = 33; // `!`.charCodeAt(0);\r\nexport const backslash = 92; // '\\\\'.charCodeAt(0);\r\nexport const cr = 13; // '\\r'.charCodeAt(0);\r\nexport const feed = 12; // '\\f'.charCodeAt(0);\r\nexport const newline = 10; // '\\n'.charCodeAt(0);\r\nexport const tab = 9; // '\\t'.charCodeAt(0);\r\n// Expose aliases primarily for readability.\r\nexport const str = singleQuote;\r\n// No good single character representation!\r\nexport const comment = -1;\r\nexport const word = -2;\r\nexport const combinator = -3;\r\n", "import * as t from './tokenTypes';\r\nconst unescapable = {\r\n    [t.tab]: true,\r\n    [t.newline]: true,\r\n    [t.cr]: true,\r\n    [t.feed]: true,\r\n};\r\nconst wordDelimiters = {\r\n    [t.space]: true,\r\n    [t.tab]: true,\r\n    [t.newline]: true,\r\n    [t.cr]: true,\r\n    [t.feed]: true,\r\n    [t.ampersand]: true,\r\n    [t.asterisk]: true,\r\n    [t.bang]: true,\r\n    [t.comma]: true,\r\n    [t.colon]: true,\r\n    [t.semicolon]: true,\r\n    [t.openParenthesis]: true,\r\n    [t.closeParenthesis]: true,\r\n    [t.openSquare]: true,\r\n    [t.closeSquare]: true,\r\n    [t.singleQuote]: true,\r\n    [t.doubleQuote]: true,\r\n    [t.plus]: true,\r\n    [t.pipe]: true,\r\n    [t.tilde]: true,\r\n    [t.greaterThan]: true,\r\n    [t.equals]: true,\r\n    [t.dollar]: true,\r\n    [t.caret]: true,\r\n    [t.slash]: true,\r\n};\r\nconst hex = {};\r\nconst hexChars = \"0123456789abcdefABCDEF\";\r\nfor (let i = 0; i < hexChars.length; i++) {\r\n    hex[hexChars.charCodeAt(i)] = true;\r\n}\r\n/**\r\n *  Returns the last index of the bar css word\r\n * @param {string} css The string in which the word begins\r\n * @param {number} start The index into the string where word's first letter occurs\r\n */\r\nfunction consumeWord(css, start) {\r\n    let next = start;\r\n    let code;\r\n    do {\r\n        code = css.charCodeAt(next);\r\n        if (wordDelimiters[code]) {\r\n            return next - 1;\r\n        }\r\n        else if (code === t.backslash) {\r\n            next = consumeEscape(css, next) + 1;\r\n        }\r\n        else {\r\n            // All other characters are part of the word\r\n            next++;\r\n        }\r\n    } while (next < css.length);\r\n    return next - 1;\r\n}\r\n/**\r\n *  Returns the last index of the escape sequence\r\n * @param {string} css The string in which the sequence begins\r\n * @param {number} start The index into the string where escape character (`\\`) occurs.\r\n */\r\nfunction consumeEscape(css, start) {\r\n    let next = start;\r\n    let code = css.charCodeAt(next + 1);\r\n    if (unescapable[code]) {\r\n        // just consume the escape char\r\n    }\r\n    else if (hex[code]) {\r\n        let hexDigits = 0;\r\n        // consume up to 6 hex chars\r\n        do {\r\n            next++;\r\n            hexDigits++;\r\n            code = css.charCodeAt(next + 1);\r\n        } while (hex[code] && hexDigits < 6);\r\n        // if fewer than 6 hex chars, a trailing space ends the escape\r\n        if (hexDigits < 6 && code === t.space) {\r\n            next++;\r\n        }\r\n    }\r\n    else {\r\n        // the next char is part of the current word\r\n        next++;\r\n    }\r\n    return next;\r\n}\r\nexport const FIELDS = {\r\n    TYPE: 0,\r\n    START_LINE: 1,\r\n    START_COL: 2,\r\n    END_LINE: 3,\r\n    END_COL: 4,\r\n    START_POS: 5,\r\n    END_POS: 6,\r\n};\r\nexport default function tokenize(input) {\r\n    const tokens = [];\r\n    let css = input.css.valueOf();\r\n    let { length } = css;\r\n    let offset = -1;\r\n    let line = 1;\r\n    let start = 0;\r\n    let end = 0;\r\n    let code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\r\n    function unclosed(what, fix) {\r\n        if (input.safe) { // fyi: this is never set to true.\r\n            css += fix;\r\n            next = css.length - 1;\r\n        }\r\n        else {\r\n            throw input.error('Unclosed ' + what, line, start - offset, start);\r\n        }\r\n    }\r\n    while (start < length) {\r\n        code = css.charCodeAt(start);\r\n        if (code === t.newline) {\r\n            offset = start;\r\n            line += 1;\r\n        }\r\n        switch (code) {\r\n            case t.space:\r\n            case t.tab:\r\n            case t.newline:\r\n            case t.cr:\r\n            case t.feed:\r\n                next = start;\r\n                do {\r\n                    next += 1;\r\n                    code = css.charCodeAt(next);\r\n                    if (code === t.newline) {\r\n                        offset = next;\r\n                        line += 1;\r\n                    }\r\n                } while (code === t.space ||\r\n                    code === t.newline ||\r\n                    code === t.tab ||\r\n                    code === t.cr ||\r\n                    code === t.feed);\r\n                tokenType = t.space;\r\n                endLine = line;\r\n                endColumn = next - offset - 1;\r\n                end = next;\r\n                break;\r\n            case t.plus:\r\n            case t.greaterThan:\r\n            case t.tilde:\r\n            case t.pipe:\r\n                next = start;\r\n                do {\r\n                    next += 1;\r\n                    code = css.charCodeAt(next);\r\n                } while (code === t.plus ||\r\n                    code === t.greaterThan ||\r\n                    code === t.tilde ||\r\n                    code === t.pipe);\r\n                tokenType = t.combinator;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next;\r\n                break;\r\n            // Consume these characters as single tokens.\r\n            case t.asterisk:\r\n            case t.ampersand:\r\n            case t.bang:\r\n            case t.comma:\r\n            case t.equals:\r\n            case t.dollar:\r\n            case t.caret:\r\n            case t.openSquare:\r\n            case t.closeSquare:\r\n            case t.colon:\r\n            case t.semicolon:\r\n            case t.openParenthesis:\r\n            case t.closeParenthesis:\r\n                next = start;\r\n                tokenType = code;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next + 1;\r\n                break;\r\n            case t.singleQuote:\r\n            case t.doubleQuote:\r\n                quote = code === t.singleQuote ? \"'\" : '\"';\r\n                next = start;\r\n                do {\r\n                    escaped = false;\r\n                    next = css.indexOf(quote, next + 1);\r\n                    if (next === -1) {\r\n                        unclosed('quote', quote);\r\n                    }\r\n                    escapePos = next;\r\n                    while (css.charCodeAt(escapePos - 1) === t.backslash) {\r\n                        escapePos -= 1;\r\n                        escaped = !escaped;\r\n                    }\r\n                } while (escaped);\r\n                tokenType = t.str;\r\n                endLine = line;\r\n                endColumn = start - offset;\r\n                end = next + 1;\r\n                break;\r\n            default:\r\n                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\r\n                    next = css.indexOf('*/', start + 2) + 1;\r\n                    if (next === 0) {\r\n                        unclosed('comment', '*/');\r\n                    }\r\n                    content = css.slice(start, next + 1);\r\n                    lines = content.split('\\n');\r\n                    last = lines.length - 1;\r\n                    if (last > 0) {\r\n                        nextLine = line + last;\r\n                        nextOffset = next - lines[last].length;\r\n                    }\r\n                    else {\r\n                        nextLine = line;\r\n                        nextOffset = offset;\r\n                    }\r\n                    tokenType = t.comment;\r\n                    line = nextLine;\r\n                    endLine = nextLine;\r\n                    endColumn = next - nextOffset;\r\n                }\r\n                else if (code === t.slash) {\r\n                    next = start;\r\n                    tokenType = code;\r\n                    endLine = line;\r\n                    endColumn = start - offset;\r\n                    end = next + 1;\r\n                }\r\n                else {\r\n                    next = consumeWord(css, start);\r\n                    tokenType = t.word;\r\n                    endLine = line;\r\n                    endColumn = next - offset;\r\n                }\r\n                end = next + 1;\r\n                break;\r\n        }\r\n        // Ensure that the token structure remains consistent\r\n        tokens.push([\r\n            tokenType, // [0] Token type\r\n            line, // [1] Starting line\r\n            start - offset, // [2] Starting column\r\n            endLine, // [3] Ending line\r\n            endColumn, // [4] Ending column\r\n            start, // [5] Start position / Source index\r\n            end, // [6] End position\r\n        ]);\r\n        // Reset offset for the next token\r\n        if (nextOffset) {\r\n            offset = nextOffset;\r\n            nextOffset = null;\r\n        }\r\n        start = end;\r\n    }\r\n    return tokens;\r\n}\r\n", "import Root from './selectors/root';\r\nimport Selector from './selectors/selector';\r\nimport ClassName from './selectors/className';\r\nimport Comment from './selectors/comment';\r\nimport ID from './selectors/id';\r\nimport Tag from './selectors/tag';\r\nimport Str from './selectors/string';\r\nimport Pseudo from './selectors/pseudo';\r\nimport Attribute, { unescapeValue } from './selectors/attribute';\r\nimport Universal from './selectors/universal';\r\nimport Combinator from './selectors/combinator';\r\nimport Nesting from './selectors/nesting';\r\nimport sortAsc from './sortAscending';\r\nimport tokenize, { FIELDS as TOKEN } from './tokenize';\r\nimport * as tokens from './tokenTypes';\r\nimport * as types from './selectors/types';\r\nimport { unesc, getProp, ensureObject } from './util';\r\nconst WHITESPACE_TOKENS = {\r\n    [tokens.space]: true,\r\n    [tokens.cr]: true,\r\n    [tokens.feed]: true,\r\n    [tokens.newline]: true,\r\n    [tokens.tab]: true,\r\n};\r\nconst WHITESPACE_EQUIV_TOKENS = {\r\n    ...WHITESPACE_TOKENS,\r\n    [tokens.comment]: true,\r\n};\r\nfunction tokenStart(token) {\r\n    return {\r\n        line: token[TOKEN.START_LINE],\r\n        column: token[TOKEN.START_COL],\r\n    };\r\n}\r\nfunction tokenEnd(token) {\r\n    return {\r\n        line: token[TOKEN.END_LINE],\r\n        column: token[TOKEN.END_COL],\r\n    };\r\n}\r\nfunction getSource(startLine, startColumn, endLine, endColumn) {\r\n    return {\r\n        start: {\r\n            line: startLine,\r\n            column: startColumn,\r\n        },\r\n        end: {\r\n            line: endLine,\r\n            column: endColumn,\r\n        },\r\n    };\r\n}\r\nfunction getTokenSource(token) {\r\n    return getSource(token[TOKEN.START_LINE], token[TOKEN.START_COL], token[TOKEN.END_LINE], token[TOKEN.END_COL]);\r\n}\r\nfunction getTokenSourceSpan(startToken, endToken) {\r\n    if (!startToken) {\r\n        return undefined;\r\n    }\r\n    return getSource(startToken[TOKEN.START_LINE], startToken[TOKEN.START_COL], endToken[TOKEN.END_LINE], endToken[TOKEN.END_COL]);\r\n}\r\nfunction unescapeProp(node, prop) {\r\n    let value = node[prop];\r\n    if (typeof value !== \"string\") {\r\n        return;\r\n    }\r\n    if (value.indexOf(\"\\\\\") !== -1) {\r\n        ensureObject(node, 'raws');\r\n        node[prop] = unesc(value);\r\n        if (node.raws[prop] === undefined) {\r\n            node.raws[prop] = value;\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction indexesOf(array, item) {\r\n    let i = -1;\r\n    const indexes = [];\r\n    while ((i = array.indexOf(item, i + 1)) !== -1) {\r\n        indexes.push(i);\r\n    }\r\n    return indexes;\r\n}\r\nfunction uniqs() {\r\n    const list = Array.prototype.concat.apply([], arguments);\r\n    return list.filter((item, i) => i === list.indexOf(item));\r\n}\r\nexport default class Parser {\r\n    constructor(rule, options = {}) {\r\n        this.rule = rule;\r\n        this.options = Object.assign({ lossy: false, safe: false }, options);\r\n        this.position = 0;\r\n        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\r\n        this.tokens = tokenize({\r\n            css: this.css,\r\n            error: this._errorGenerator(),\r\n            safe: this.options.safe,\r\n        });\r\n        let rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\r\n        this.root = new Root({ source: rootSource });\r\n        this.root.errorGenerator = this._errorGenerator();\r\n        const selector = new Selector({\r\n            source: { start: { line: 1, column: 1 } },\r\n            sourceIndex: 0,\r\n        });\r\n        this.root.append(selector);\r\n        this.current = selector;\r\n        this.loop();\r\n    }\r\n    _errorGenerator() {\r\n        return (message, errorOptions) => {\r\n            if (typeof this.rule === 'string') {\r\n                return new Error(message);\r\n            }\r\n            return this.rule.error(message, errorOptions);\r\n        };\r\n    }\r\n    attribute() {\r\n        const attr = [];\r\n        const startingToken = this.currToken;\r\n        this.position++;\r\n        while (this.position < this.tokens.length &&\r\n            this.currToken[TOKEN.TYPE] !== tokens.closeSquare) {\r\n            attr.push(this.currToken);\r\n            this.position++;\r\n        }\r\n        if (this.currToken[TOKEN.TYPE] !== tokens.closeSquare) {\r\n            return this.expected('closing square bracket', this.currToken[TOKEN.START_POS]);\r\n        }\r\n        const len = attr.length;\r\n        const node = {\r\n            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\r\n            sourceIndex: startingToken[TOKEN.START_POS],\r\n        };\r\n        if (len === 1 && !~[tokens.word].indexOf(attr[0][TOKEN.TYPE])) {\r\n            return this.expected('attribute', attr[0][TOKEN.START_POS]);\r\n        }\r\n        let pos = 0;\r\n        let spaceBefore = '';\r\n        let commentBefore = '';\r\n        let lastAdded = null;\r\n        let spaceAfterMeaningfulToken = false;\r\n        while (pos < len) {\r\n            const token = attr[pos];\r\n            const content = this.content(token);\r\n            const next = attr[pos + 1];\r\n            switch (token[TOKEN.TYPE]) {\r\n                case tokens.space:\r\n                    // if (\r\n                    //     len === 1 ||\r\n                    //     pos === 0 && this.content(next) === '|'\r\n                    // ) {\r\n                    //     return this.expected('attribute', token[TOKEN.START_POS], content);\r\n                    // }\r\n                    spaceAfterMeaningfulToken = true;\r\n                    if (this.options.lossy) {\r\n                        break;\r\n                    }\r\n                    if (lastAdded) {\r\n                        ensureObject(node, 'spaces', lastAdded);\r\n                        const prevContent = node.spaces[lastAdded].after || '';\r\n                        node.spaces[lastAdded].after = prevContent + content;\r\n                        const existingComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || null;\r\n                        if (existingComment) {\r\n                            node.raws.spaces[lastAdded].after = existingComment + content;\r\n                        }\r\n                    }\r\n                    else {\r\n                        spaceBefore = spaceBefore + content;\r\n                        commentBefore = commentBefore + content;\r\n                    }\r\n                    break;\r\n                case tokens.asterisk:\r\n                    if (next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    else if ((!node.namespace || (lastAdded === \"namespace\" && !spaceAfterMeaningfulToken)) && next) {\r\n                        if (spaceBefore) {\r\n                            ensureObject(node, 'spaces', 'attribute');\r\n                            node.spaces.attribute.before = spaceBefore;\r\n                            spaceBefore = '';\r\n                        }\r\n                        if (commentBefore) {\r\n                            ensureObject(node, 'raws', 'spaces', 'attribute');\r\n                            node.raws.spaces.attribute.before = spaceBefore;\r\n                            commentBefore = '';\r\n                        }\r\n                        node.namespace = (node.namespace || \"\") + content;\r\n                        const rawValue = getProp(node, 'raws', 'namespace') || null;\r\n                        if (rawValue) {\r\n                            node.raws.namespace += content;\r\n                        }\r\n                        lastAdded = 'namespace';\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.dollar:\r\n                    if (lastAdded === \"value\") {\r\n                        let oldRawValue = getProp(node, 'raws', 'value');\r\n                        node.value += \"$\";\r\n                        if (oldRawValue) {\r\n                            node.raws.value = oldRawValue + \"$\";\r\n                        }\r\n                        break;\r\n                    }\r\n                // Falls through\r\n                case tokens.caret:\r\n                    if (next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.combinator:\r\n                    if (content === '~' && next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    if (content !== '|') {\r\n                        spaceAfterMeaningfulToken = false;\r\n                        break;\r\n                    }\r\n                    if (next[TOKEN.TYPE] === tokens.equals) {\r\n                        node.operator = content;\r\n                        lastAdded = 'operator';\r\n                    }\r\n                    else if (!node.namespace && !node.attribute) {\r\n                        node.namespace = true;\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.word:\r\n                    if (next &&\r\n                        this.content(next) === '|' &&\r\n                        (attr[pos + 2] && attr[pos + 2][TOKEN.TYPE] !== tokens.equals) && // this look-ahead probably fails with comment nodes involved.\r\n                        !node.operator &&\r\n                        !node.namespace) {\r\n                        node.namespace = content;\r\n                        lastAdded = 'namespace';\r\n                    }\r\n                    else if (!node.attribute || (lastAdded === \"attribute\" && !spaceAfterMeaningfulToken)) {\r\n                        if (spaceBefore) {\r\n                            ensureObject(node, 'spaces', 'attribute');\r\n                            node.spaces.attribute.before = spaceBefore;\r\n                            spaceBefore = '';\r\n                        }\r\n                        if (commentBefore) {\r\n                            ensureObject(node, 'raws', 'spaces', 'attribute');\r\n                            node.raws.spaces.attribute.before = commentBefore;\r\n                            commentBefore = '';\r\n                        }\r\n                        node.attribute = (node.attribute || \"\") + content;\r\n                        const rawValue = getProp(node, 'raws', 'attribute') || null;\r\n                        if (rawValue) {\r\n                            node.raws.attribute += content;\r\n                        }\r\n                        lastAdded = 'attribute';\r\n                    }\r\n                    else if ((!node.value && node.value !== \"\") || (lastAdded === \"value\" && !(spaceAfterMeaningfulToken || node.quoteMark))) {\r\n                        let unescaped = unesc(content);\r\n                        let oldRawValue = getProp(node, 'raws', 'value') || '';\r\n                        let oldValue = node.value || '';\r\n                        node.value = oldValue + unescaped;\r\n                        node.quoteMark = null;\r\n                        if (unescaped !== content || oldRawValue) {\r\n                            ensureObject(node, 'raws');\r\n                            node.raws.value = (oldRawValue || oldValue) + content;\r\n                        }\r\n                        lastAdded = 'value';\r\n                    }\r\n                    else {\r\n                        let insensitive = (content === 'i' || content === \"I\");\r\n                        if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\r\n                            node.insensitive = insensitive;\r\n                            if (!insensitive || content === \"I\") {\r\n                                ensureObject(node, 'raws');\r\n                                node.raws.insensitiveFlag = content;\r\n                            }\r\n                            lastAdded = 'insensitive';\r\n                            if (spaceBefore) {\r\n                                ensureObject(node, 'spaces', 'insensitive');\r\n                                node.spaces.insensitive.before = spaceBefore;\r\n                                spaceBefore = '';\r\n                            }\r\n                            if (commentBefore) {\r\n                                ensureObject(node, 'raws', 'spaces', 'insensitive');\r\n                                node.raws.spaces.insensitive.before = commentBefore;\r\n                                commentBefore = '';\r\n                            }\r\n                        }\r\n                        else if (node.value || node.value === '') {\r\n                            lastAdded = 'value';\r\n                            node.value += content;\r\n                            if (node.raws.value) {\r\n                                node.raws.value += content;\r\n                            }\r\n                        }\r\n                    }\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.str:\r\n                    if (!node.attribute || !node.operator) {\r\n                        return this.error(`Expected an attribute followed by an operator preceding the string.`, {\r\n                            index: token[TOKEN.START_POS],\r\n                        });\r\n                    }\r\n                    let { unescaped, quoteMark } = unescapeValue(content);\r\n                    node.value = unescaped;\r\n                    node.quoteMark = quoteMark;\r\n                    lastAdded = 'value';\r\n                    ensureObject(node, 'raws');\r\n                    node.raws.value = content;\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.equals:\r\n                    if (!node.attribute) {\r\n                        return this.expected('attribute', token[TOKEN.START_POS], content);\r\n                    }\r\n                    if (node.value) {\r\n                        return this.error('Unexpected \"=\" found; an operator was already defined.', { index: token[TOKEN.START_POS] });\r\n                    }\r\n                    node.operator = node.operator ? node.operator + content : content;\r\n                    lastAdded = 'operator';\r\n                    spaceAfterMeaningfulToken = false;\r\n                    break;\r\n                case tokens.comment:\r\n                    if (lastAdded) {\r\n                        if (spaceAfterMeaningfulToken || (next && next[TOKEN.TYPE] === tokens.space) ||\r\n                            lastAdded === 'insensitive') {\r\n                            const lastComment = getProp(node, 'spaces', lastAdded, 'after') || '';\r\n                            const rawLastComment = getProp(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\r\n                            ensureObject(node, 'raws', 'spaces', lastAdded);\r\n                            node.raws.spaces[lastAdded].after = rawLastComment + content;\r\n                        }\r\n                        else {\r\n                            const lastValue = node[lastAdded] || '';\r\n                            const rawLastValue = getProp(node, 'raws', lastAdded) || lastValue;\r\n                            ensureObject(node, 'raws');\r\n                            node.raws[lastAdded] = rawLastValue + content;\r\n                        }\r\n                    }\r\n                    else {\r\n                        commentBefore = commentBefore + content;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return this.error(`Unexpected \"${content}\" found.`, { index: token[TOKEN.START_POS] });\r\n            }\r\n            pos++;\r\n        }\r\n        unescapeProp(node, \"attribute\");\r\n        unescapeProp(node, \"namespace\");\r\n        this.newNode(new Attribute(node));\r\n        this.position++;\r\n    }\r\n    /**\r\n     * return a node containing meaningless garbage up to (but not including) the specified token position.\r\n     * if the token position is negative, all remaining tokens are consumed.\r\n     *\r\n     * This returns an array containing a single string node if all whitespace,\r\n     * otherwise an array of comment nodes with space before and after.\r\n     *\r\n     * These tokens are not added to the current selector, the caller can add them or use them to amend\r\n     * a previous node's space metadata.\r\n     *\r\n     * In lossy mode, this returns only comments.\r\n     */\r\n    parseWhitespaceEquivalentTokens(stopPosition) {\r\n        if (stopPosition < 0) {\r\n            stopPosition = this.tokens.length;\r\n        }\r\n        let startPosition = this.position;\r\n        let nodes = [];\r\n        let space = \"\";\r\n        let lastComment = undefined;\r\n        do {\r\n            if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\r\n                if (!this.options.lossy) {\r\n                    space += this.content();\r\n                }\r\n            }\r\n            else if (this.currToken[TOKEN.TYPE] === tokens.comment) {\r\n                let spaces = {};\r\n                if (space) {\r\n                    spaces.before = space;\r\n                    space = \"\";\r\n                }\r\n                lastComment = new Comment({\r\n                    value: this.content(),\r\n                    source: getTokenSource(this.currToken),\r\n                    sourceIndex: this.currToken[TOKEN.START_POS],\r\n                    spaces,\r\n                });\r\n                nodes.push(lastComment);\r\n            }\r\n        } while (++this.position < stopPosition);\r\n        if (space) {\r\n            if (lastComment) {\r\n                lastComment.spaces.after = space;\r\n            }\r\n            else if (!this.options.lossy) {\r\n                let firstToken = this.tokens[startPosition];\r\n                let lastToken = this.tokens[this.position - 1];\r\n                nodes.push(new Str({\r\n                    value: '',\r\n                    source: getSource(firstToken[TOKEN.START_LINE], firstToken[TOKEN.START_COL], lastToken[TOKEN.END_LINE], lastToken[TOKEN.END_COL]),\r\n                    sourceIndex: firstToken[TOKEN.START_POS],\r\n                    spaces: { before: space, after: '' },\r\n                }));\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n    /**\r\n     *\r\n     * @param {*} nodes\r\n     */\r\n    convertWhitespaceNodesToSpace(nodes, requiredSpace = false) {\r\n        let space = \"\";\r\n        let rawSpace = \"\";\r\n        nodes.forEach(n => {\r\n            let spaceBefore = this.lossySpace(n.spaces.before, requiredSpace);\r\n            let rawSpaceBefore = this.lossySpace(n.rawSpaceBefore, requiredSpace);\r\n            space += spaceBefore + this.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\r\n            rawSpace += spaceBefore + n.value + this.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\r\n        });\r\n        if (rawSpace === space) {\r\n            rawSpace = undefined;\r\n        }\r\n        let result = { space, rawSpace };\r\n        return result;\r\n    }\r\n    isNamedCombinator(position = this.position) {\r\n        return this.tokens[position + 0] && this.tokens[position + 0][TOKEN.TYPE] === tokens.slash &&\r\n            this.tokens[position + 1] && this.tokens[position + 1][TOKEN.TYPE] === tokens.word &&\r\n            this.tokens[position + 2] && this.tokens[position + 2][TOKEN.TYPE] === tokens.slash;\r\n    }\r\n    namedCombinator() {\r\n        if (this.isNamedCombinator()) {\r\n            let nameRaw = this.content(this.tokens[this.position + 1]);\r\n            let name = unesc(nameRaw).toLowerCase();\r\n            let raws = {};\r\n            if (name !== nameRaw) {\r\n                raws.value = `/${nameRaw}/`;\r\n            }\r\n            let node = new Combinator({\r\n                value: `/${name}/`,\r\n                source: getSource(this.currToken[TOKEN.START_LINE], this.currToken[TOKEN.START_COL], this.tokens[this.position + 2][TOKEN.END_LINE], this.tokens[this.position + 2][TOKEN.END_COL]),\r\n                sourceIndex: this.currToken[TOKEN.START_POS],\r\n                raws,\r\n            });\r\n            this.position = this.position + 3;\r\n            return node;\r\n        }\r\n        else {\r\n            this.unexpected();\r\n        }\r\n    }\r\n    combinator() {\r\n        if (this.content() === '|') {\r\n            return this.namespace();\r\n        }\r\n        // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\r\n        let nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\r\n        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][TOKEN.TYPE] === tokens.closeParenthesis) {\r\n            let nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\r\n            if (nodes.length > 0) {\r\n                let last = this.current.last;\r\n                if (last) {\r\n                    let { space, rawSpace } = this.convertWhitespaceNodesToSpace(nodes);\r\n                    if (rawSpace !== undefined) {\r\n                        last.rawSpaceAfter += rawSpace;\r\n                    }\r\n                    last.spaces.after += space;\r\n                }\r\n                else {\r\n                    nodes.forEach(n => this.newNode(n));\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        let firstToken = this.currToken;\r\n        let spaceOrDescendantSelectorNodes = undefined;\r\n        if (nextSigTokenPos > this.position) {\r\n            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\r\n        }\r\n        let node;\r\n        if (this.isNamedCombinator()) {\r\n            node = this.namedCombinator();\r\n        }\r\n        else if (this.currToken[TOKEN.TYPE] === tokens.combinator) {\r\n            node = new Combinator({\r\n                value: this.content(),\r\n                source: getTokenSource(this.currToken),\r\n                sourceIndex: this.currToken[TOKEN.START_POS],\r\n            });\r\n            this.position++;\r\n        }\r\n        else if (WHITESPACE_TOKENS[this.currToken[TOKEN.TYPE]]) {\r\n            // pass\r\n        }\r\n        else if (!spaceOrDescendantSelectorNodes) {\r\n            this.unexpected();\r\n        }\r\n        if (node) {\r\n            if (spaceOrDescendantSelectorNodes) {\r\n                let { space, rawSpace } = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes);\r\n                node.spaces.before = space;\r\n                node.rawSpaceBefore = rawSpace;\r\n            }\r\n        }\r\n        else {\r\n            // descendant combinator\r\n            let { space, rawSpace } = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true);\r\n            if (!rawSpace) {\r\n                rawSpace = space;\r\n            }\r\n            let spaces = {};\r\n            let raws = { spaces: {} };\r\n            if (space.endsWith(' ') && rawSpace.endsWith(' ')) {\r\n                spaces.before = space.slice(0, space.length - 1);\r\n                raws.spaces.before = rawSpace.slice(0, rawSpace.length - 1);\r\n            }\r\n            else if (space.startsWith(' ') && rawSpace.startsWith(' ')) {\r\n                spaces.after = space.slice(1);\r\n                raws.spaces.after = rawSpace.slice(1);\r\n            }\r\n            else {\r\n                raws.value = rawSpace;\r\n            }\r\n            node = new Combinator({\r\n                value: ' ',\r\n                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\r\n                sourceIndex: firstToken[TOKEN.START_POS],\r\n                spaces,\r\n                raws,\r\n            });\r\n        }\r\n        if (this.currToken && this.currToken[TOKEN.TYPE] === tokens.space) {\r\n            node.spaces.after = this.optionalSpace(this.content());\r\n            this.position++;\r\n        }\r\n        return this.newNode(node);\r\n    }\r\n    comma() {\r\n        if (this.position === this.tokens.length - 1) {\r\n            this.root.trailingComma = true;\r\n            this.position++;\r\n            return;\r\n        }\r\n        this.current._inferEndPosition();\r\n        const selector = new Selector({\r\n            source: {\r\n                start: tokenStart(this.tokens[this.position + 1]),\r\n            },\r\n            sourceIndex: this.tokens[this.position + 1][TOKEN.START_POS],\r\n        });\r\n        this.current.parent.append(selector);\r\n        this.current = selector;\r\n        this.position++;\r\n    }\r\n    comment() {\r\n        const current = this.currToken;\r\n        this.newNode(new Comment({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }));\r\n        this.position++;\r\n    }\r\n    error(message, opts) {\r\n        throw this.root.error(message, opts);\r\n    }\r\n    missingBackslash() {\r\n        return this.error('Expected a backslash preceding the semicolon.', {\r\n            index: this.currToken[TOKEN.START_POS],\r\n        });\r\n    }\r\n    missingParenthesis() {\r\n        return this.expected('opening parenthesis', this.currToken[TOKEN.START_POS]);\r\n    }\r\n    missingSquareBracket() {\r\n        return this.expected('opening square bracket', this.currToken[TOKEN.START_POS]);\r\n    }\r\n    unexpected() {\r\n        return this.error(`Unexpected '${this.content()}'. Escaping special characters with \\\\ may help.`, this.currToken[TOKEN.START_POS]);\r\n    }\r\n    unexpectedPipe() {\r\n        return this.error(`Unexpected '|'.`, this.currToken[TOKEN.START_POS]);\r\n    }\r\n    namespace() {\r\n        const before = this.prevToken && this.content(this.prevToken) || true;\r\n        if (this.nextToken[TOKEN.TYPE] === tokens.word) {\r\n            this.position++;\r\n            return this.word(before);\r\n        }\r\n        else if (this.nextToken[TOKEN.TYPE] === tokens.asterisk) {\r\n            this.position++;\r\n            return this.universal(before);\r\n        }\r\n        this.unexpectedPipe();\r\n    }\r\n    nesting() {\r\n        if (this.nextToken) {\r\n            let nextContent = this.content(this.nextToken);\r\n            if (nextContent === \"|\") {\r\n                this.position++;\r\n                return;\r\n            }\r\n        }\r\n        const current = this.currToken;\r\n        this.newNode(new Nesting({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }));\r\n        this.position++;\r\n    }\r\n    parentheses() {\r\n        let last = this.current.last;\r\n        let unbalanced = 1;\r\n        this.position++;\r\n        if (last && last.type === types.PSEUDO) {\r\n            const selector = new Selector({\r\n                source: { start: tokenStart(this.tokens[this.position]) },\r\n                sourceIndex: this.tokens[this.position][TOKEN.START_POS],\r\n            });\r\n            const cache = this.current;\r\n            last.append(selector);\r\n            this.current = selector;\r\n            while (this.position < this.tokens.length && unbalanced) {\r\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\r\n                    unbalanced++;\r\n                }\r\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\r\n                    unbalanced--;\r\n                }\r\n                if (unbalanced) {\r\n                    this.parse();\r\n                }\r\n                else {\r\n                    this.current.source.end = tokenEnd(this.currToken);\r\n                    this.current.parent.source.end = tokenEnd(this.currToken);\r\n                    this.position++;\r\n                }\r\n            }\r\n            this.current = cache;\r\n        }\r\n        else {\r\n            // I think this case should be an error. It's used to implement a basic parse of media queries\r\n            // but I don't think it's a good idea.\r\n            let parenStart = this.currToken;\r\n            let parenValue = \"(\";\r\n            let parenEnd;\r\n            while (this.position < this.tokens.length && unbalanced) {\r\n                if (this.currToken[TOKEN.TYPE] === tokens.openParenthesis) {\r\n                    unbalanced++;\r\n                }\r\n                if (this.currToken[TOKEN.TYPE] === tokens.closeParenthesis) {\r\n                    unbalanced--;\r\n                }\r\n                parenEnd = this.currToken;\r\n                parenValue += this.parseParenthesisToken(this.currToken);\r\n                this.position++;\r\n            }\r\n            if (last) {\r\n                last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\r\n            }\r\n            else {\r\n                this.newNode(new Str({\r\n                    value: parenValue,\r\n                    source: getSource(parenStart[TOKEN.START_LINE], parenStart[TOKEN.START_COL], parenEnd[TOKEN.END_LINE], parenEnd[TOKEN.END_COL]),\r\n                    sourceIndex: parenStart[TOKEN.START_POS],\r\n                }));\r\n            }\r\n        }\r\n        if (unbalanced) {\r\n            return this.expected('closing parenthesis', this.currToken[TOKEN.START_POS]);\r\n        }\r\n    }\r\n    pseudo() {\r\n        let pseudoStr = '';\r\n        let startingToken = this.currToken;\r\n        while (this.currToken && this.currToken[TOKEN.TYPE] === tokens.colon) {\r\n            pseudoStr += this.content();\r\n            this.position++;\r\n        }\r\n        if (!this.currToken) {\r\n            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\r\n        }\r\n        if (this.currToken[TOKEN.TYPE] === tokens.word) {\r\n            this.splitWord(false, (first, length) => {\r\n                pseudoStr += first;\r\n                this.newNode(new Pseudo({\r\n                    value: pseudoStr,\r\n                    source: getTokenSourceSpan(startingToken, this.currToken),\r\n                    sourceIndex: startingToken[TOKEN.START_POS],\r\n                }));\r\n                if (length > 1 &&\r\n                    this.nextToken &&\r\n                    this.nextToken[TOKEN.TYPE] === tokens.openParenthesis) {\r\n                    this.error('Misplaced parenthesis.', {\r\n                        index: this.nextToken[TOKEN.START_POS],\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[TOKEN.START_POS]);\r\n        }\r\n    }\r\n    space() {\r\n        const content = this.content();\r\n        // Handle space before and after the selector\r\n        if (this.position === 0 ||\r\n            this.prevToken[TOKEN.TYPE] === tokens.comma ||\r\n            this.prevToken[TOKEN.TYPE] === tokens.openParenthesis ||\r\n            (this.current.nodes.every((node) => node.type === 'comment'))) {\r\n            this.spaces = this.optionalSpace(content);\r\n            this.position++;\r\n        }\r\n        else if (this.position === (this.tokens.length - 1) ||\r\n            this.nextToken[TOKEN.TYPE] === tokens.comma ||\r\n            this.nextToken[TOKEN.TYPE] === tokens.closeParenthesis) {\r\n            this.current.last.spaces.after = this.optionalSpace(content);\r\n            this.position++;\r\n        }\r\n        else {\r\n            this.combinator();\r\n        }\r\n    }\r\n    string() {\r\n        const current = this.currToken;\r\n        this.newNode(new Str({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }));\r\n        this.position++;\r\n    }\r\n    universal(namespace) {\r\n        const nextToken = this.nextToken;\r\n        if (nextToken && this.content(nextToken) === '|') {\r\n            this.position++;\r\n            return this.namespace();\r\n        }\r\n        const current = this.currToken;\r\n        this.newNode(new Universal({\r\n            value: this.content(),\r\n            source: getTokenSource(current),\r\n            sourceIndex: current[TOKEN.START_POS],\r\n        }), namespace);\r\n        this.position++;\r\n    }\r\n    splitWord(namespace, firstCallback) {\r\n        let nextToken = this.nextToken;\r\n        let word = this.content();\r\n        while (nextToken &&\r\n            ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[TOKEN.TYPE])) {\r\n            this.position++;\r\n            let current = this.content();\r\n            word += current;\r\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\r\n                let next = this.nextToken;\r\n                if (next && next[TOKEN.TYPE] === tokens.space) {\r\n                    word += this.requiredSpace(this.content(next));\r\n                    this.position++;\r\n                }\r\n            }\r\n            nextToken = this.nextToken;\r\n        }\r\n        const hasClass = indexesOf(word, '.').filter(i => {\r\n            // Allow escaped dot within class name\r\n            const escapedDot = word[i - 1] === '\\\\';\r\n            // Allow decimal numbers percent in @keyframes\r\n            const isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\r\n            return !escapedDot && !isKeyframesPercent;\r\n        });\r\n        let hasId = indexesOf(word, '#').filter(i => word[i - 1] !== '\\\\');\r\n        // Eliminate Sass interpolations from the list of id indexes\r\n        const interpolations = indexesOf(word, '#{');\r\n        if (interpolations.length) {\r\n            hasId = hasId.filter(hashIndex => !~interpolations.indexOf(hashIndex));\r\n        }\r\n        let indices = sortAsc(uniqs([0, ...hasClass, ...hasId]));\r\n        indices.forEach((ind, i) => {\r\n            const index = indices[i + 1] || word.length;\r\n            const value = word.slice(ind, index);\r\n            if (i === 0 && firstCallback) {\r\n                return firstCallback.call(this, value, indices.length);\r\n            }\r\n            let node;\r\n            const current = this.currToken;\r\n            const sourceIndex = current[TOKEN.START_POS] + indices[i];\r\n            const source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\r\n            if (~hasClass.indexOf(ind)) {\r\n                let classNameOpts = {\r\n                    value: value.slice(1),\r\n                    source,\r\n                    sourceIndex,\r\n                };\r\n                node = new ClassName(unescapeProp(classNameOpts, \"value\"));\r\n            }\r\n            else if (~hasId.indexOf(ind)) {\r\n                let idOpts = {\r\n                    value: value.slice(1),\r\n                    source,\r\n                    sourceIndex,\r\n                };\r\n                node = new ID(unescapeProp(idOpts, \"value\"));\r\n            }\r\n            else {\r\n                let tagOpts = {\r\n                    value,\r\n                    source,\r\n                    sourceIndex,\r\n                };\r\n                unescapeProp(tagOpts, \"value\");\r\n                node = new Tag(tagOpts);\r\n            }\r\n            this.newNode(node, namespace);\r\n            // Ensure that the namespace is used only once\r\n            namespace = null;\r\n        });\r\n        this.position++;\r\n    }\r\n    word(namespace) {\r\n        const nextToken = this.nextToken;\r\n        if (nextToken && this.content(nextToken) === '|') {\r\n            this.position++;\r\n            return this.namespace();\r\n        }\r\n        return this.splitWord(namespace);\r\n    }\r\n    loop() {\r\n        while (this.position < this.tokens.length) {\r\n            this.parse(true);\r\n        }\r\n        this.current._inferEndPosition();\r\n        return this.root;\r\n    }\r\n    parse(throwOnParenthesis) {\r\n        switch (this.currToken[TOKEN.TYPE]) {\r\n            case tokens.space:\r\n                this.space();\r\n                break;\r\n            case tokens.comment:\r\n                this.comment();\r\n                break;\r\n            case tokens.openParenthesis:\r\n                this.parentheses();\r\n                break;\r\n            case tokens.closeParenthesis:\r\n                if (throwOnParenthesis) {\r\n                    this.missingParenthesis();\r\n                }\r\n                break;\r\n            case tokens.openSquare:\r\n                this.attribute();\r\n                break;\r\n            case tokens.dollar:\r\n            case tokens.caret:\r\n            case tokens.equals:\r\n            case tokens.word:\r\n                this.word();\r\n                break;\r\n            case tokens.colon:\r\n                this.pseudo();\r\n                break;\r\n            case tokens.comma:\r\n                this.comma();\r\n                break;\r\n            case tokens.asterisk:\r\n                this.universal();\r\n                break;\r\n            case tokens.ampersand:\r\n                this.nesting();\r\n                break;\r\n            case tokens.slash:\r\n            case tokens.combinator:\r\n                this.combinator();\r\n                break;\r\n            case tokens.str:\r\n                this.string();\r\n                break;\r\n            // These cases throw; no break needed.\r\n            case tokens.closeSquare:\r\n                this.missingSquareBracket();\r\n            case tokens.semicolon:\r\n                this.missingBackslash();\r\n            default:\r\n                this.unexpected();\r\n        }\r\n    }\r\n    /**\r\n     * Helpers\r\n     */\r\n    expected(description, index, found) {\r\n        if (Array.isArray(description)) {\r\n            const last = description.pop();\r\n            description = `${description.join(', ')} or ${last}`;\r\n        }\r\n        const an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\r\n        if (!found) {\r\n            return this.error(`Expected ${an} ${description}.`, { index });\r\n        }\r\n        return this.error(`Expected ${an} ${description}, found \"${found}\" instead.`, { index });\r\n    }\r\n    requiredSpace(space) {\r\n        return this.options.lossy ? ' ' : space;\r\n    }\r\n    optionalSpace(space) {\r\n        return this.options.lossy ? '' : space;\r\n    }\r\n    lossySpace(space, required) {\r\n        if (this.options.lossy) {\r\n            return required ? ' ' : '';\r\n        }\r\n        else {\r\n            return space;\r\n        }\r\n    }\r\n    parseParenthesisToken(token) {\r\n        const content = this.content(token);\r\n        if (token[TOKEN.TYPE] === tokens.space) {\r\n            return this.requiredSpace(content);\r\n        }\r\n        else {\r\n            return content;\r\n        }\r\n    }\r\n    newNode(node, namespace) {\r\n        if (namespace) {\r\n            if (/^ +$/.test(namespace)) {\r\n                if (!this.options.lossy) {\r\n                    this.spaces = (this.spaces || '') + namespace;\r\n                }\r\n                namespace = true;\r\n            }\r\n            node.namespace = namespace;\r\n            unescapeProp(node, \"namespace\");\r\n        }\r\n        if (this.spaces) {\r\n            node.spaces.before = this.spaces;\r\n            this.spaces = '';\r\n        }\r\n        return this.current.append(node);\r\n    }\r\n    content(token = this.currToken) {\r\n        return this.css.slice(token[TOKEN.START_POS], token[TOKEN.END_POS]);\r\n    }\r\n    get currToken() {\r\n        return this.tokens[this.position];\r\n    }\r\n    get nextToken() {\r\n        return this.tokens[this.position + 1];\r\n    }\r\n    get prevToken() {\r\n        return this.tokens[this.position - 1];\r\n    }\r\n    /**\r\n     * returns the index of the next non-whitespace, non-comment token.\r\n     * returns -1 if no meaningful token is found.\r\n     */\r\n    locateNextMeaningfulToken(startPosition = this.position + 1) {\r\n        let searchPosition = startPosition;\r\n        while (searchPosition < this.tokens.length) {\r\n            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][TOKEN.TYPE]]) {\r\n                searchPosition++;\r\n                continue;\r\n            }\r\n            else {\r\n                return searchPosition;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n", "import Parser from './parser';\r\nexport default class Processor {\r\n    constructor(func, options) {\r\n        this.func = func || function noop() { };\r\n        this.funcRes = null;\r\n        this.options = options;\r\n    }\r\n    _shouldUpdateSelector(rule, options = {}) {\r\n        let merged = Object.assign({}, this.options, options);\r\n        if (merged.updateSelector === false) {\r\n            return false;\r\n        }\r\n        else {\r\n            return typeof rule !== \"string\";\r\n        }\r\n    }\r\n    _isLossy(options = {}) {\r\n        let merged = Object.assign({}, this.options, options);\r\n        if (merged.lossless === false) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    _root(rule, options = {}) {\r\n        let parser = new Parser(rule, this._parseOptions(options));\r\n        return parser.root;\r\n    }\r\n    _parseOptions(options) {\r\n        return {\r\n            lossy: this._isLossy(options),\r\n        };\r\n    }\r\n    _run(rule, options = {}) {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                let root = this._root(rule, options);\r\n                Promise.resolve(this.func(root)).then(transform => {\r\n                    let string = undefined;\r\n                    if (this._shouldUpdateSelector(rule, options)) {\r\n                        string = root.toString();\r\n                        rule.selector = string;\r\n                    }\r\n                    return { transform, root, string };\r\n                }).then(resolve, reject);\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    _runSync(rule, options = {}) {\r\n        let root = this._root(rule, options);\r\n        let transform = this.func(root);\r\n        if (transform && typeof transform.then === \"function\") {\r\n            throw new Error(\"Selector processor returned a promise to a synchronous call.\");\r\n        }\r\n        let string = undefined;\r\n        if (options.updateSelector && typeof rule !== \"string\") {\r\n            string = root.toString();\r\n            rule.selector = string;\r\n        }\r\n        return { transform, root, string };\r\n    }\r\n    /**\r\n     * Process rule into a selector AST.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {Promise<parser.Root>} The AST of the selector after processing it.\r\n     */\r\n    ast(rule, options) {\r\n        return this._run(rule, options).then(result => result.root);\r\n    }\r\n    /**\r\n     * Process rule into a selector AST synchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {parser.Root} The AST of the selector after processing it.\r\n     */\r\n    astSync(rule, options) {\r\n        return this._runSync(rule, options).root;\r\n    }\r\n    /**\r\n     * Process a selector into a transformed value asynchronously\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {Promise<any>} The value returned by the processor.\r\n     */\r\n    transform(rule, options) {\r\n        return this._run(rule, options).then(result => result.transform);\r\n    }\r\n    /**\r\n     * Process a selector into a transformed value synchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {any} The value returned by the processor.\r\n     */\r\n    transformSync(rule, options) {\r\n        return this._runSync(rule, options).transform;\r\n    }\r\n    /**\r\n     * Process a selector into a new selector string asynchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {string} the selector after processing.\r\n     */\r\n    process(rule, options) {\r\n        return this._run(rule, options)\r\n            .then((result) => result.string || result.root.toString());\r\n    }\r\n    /**\r\n     * Process a selector into a new selector string synchronously.\r\n     *\r\n     * @param rule {postcss.Rule | string} The css selector to be processed\r\n     * @param options The options for processing\r\n     * @returns {string} the selector after processing.\r\n     */\r\n    processSync(rule, options) {\r\n        let result = this._runSync(rule, options);\r\n        return result.string || result.root.toString();\r\n    }\r\n}\r\n", "export * from \"./types\";\r\nexport * from \"./constructors\";\r\nexport * from \"./guards\";\r\n", "import Attribute from './attribute';\r\nimport ClassName from './className';\r\nimport Combinator from './combinator';\r\nimport Comment from './comment';\r\nimport Id from './id';\r\nimport Nesting from './nesting';\r\nimport Pseudo from './pseudo';\r\nimport Root from './root';\r\nimport Selector from './selector';\r\nimport Str from './string';\r\nimport Tag from './tag';\r\nimport Universal from './universal';\r\nexport const attribute = opts => new Attribute(opts);\r\nexport const className = opts => new ClassName(opts);\r\nexport const combinator = opts => new Combinator(opts);\r\nexport const comment = opts => new Comment(opts);\r\nexport const id = opts => new Id(opts);\r\nexport const nesting = opts => new Nesting(opts);\r\nexport const pseudo = opts => new Pseudo(opts);\r\nexport const root = opts => new Root(opts);\r\nexport const selector = opts => new Selector(opts);\r\nexport const string = opts => new Str(opts);\r\nexport const tag = opts => new Tag(opts);\r\nexport const universal = opts => new Universal(opts);\r\n", "import { ATTRIBUTE, CLASS, COMBINATOR, COMMENT, ID, NESTING, PSEUDO, ROOT, SELECTOR, STRING, TAG, UNIVERSAL, } from \"./types\";\r\nconst IS_TYPE = {\r\n    [ATTRIBUTE]: true,\r\n    [CLASS]: true,\r\n    [COMBINATOR]: true,\r\n    [COMMENT]: true,\r\n    [ID]: true,\r\n    [NESTING]: true,\r\n    [PSEUDO]: true,\r\n    [ROOT]: true,\r\n    [SELECTOR]: true,\r\n    [STRING]: true,\r\n    [TAG]: true,\r\n    [UNIVERSAL]: true,\r\n};\r\nexport function isNode(node) {\r\n    return (typeof node === \"object\" && IS_TYPE[node.type]);\r\n}\r\nfunction isNodeType(type, node) {\r\n    return isNode(node) && node.type === type;\r\n}\r\nexport const isAttribute = isNodeType.bind(null, ATTRIBUTE);\r\nexport const isClassName = isNodeType.bind(null, CLASS);\r\nexport const isCombinator = isNodeType.bind(null, COMBINATOR);\r\nexport const isComment = isNodeType.bind(null, COMMENT);\r\nexport const isIdentifier = isNodeType.bind(null, ID);\r\nexport const isNesting = isNodeType.bind(null, NESTING);\r\nexport const isPseudo = isNodeType.bind(null, PSEUDO);\r\nexport const isRoot = isNodeType.bind(null, ROOT);\r\nexport const isSelector = isNodeType.bind(null, SELECTOR);\r\nexport const isString = isNodeType.bind(null, STRING);\r\nexport const isTag = isNodeType.bind(null, TAG);\r\nexport const isUniversal = isNodeType.bind(null, UNIVERSAL);\r\nexport function isPseudoElement(node) {\r\n    return isPseudo(node)\r\n        && node.value\r\n        && (node.value.startsWith(\"::\")\r\n            || node.value.toLowerCase() === \":before\"\r\n            || node.value.toLowerCase() === \":after\"\r\n            || node.value.toLowerCase() === \":first-letter\"\r\n            || node.value.toLowerCase() === \":first-line\");\r\n}\r\nexport function isPseudoClass(node) {\r\n    return isPseudo(node) && !isPseudoElement(node);\r\n}\r\nexport function isContainer(node) {\r\n    return !!(isNode(node) && node.walk);\r\n}\r\nexport function isNamespace(node) {\r\n    return isAttribute(node) || isTag(node);\r\n}\r\n", "import Processor from './processor';\r\nimport * as selectors from './selectors';\r\nconst parser = processor => new Processor(processor);\r\nObject.assign(parser, selectors);\r\nexport default parser;\r\n", "import type { ExtractorResult } from \"./types\";\n\nfunction mergeSets(into: Set<string>, from?: string[] | Set<string>): void {\n  if (from) {\n    from.forEach(into.add, into);\n  }\n}\n\n/**\n * @public\n */\nclass ExtractorResultSets {\n  private undetermined = new Set<string>();\n  private attrNames = new Set<string>();\n  private attrValues = new Set<string>();\n  private classes = new Set<string>();\n  private ids = new Set<string>();\n  private tags = new Set<string>();\n\n  constructor(er: ExtractorResult) {\n    this.merge(er);\n  }\n\n  merge(that: ExtractorResult | ExtractorResultSets): this {\n    if (Array.isArray(that)) {\n      mergeSets(this.undetermined, that);\n    } else if (that instanceof ExtractorResultSets) {\n      mergeSets(this.undetermined, that.undetermined);\n      mergeSets(this.attrNames, that.attrNames);\n      mergeSets(this.attrValues, that.attrValues);\n      mergeSets(this.classes, that.classes);\n      mergeSets(this.ids, that.ids);\n      mergeSets(this.tags, that.tags);\n    } else {\n      // ExtractorResultDetailed:\n      mergeSets(this.undetermined, that.undetermined);\n      if (that.attributes) {\n        mergeSets(this.attrNames, that.attributes.names);\n        mergeSets(this.attrValues, that.attributes.values);\n      }\n      mergeSets(this.classes, that.classes);\n      mergeSets(this.ids, that.ids);\n      mergeSets(this.tags, that.tags);\n    }\n    return this;\n  }\n\n  hasAttrName(name: string): boolean {\n    return this.attrNames.has(name) || this.undetermined.has(name);\n  }\n\n  private someAttrValue(predicate: (value: string) => boolean): boolean {\n    for (const val of this.attrValues) {\n      if (predicate(val)) return true;\n    }\n    for (const val of this.undetermined) {\n      if (predicate(val)) return true;\n    }\n    return false;\n  }\n\n  hasAttrPrefix(prefix: string): boolean {\n    return this.someAttrValue((value) => value.startsWith(prefix));\n  }\n\n  hasAttrSuffix(suffix: string): boolean {\n    return this.someAttrValue((value) => value.endsWith(suffix));\n  }\n\n  hasAttrSubstr(substr: string): boolean {\n    const wordSubstr = substr.trim().split(\" \");\n    return wordSubstr.every((word) =>\n      this.someAttrValue((value) => value.includes(word)),\n    );\n  }\n\n  hasAttrValue(value: string): boolean {\n    return this.attrValues.has(value) || this.undetermined.has(value);\n  }\n\n  hasClass(name: string): boolean {\n    return this.classes.has(name) || this.undetermined.has(name);\n  }\n\n  hasId(id: string): boolean {\n    return this.ids.has(id) || this.undetermined.has(id);\n  }\n\n  hasTag(tag: string): boolean {\n    return this.tags.has(tag) || this.undetermined.has(tag);\n  }\n}\n\nexport default ExtractorResultSets;\n", "import type { ExtractorResult, Options } from \"./types/\";\n\n/**\n * @public\n */\nexport const defaultOptions: Options = {\n  css: [],\n  content: [],\n  defaultExtractor: (content: string): ExtractorResult =>\n    content.match(/[A-Za-z0-9_-]+/g) || [],\n  extractors: [],\n  fontFace: false,\n  keyframes: false,\n  rejected: false,\n  rejectedCss: false,\n  stdin: false,\n  stdout: false,\n  variables: false,\n  safelist: {\n    standard: [],\n    deep: [],\n    greedy: [],\n    variables: [],\n    keyframes: [],\n  },\n  blocklist: [],\n  skippedContentGlobs: [],\n  dynamicAttributes: [],\n};\n", "import type { StringRegExpArray } from \"./types\";\n\n/**\n * @public\n */\nexport class VariableNode {\n  public nodes: VariableNode[] = [];\n  public value: any;\n  public isUsed = false;\n\n  constructor(declaration: any) {\n    this.value = declaration;\n  }\n}\n\n/**\n * @public\n */\nexport class VariablesStructure {\n  public nodes: Map<string, VariableNode[]> = new Map();\n  public usedVariables: Set<string> = new Set();\n  public safelist: StringRegExpArray = [];\n\n  addVariable(declaration: any): void {\n    const { prop } = declaration;\n    if (!this.nodes.has(prop)) {\n      const node = new VariableNode(declaration);\n      this.nodes.set(prop, [node]);\n    } else {\n      const node = new VariableNode(declaration);\n      const variableNodes = this.nodes.get(prop) || [];\n      this.nodes.set(prop, [...variableNodes, node]);\n    }\n  }\n\n  addVariableUsage(\n    declaration: any,\n    matchedVariables: IterableIterator<RegExpMatchArray>,\n  ): void {\n    const { prop } = declaration;\n    const nodes = this.nodes.get(prop);\n    for (const variableMatch of matchedVariables) {\n      // capturing group containing the variable is in index 1\n      const variableName = variableMatch[1];\n      if (this.nodes.has(variableName)) {\n        const usedVariableNodes = this.nodes.get(variableName);\n        nodes?.forEach((node) => {\n          usedVariableNodes?.forEach((usedVariableNode) =>\n            node.nodes.push(usedVariableNode),\n          );\n        });\n      }\n    }\n  }\n\n  addVariableUsageInProperties(\n    matchedVariables: IterableIterator<RegExpMatchArray>,\n  ): void {\n    for (const variableMatch of matchedVariables) {\n      // capturing group containing the variable is in index 1\n      const variableName = variableMatch[1];\n      this.usedVariables.add(variableName);\n    }\n  }\n\n  setAsUsed(variableName: string): void {\n    const nodes = this.nodes.get(variableName);\n    if (nodes) {\n      const queue = [...nodes];\n      while (queue.length !== 0) {\n        const currentNode = queue.pop();\n        if (currentNode && !currentNode.isUsed) {\n          currentNode.isUsed = true;\n          queue.push(...currentNode.nodes);\n        }\n      }\n    }\n  }\n\n  removeUnused(): void {\n    // check unordered usage\n    for (const used of this.usedVariables) {\n      const usedNodes = this.nodes.get(used);\n      if (usedNodes) {\n        for (const usedNode of usedNodes) {\n          const usedVariablesMatchesInDeclaration =\n            usedNode.value.value.matchAll(/var\\((.+?)[,)]/g);\n\n          for (const usage of usedVariablesMatchesInDeclaration) {\n            if (!this.usedVariables.has(usage[1])) {\n              this.usedVariables.add(usage[1]);\n            }\n          }\n        }\n      }\n    }\n\n    for (const used of this.usedVariables) {\n      this.setAsUsed(used);\n    }\n\n    for (const [name, declarations] of this.nodes) {\n      for (const declaration of declarations) {\n        if (!declaration.isUsed && !this.isVariablesSafelisted(name)) {\n          declaration.value.remove();\n        }\n      }\n    }\n  }\n\n  isVariablesSafelisted(variable: string): boolean {\n    return this.safelist.some((safelistItem) => {\n      return typeof safelistItem === \"string\"\n        ? safelistItem === variable\n        : safelistItem.test(variable);\n    });\n  }\n}\n", "/**\n * Core package of PurgeCSS\n *\n * Contains the core methods to analyze the files, remove unused CSS.\n *\n * @packageDocumentation\n */\n\nimport postcss from \"./postcss/postcss\";\nimport selectorParser from \"./postcss-selector-parser\";\nimport ExtractorResultSets from \"./ExtractorResultSets\";\nimport { defaultOptions } from \"./options\";\nimport type {\n  AtRules,\n  ComplexSafelist,\n  ExtractorFunction,\n  ExtractorResultDetailed,\n  Extractors,\n  IgnoreType,\n  Options,\n  PostCSSRoot,\n  RawContent,\n  RawCSS,\n  ResultPurge,\n  UserDefinedOptions,\n  UserDefinedSafelist,\n} from \"./types\";\n\nimport { VariablesStructure } from \"./VariablesStructure\";\n\nexport * from \"./types\";\nexport { defaultOptions, ExtractorResultSets, PurgeCSS, VariablesStructure };\nexport * from \"./VariablesStructure\";\n\nconst CSS_SAFELIST = [\"*\", \":root\", \":after\", \":before\"];\nexport const IGNORE_ANNOTATION_CURRENT = \"purgecss ignore current\";\nexport const IGNORE_ANNOTATION_NEXT = \"purgecss ignore\";\nexport const IGNORE_ANNOTATION_START = \"purgecss start ignore\";\nexport const IGNORE_ANNOTATION_END = \"purgecss end ignore\";\nexport const CONFIG_FILENAME = \"purgecss.config.js\";\nexport const ERROR_CONFIG_FILE_LOADING = \"Error loading the config file\";\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function standardizeSafelist(\n  userDefinedSafelist: UserDefinedSafelist = [],\n): Required<ComplexSafelist> {\n  if (Array.isArray(userDefinedSafelist)) {\n    return {\n      ...defaultOptions.safelist,\n      standard: userDefinedSafelist,\n    };\n  }\n  return {\n    ...defaultOptions.safelist,\n    ...userDefinedSafelist,\n  };\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nasync function extractSelectors(\n  content: string,\n  extractor: ExtractorFunction,\n): Promise<ExtractorResultSets> {\n  return new ExtractorResultSets(await extractor(content));\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isIgnoreAnnotation(node: any, type: IgnoreType): boolean {\n  switch (type) {\n    case \"next\":\n      return node.text.includes(IGNORE_ANNOTATION_NEXT);\n    case \"start\":\n      return node.text.includes(IGNORE_ANNOTATION_START);\n    case \"end\":\n      return node.text.includes(IGNORE_ANNOTATION_END);\n  }\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isRuleEmpty(node?: any): boolean {\n  if (\n    (isPostCSSRule(node) && !node.selector) ||\n    (node?.nodes && !node.nodes.length) ||\n    (isPostCSSAtRule(node) &&\n      ((!node.nodes && !node.params) ||\n        (!node.params && node.nodes && !node.nodes.length)))\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction hasIgnoreAnnotation(rule: any): boolean {\n  let found = false;\n  rule.walkComments((node) => {\n    if (\n      node &&\n      node.type === \"comment\" &&\n      node.text.includes(IGNORE_ANNOTATION_CURRENT)\n    ) {\n      found = true;\n      node.remove();\n    }\n  });\n  return found;\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function mergeExtractorSelectors(\n  ...extractors: (ExtractorResultDetailed | ExtractorResultSets)[]\n): ExtractorResultSets {\n  const result = new ExtractorResultSets([]);\n  extractors.forEach(result.merge, result);\n  return result;\n}\n/*@__NO_SIDE_EFFECTS__*/\nfunction stripQuotes(str: string): string {\n  return str.replace(/(^[\"'])|([\"']$)/g, \"\");\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isAttributeFound(\n  attributeNode: selectorParser.Attribute,\n  selectors: ExtractorResultSets,\n): boolean {\n  if (!selectors.hasAttrName(attributeNode.attribute)) {\n    return false;\n  }\n\n  if (typeof attributeNode.value === \"undefined\") {\n    return true;\n  }\n\n  switch (attributeNode.operator) {\n    case \"$=\":\n      return selectors.hasAttrSuffix(attributeNode.value);\n    case \"~=\":\n    case \"*=\":\n      return selectors.hasAttrSubstr(attributeNode.value);\n    case \"=\":\n      return selectors.hasAttrValue(attributeNode.value);\n    case \"|=\":\n    case \"^=\":\n      return selectors.hasAttrPrefix(attributeNode.value);\n    default:\n      return true;\n  }\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isClassFound(\n  classNode: selectorParser.ClassName,\n  selectors: ExtractorResultSets,\n): boolean {\n  return selectors.hasClass(classNode.value);\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isIdentifierFound(\n  identifierNode: selectorParser.Identifier,\n  selectors: ExtractorResultSets,\n): boolean {\n  return selectors.hasId(identifierNode.value);\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isTagFound(\n  tagNode: selectorParser.Tag,\n  selectors: ExtractorResultSets,\n): boolean {\n  return selectors.hasTag(tagNode.value);\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isInPseudoClass(selector: selectorParser.Node): boolean {\n  return (\n    (selector.parent &&\n      selector.parent.type === \"pseudo\" &&\n      selector.parent.value.startsWith(\":\")) ||\n    false\n  );\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isInPseudoClassWhereOrIs(selector: selectorParser.Node): boolean {\n  return (\n    (selector.parent &&\n      selector.parent.type === \"pseudo\" &&\n      (selector.parent.value === \":where\" ||\n        selector.parent.value === \":is\")) ||\n    false\n  );\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isPseudoClassAtRootLevel(selector: selectorParser.Node): boolean {\n  let result = false;\n  if (\n    selector.type === \"selector\" &&\n    selector.parent?.type === \"root\" &&\n    selector.nodes.length === 1\n  ) {\n    selector.walk((node) => {\n      if (\n        node.type === \"pseudo\" &&\n        (node.value === \":where\" ||\n          node.value === \":is\" ||\n          node.value === \":has\" ||\n          node.value === \":not\")\n      ) {\n        result = true;\n      }\n    });\n  }\n  return result;\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isPostCSSAtRule(node?: any): node is any {\n  return node?.type === \"atrule\";\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isPostCSSRule(node?: any): node is any {\n  return node?.type === \"rule\";\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nfunction isPostCSSComment(\n\t\tnode?: any,\n\t): node is any {\n  return node?.type === \"comment\";\n}\n\n/**\n * Class used to instantiate PurgeCSS and can then be used\n * to purge CSS files.\n *\n * @example\n * ```ts\n * await new PurgeCSS().purge({\n *    content: ['index.html'],\n *    css: ['css/app.css']\n * })\n * ```\n *\n * @public\n */\nclass PurgeCSS {\n  private ignore = false;\n  private atRules: AtRules = {\n    fontFace: [],\n    keyframes: [],\n  };\n\n  private usedAnimations: Set<string> = new Set();\n  private usedFontFaces: Set<string> = new Set();\n  public selectorsRemoved: Set<string> = new Set();\n  public removedNodes: any[] = [];\n  public variablesStructure: VariablesStructure = new VariablesStructure();\n\n  public options: Options = defaultOptions;\n\n  private collectDeclarationsData(declaration:  any): void {\n    const { prop, value } = declaration;\n\n    // collect css properties data\n    if (this.options.variables) {\n      const usedVariablesMatchesInDeclaration =\n        value.matchAll(/var\\((.+?)[,)]/g);\n      if (prop.startsWith(\"--\")) {\n        this.variablesStructure.addVariable(declaration);\n        this.variablesStructure.addVariableUsage(\n          declaration,\n          usedVariablesMatchesInDeclaration,\n        );\n      } else {\n        this.variablesStructure.addVariableUsageInProperties(\n          usedVariablesMatchesInDeclaration,\n        );\n      }\n    }\n\n    // collect keyframes data\n    if (this.options.keyframes) {\n      if (prop === \"animation\" || prop === \"animation-name\") {\n        for (const word of value.split(/[\\s,]+/)) {\n          this.usedAnimations.add(word);\n        }\n        return;\n      }\n    }\n\n    // collect font faces data\n    if (this.options.fontFace) {\n      if (prop === \"font-family\") {\n        for (const fontName of value.split(\",\")) {\n          const cleanedFontFace = stripQuotes(fontName.trim());\n          this.usedFontFaces.add(cleanedFontFace);\n        }\n      }\n      return;\n    }\n  }\n\n  /**\n   * Get the extractor corresponding to the extension file\n   * @param filename - Name of the file\n   * @param extractors - Array of extractors definition\n   */\n  private getFileExtractor(\n    filename: string,\n    extractors: Extractors[],\n  ): ExtractorFunction {\n    const extractorObj = extractors.find((extractor) =>\n      extractor.extensions.find((ext) => filename.endsWith(ext)),\n    );\n\n    return typeof extractorObj === \"undefined\"\n      ? this.options.defaultExtractor\n      : extractorObj.extractor;\n  }\n\n\n  /**\n   * Extract the selectors present in the passed string using a PurgeCSS extractor\n   *\n   * @param content - Array of content\n   * @param extractors - Array of extractors\n   */\n  public async extractSelectorsFromString(\n    content: RawContent[],\n    extractors: Extractors[],\n  ): Promise<ExtractorResultSets> {\n    const selectors = new ExtractorResultSets([]);\n    for (const { raw, extension } of content) {\n      const extractor = this.getFileExtractor(`.${extension}`, extractors);\n      const extractedSelectors = await extractSelectors(raw, extractor);\n      selectors.merge(extractedSelectors);\n    }\n    return selectors;\n  }\n\n  /**\n   * Evaluate at-rule and register it for future reference\n   * @param node - node of postcss AST\n   */\n  private evaluateAtRule(node:any): void {\n    // keyframes\n    if (this.options.keyframes && node.name.endsWith(\"keyframes\")) {\n      this.atRules.keyframes.push(node);\n      return;\n    }\n    // font-face\n    if (this.options.fontFace && node.name === \"font-face\" && node.nodes) {\n      for (const childNode of node.nodes) {\n        if (childNode.type === \"decl\" && childNode.prop === \"font-family\") {\n          this.atRules.fontFace.push({\n            name: stripQuotes(childNode.value),\n            node,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Evaluate css selector and decide if it should be removed or not\n   *\n   * @param node - node of postcss AST\n   * @param selectors - selectors used in content files\n   */\n  private evaluateRule(\n    node: any,\n    selectors: ExtractorResultSets,\n  ): void {\n    // exit if is in ignoring state activated by an ignore comment\n    if (this.ignore) {\n      return;\n    }\n\n    // exit if the previous annotation is a ignore next line comment\n    const annotation = node.prev();\n    if (\n      isPostCSSComment(annotation) &&\n      isIgnoreAnnotation(annotation, \"next\")\n    ) {\n      annotation.remove();\n      return;\n    }\n\n    // exit if it is inside a keyframes\n    if (\n      node.parent &&\n      isPostCSSAtRule(node.parent) &&\n      node.parent.name.endsWith(\"keyframes\")\n    ) {\n      return;\n    }\n\n    // exit if it is not a rule\n    if (!isPostCSSRule(node)) {\n      return;\n    }\n\n    // exit if it has an ignore rule comment inside\n    if (hasIgnoreAnnotation(node)) {\n      return;\n    }\n\n    const selectorsRemovedFromRule: string[] = [];\n    // selector transformer, walk over the list of the parsed selectors twice.\n    // First pass will remove the unused selectors. It goes through\n    // pseudo-classes like :where() and :is() and remove the unused\n    // selectors inside of them, but will not remove the pseudo-classes\n    // themselves. Second pass will remove selectors containing empty\n    // :where and :is.\n    node.selector = selectorParser((selectorsParsed) => {\n      selectorsParsed.walk((selector) => {\n        if (selector.type !== \"selector\") {\n          return;\n        }\n        const keepSelector = this.shouldKeepSelector(selector, selectors);\n\n        if (!keepSelector) {\n          if (this.options.rejected) {\n            this.selectorsRemoved.add(selector.toString());\n          }\n          if (this.options.rejectedCss) {\n            selectorsRemovedFromRule.push(selector.toString());\n          }\n          selector.remove();\n        }\n      });\n\n      // removes selectors containing empty :where and :is\n      selectorsParsed.walk((selector) => {\n        if (selector.type !== \"selector\") {\n          return;\n        }\n\n        if (selector.toString() && /(:where)|(:is)/.test(selector.toString())) {\n          selector.walk((node) => {\n            if (node.type !== \"pseudo\") return;\n            if (node.value !== \":where\" && node.value !== \":is\") return;\n            if (node.nodes.length === 0) {\n              selector.remove();\n            }\n          });\n        }\n      });\n    }).processSync(node.selector);\n\n    // declarations\n    if (node.selector && typeof node.nodes !== \"undefined\") {\n      for (const childNode of node.nodes) {\n        if (childNode.type !== \"decl\") continue;\n        this.collectDeclarationsData(childNode);\n      }\n    }\n\n    // remove empty rules\n    const parent = node.parent;\n    if (!node.selector) {\n      node.remove();\n    }\n    if (isRuleEmpty(parent)) parent?.remove();\n\n    // rebuild the rule with the removed selectors and optionally its parent\n    if (this.options.rejectedCss) {\n      if (selectorsRemovedFromRule.length > 0) {\n        const clone = node.clone();\n        const parentClone = parent?.clone().removeAll().append(clone);\n        clone.selectors = selectorsRemovedFromRule;\n        const nodeToPreserve = parentClone ? parentClone : clone;\n        this.removedNodes.push(nodeToPreserve);\n      }\n    }\n  }\n\n  /**\n   * Get the purged version of the css based on the files\n   *\n   * @param cssOptions - css options, files or raw strings\n   * @param selectors - set of extracted css selectors\n   */\n  public async getPurgedCSS(\n    cssOptions: Array<string | RawCSS>,\n    selectors: ExtractorResultSets,\n  ): Promise<ResultPurge[]> {\n    const sources = [];\n\n    // resolve any globs\n    const processedOptions: Array<string | RawCSS> = [];\n    for (const option of cssOptions) {\n      if (typeof option === \"string\") {\n        throw new Error(\"PurgeCSS: string options are not supported\");\n      } else {\n        processedOptions.push(option);\n      }\n    }\n\n    for (const option of processedOptions) {\n      const cssContent =\n        typeof option === \"string\"\n          ? this.options.stdin\n            ? option\n            : null\n          : option.raw;\n      const isFromFile = typeof option === \"string\" && !this.options.stdin;\n          // @ts-ignore\n      const root = postcss.parse(cssContent, {\n        from: isFromFile ? option : undefined,\n      });\n\n      // purge unused selectors\n      this.walkThroughCSS(root, selectors);\n\n      if (this.options.fontFace) this.removeUnusedFontFaces();\n      if (this.options.keyframes) this.removeUnusedKeyframes();\n      if (this.options.variables) this.removeUnusedCSSVariables();\n\n      const postCSSResult = root.toResult({\n        map: this.options.sourceMap,\n        to:\n          typeof this.options.sourceMap === \"object\"\n            ? this.options.sourceMap.to\n            : undefined,\n      });\n      const result: any = {\n        css: postCSSResult.toString(),\n        file: typeof option === \"string\" ? option : option.name,\n      };\n\n      if (this.options.sourceMap) {\n        result.sourceMap = postCSSResult.map?.toString();\n      }\n\n      if (this.options.rejected) {\n        result.rejected = Array.from(this.selectorsRemoved);\n        this.selectorsRemoved.clear();\n      }\n\n      if (this.options.rejectedCss) {\n        result.rejectedCss = postcss\n          .root({ nodes: this.removedNodes })\n          .toString();\n      }\n\n      sources.push(result);\n    }\n    return sources;\n  }\n\n  /**\n   * Check if the keyframe is safelisted with the option safelist keyframes\n   *\n   * @param keyframesName - name of the keyframe animation\n   */\n  private isKeyframesSafelisted(keyframesName: string): boolean {\n    return this.options.safelist.keyframes.some((safelistItem) => {\n      return typeof safelistItem === \"string\"\n        ? safelistItem === keyframesName\n        : safelistItem.test(keyframesName);\n    });\n  }\n\n  /**\n   * Check if the selector is blocklisted with the option blocklist\n   *\n   * @param selector - css selector\n   */\n  private isSelectorBlocklisted(selector: string): boolean {\n    return this.options.blocklist.some((blocklistItem) => {\n      return typeof blocklistItem === \"string\"\n        ? blocklistItem === selector\n        : blocklistItem.test(selector);\n    });\n  }\n\n  /**\n   * Check if the selector is safelisted with the option safelist standard\n   *\n   * @param selector - css selector\n   */\n  private isSelectorSafelisted(selector: string): boolean {\n    const isSafelisted = this.options.safelist.standard.some((safelistItem) => {\n      return typeof safelistItem === \"string\"\n        ? safelistItem === selector\n        : safelistItem.test(selector);\n    });\n    const isPseudoElement = /^::.*/.test(selector);\n    return CSS_SAFELIST.includes(selector) || isPseudoElement || isSafelisted;\n  }\n\n  /**\n   * Check if the selector is safelisted with the option safelist deep\n   *\n   * @param selector - selector\n   */\n  private isSelectorSafelistedDeep(selector: string): boolean {\n    return this.options.safelist.deep.some((safelistItem) =>\n      safelistItem.test(selector),\n    );\n  }\n\n  /**\n   * Check if the selector is safelisted with the option safelist greedy\n   *\n   * @param selector - selector\n   */\n  private isSelectorSafelistedGreedy(selector: string): boolean {\n    return this.options.safelist.greedy.some((safelistItem) =>\n      safelistItem.test(selector),\n    );\n  }\n\n  /**\n   * Remove unused CSS\n   *\n   * @param userOptions - PurgeCSS options or path to the configuration file\n   * @returns an array of object containing the filename and the associated CSS\n   *\n   * @example Using a configuration file named purgecss.config.js\n   * ```ts\n   * const purgeCSSResults = await new PurgeCSS().purge()\n   * ```\n   *\n   * @example Using a custom path to the configuration file\n   * ```ts\n   * const purgeCSSResults = await new PurgeCSS().purge('./purgecss.config.js')\n   * ```\n   *\n   * @example Using the PurgeCSS options\n   * ```ts\n   * const purgeCSSResults = await new PurgeCSS().purge({\n   *    content: ['index.html', '**\\/*.js', '**\\/*.html', '**\\/*.vue'],\n   *    css: ['css/app.css']\n   * })\n   * ```\n   */\n  public async purge(\n    userOptions: UserDefinedOptions | string | undefined,\n  ): Promise<ResultPurge[]> {\n    this.options =\n      typeof userOptions !== \"object\"\n          // @ts-ignore\n        ? await setOptions(userOptions)\n        : {\n            ...defaultOptions,\n            ...userOptions,\n            safelist: standardizeSafelist(userOptions.safelist),\n          };\n    const { content, css, extractors, safelist } = this.options;\n\n    if (this.options.variables) {\n      this.variablesStructure.safelist = safelist.variables || [];\n    }\n\n\n    const rawFormatContents = content.filter(\n      (o) => typeof o === \"object\",\n    ) as RawContent[];\n\n\n    const cssRawSelectors = await this.extractSelectorsFromString(\n      rawFormatContents,\n      extractors,\n    );\n\n    return this.getPurgedCSS(\n      css,\n      mergeExtractorSelectors({} as any, cssRawSelectors),\n    );\n  }\n\n  /**\n   * Remove unused CSS variables\n   */\n  public removeUnusedCSSVariables(): void {\n    this.variablesStructure.removeUnused();\n  }\n\n  /**\n   * Remove unused font-faces\n   */\n  public removeUnusedFontFaces(): void {\n    for (const { name, node } of this.atRules.fontFace) {\n      if (!this.usedFontFaces.has(name)) {\n        node.remove();\n      }\n    }\n  }\n\n  /**\n   * Remove unused keyframes\n   */\n  public removeUnusedKeyframes(): void {\n    for (const node of this.atRules.keyframes) {\n      if (\n        !this.usedAnimations.has(node.params) &&\n        !this.isKeyframesSafelisted(node.params)\n      ) {\n        node.remove();\n      }\n    }\n  }\n\n  /**\n   * Transform a selector node into a string\n   */\n  private getSelectorValue(selector: selectorParser.Node): string | undefined {\n    return (\n      (selector.type === \"attribute\" && selector.attribute) || selector.value\n    );\n  }\n\n  /**\n   * Determine if the selector should be kept, based on the selectors found in the files\n   *\n   * @param selector - set of css selectors found in the content files or string\n   * @param selectorsFromExtractor - selectors in the css rule\n   *\n   * @returns true if the selector should be kept in the processed CSS\n   */\n  private shouldKeepSelector(\n    selector: selectorParser.Selector,\n    selectorsFromExtractor: ExtractorResultSets,\n  ): boolean {\n    // selectors in pseudo classes are ignored except :where() and :is(). For those pseudo-classes, we are treating the selectors inside the same way as they would be outside.\n    if (isInPseudoClass(selector) && !isInPseudoClassWhereOrIs(selector)) {\n      return true;\n    }\n\n    if (isPseudoClassAtRootLevel(selector)) {\n      return true;\n    }\n\n    // if there is any greedy safelist pattern, run all the selector parts through them\n    // if there is any match, return true\n    if (this.options.safelist.greedy.length > 0) {\n      const selectorParts = selector.nodes.map(this.getSelectorValue);\n      if (\n        selectorParts.some(\n          (selectorPart) =>\n            selectorPart && this.isSelectorSafelistedGreedy(selectorPart),\n        )\n      ) {\n        return true;\n      }\n    }\n\n    let isPresent = false;\n\n    for (const selectorNode of selector.nodes) {\n      const selectorValue = this.getSelectorValue(selectorNode);\n\n      // if the selector is safelisted with children\n      // returns true to keep all children selectors\n      if (selectorValue && this.isSelectorSafelistedDeep(selectorValue)) {\n        return true;\n      }\n\n      // The selector is found in the internal and user-defined safelist\n      if (\n        selectorValue &&\n        (CSS_SAFELIST.includes(selectorValue) ||\n          this.isSelectorSafelisted(selectorValue))\n      ) {\n        isPresent = true;\n        continue;\n      }\n\n      // The selector is present in the blocklist\n      if (selectorValue && this.isSelectorBlocklisted(selectorValue)) {\n        return false;\n      }\n\n      switch (selectorNode.type) {\n        case \"attribute\":\n          // `value` is a dynamic attribute, highly used in input element\n          // the choice is to always leave `value` as it can change based on the user\n          // idem for `checked`, `selected`, `open`\n          isPresent = [\n            ...this.options.dynamicAttributes,\n            \"value\",\n            \"checked\",\n            \"selected\",\n            \"open\",\n          ].includes(selectorNode.attribute)\n            ? true\n            : isAttributeFound(selectorNode, selectorsFromExtractor);\n          break;\n        case \"class\":\n          isPresent = isClassFound(selectorNode, selectorsFromExtractor);\n          break;\n        case \"id\":\n          isPresent = isIdentifierFound(selectorNode, selectorsFromExtractor);\n          break;\n        case \"tag\":\n          isPresent = isTagFound(selectorNode, selectorsFromExtractor);\n          break;\n        default:\n          continue;\n      }\n\n      // selector is not safelisted\n      // and it has not been found as an attribute/class/id/tag\n      if (!isPresent) {\n        return false;\n      }\n    }\n\n    return isPresent;\n  }\n\n  /**\n   * Walk through the CSS AST and remove unused CSS\n   *\n   * @param root - root node of the postcss AST\n   * @param selectors - selectors used in content files\n   */\n  public walkThroughCSS(\n    root: PostCSSRoot,\n    selectors: ExtractorResultSets,\n  ): void {\n    root.walk((node) => {\n      if (node.type === \"rule\") {\n        return this.evaluateRule(node, selectors);\n      }\n      if (node.type === \"atrule\") {\n        return this.evaluateAtRule(node);\n      }\n      if (node.type === \"comment\") {\n        if (isIgnoreAnnotation(node, \"start\")) {\n          this.ignore = true;\n          // remove ignore annotation\n          node.remove();\n        } else if (isIgnoreAnnotation(node, \"end\")) {\n          this.ignore = false;\n          // remove ignore annotation\n          node.remove();\n        }\n      }\n    });\n  }\n}\n"],
  "mappings": ";;;;;;;;AAAO,IAAM,iBAAN,MAAM,wBAAuB,MAAM;AAAA,EAA1C,OAA0C;AAAA;AAAA;AAAA,EACtC,YAAY,SAAS,MAAM,QAAQ,QAAQ,MAAMA,SAAQ;AACrD,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,QAAI,MAAM;AACN,WAAK,OAAO;AAAA,IAChB;AACA,QAAI,QAAQ;AACR,WAAK,SAAS;AAAA,IAClB;AACA,QAAIA,SAAQ;AACR,WAAK,SAASA;AAAA,IAClB;AACA,QAAI,OAAO,SAAS,eAAe,OAAO,WAAW,aAAa;AAC9D,UAAI,OAAO,SAAS,UAAU;AAC1B,aAAK,OAAO;AACZ,aAAK,SAAS;AAAA,MAClB,OACK;AACD,aAAK,OAAO,KAAK;AACjB,aAAK,SAAS,KAAK;AACnB,aAAK,UAAU,OAAO;AACtB,aAAK,YAAY,OAAO;AAAA,MAC5B;AAAA,IACJ;AACA,SAAK,WAAW;AAChB,QAAI,MAAM,mBAAmB;AACzB,YAAM,kBAAkB,MAAM,eAAc;AAAA,IAChD;AAAA,EACJ;AAAA,EACA,aAAa;AACT,SAAK,UAAU,KAAK,SAAS,KAAK,SAAS,OAAO;AAClD,SAAK,WAAW,KAAK,OAAO,KAAK,OAAO;AACxC,QAAI,OAAO,KAAK,SAAS,aAAa;AAClC,WAAK,WAAW,MAAM,KAAK,OAAO,MAAM,KAAK;AAAA,IACjD;AACA,SAAK,WAAW,OAAO,KAAK;AAAA,EAChC;AAAA,EACA,iBAAiB;AACb,WAAO;AAAA,EACX;AAAA,EACA,WAAW;AACP,QAAI,OAAO,KAAK,eAAe;AAC/B,QAAI,MAAM;AACN,aAAO,SAAS,OAAO;AAAA,IAC3B;AACA,WAAO,KAAK,OAAO,OAAO,KAAK,UAAU;AAAA,EAC7C;AACJ;;;ACjDA,IAAM,cAAc;AAAA,EAChB,OAAO;AAAA,EACP,aAAa;AAAA,EACb,eAAe;AAAA,EACf,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,OAAO;AAAA,EACP,aAAa;AAAA,EACb,cAAc;AAAA,EACd,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,WAAW;AACf;AACA,SAAS,WAAWC,MAAK;AACrB,SAAOA,KAAI,CAAC,EAAE,YAAY,IAAIA,KAAI,MAAM,CAAC;AAC7C;AAFS;AAGF,IAAM,cAAN,MAAkB;AAAA,EAjBzB,OAiByB;AAAA;AAAA;AAAA,EACrB,YAAY,SAAS;AACjB,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,OAAO,MAAMC,YAAW;AACpB,QAAI,OAAO,MAAM,KAAK;AACtB,UAAM,SAAS,KAAK,SAAS,KAAK,SAAS,MAAM,QAAQ,IAAI;AAC7D,QAAI,OAAO,KAAK,KAAK,cAAc,aAAa;AAC5C,cAAQ,KAAK,KAAK;AAAA,IACtB,WACS,QAAQ;AACb,cAAQ;AAAA,IACZ;AACA,QAAI,KAAK,OAAO;AACZ,WAAK,MAAM,MAAM,OAAO,MAAM;AAAA,IAClC,OACK;AACD,YAAM,OAAO,KAAK,KAAK,WAAW,OAAOA,aAAY,MAAM;AAC3D,WAAK,QAAQ,OAAO,SAAS,KAAK,IAAI;AAAA,IAC1C;AAAA,EACJ;AAAA,EACA,YAAY,MAAM,QAAQ;AACtB,QAAI;AACJ,QAAI,KAAK,SAAS,QAAQ;AACtB,cAAQ,KAAK,IAAI,MAAM,MAAM,YAAY;AAAA,IAC7C,WACS,KAAK,SAAS,WAAW;AAC9B,cAAQ,KAAK,IAAI,MAAM,MAAM,eAAe;AAAA,IAChD,WACS,WAAW,UAAU;AAC1B,cAAQ,KAAK,IAAI,MAAM,MAAM,YAAY;AAAA,IAC7C,OACK;AACD,cAAQ,KAAK,IAAI,MAAM,MAAM,aAAa;AAAA,IAC9C;AACA,QAAI,MAAM,KAAK;AACf,QAAI,QAAQ;AACZ,WAAO,OAAO,IAAI,SAAS,QAAQ;AAC/B,eAAS;AACT,YAAM,IAAI;AAAA,IACd;AACA,QAAI,MAAM,SAAS,IAAI,GAAG;AACtB,YAAM,SAAS,KAAK,IAAI,MAAM,MAAM,QAAQ;AAC5C,UAAI,OAAO,QAAQ;AACf,iBAAS,OAAO,GAAG,OAAO,OAAO;AAC7B,mBAAS;AAAA,MACjB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,MAAM,MAAM,OAAO;AACf,UAAM,UAAU,KAAK,IAAI,MAAM,WAAW,YAAY;AACtD,SAAK,QAAQ,QAAQ,UAAU,KAAK,MAAM,OAAO;AACjD,QAAI;AACJ,QAAI,KAAK,SAAS,KAAK,MAAM,QAAQ;AACjC,WAAK,KAAK,IAAI;AACd,cAAQ,KAAK,IAAI,MAAM,OAAO;AAAA,IAClC,OACK;AACD,cAAQ,KAAK,IAAI,MAAM,SAAS,WAAW;AAAA,IAC/C;AACA,QAAI;AACA,WAAK,QAAQ,KAAK;AACtB,SAAK,QAAQ,KAAK,MAAM,KAAK;AAAA,EACjC;AAAA,EACA,KAAK,MAAM;AACP,QAAI,OAAO,KAAK,MAAM,SAAS;AAC/B,WAAO,OAAO,GAAG;AACb,UAAI,KAAK,MAAM,IAAI,EAAE,SAAS;AAC1B;AACJ,cAAQ;AAAA,IACZ;AACA,UAAMA,aAAY,KAAK,IAAI,MAAM,WAAW;AAC5C,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AACxC,YAAM,QAAQ,KAAK,MAAM,CAAC;AAC1B,YAAM,SAAS,KAAK,IAAI,OAAO,QAAQ;AACvC,UAAI;AACA,aAAK,QAAQ,MAAM;AACvB,WAAK,UAAU,OAAO,SAAS,KAAKA,UAAS;AAAA,IACjD;AAAA,EACJ;AAAA,EACA,QAAQ,MAAM;AACV,UAAM,OAAO,KAAK,IAAI,MAAM,QAAQ,aAAa;AACjD,UAAM,QAAQ,KAAK,IAAI,MAAM,SAAS,cAAc;AACpD,SAAK,QAAQ,OAAO,OAAO,KAAK,OAAO,QAAQ,MAAM,IAAI;AAAA,EAC7D;AAAA,EACA,KAAK,MAAMA,YAAW;AAClB,UAAM,UAAU,KAAK,IAAI,MAAM,WAAW,OAAO;AACjD,QAAIC,UAAS,KAAK,OAAO,UAAU,KAAK,SAAS,MAAM,OAAO;AAC9D,QAAI,KAAK,WAAW;AAChB,MAAAA,WAAU,KAAK,KAAK,aAAa;AAAA,IACrC;AACA,QAAID;AACA,MAAAC,WAAU;AACd,SAAK,QAAQA,SAAQ,IAAI;AAAA,EAC7B;AAAA,EACA,SAAS,MAAM;AACX,SAAK,KAAK,IAAI;AAAA,EAClB;AAAA,EACA,IAAI,MAAM,KAAK,QAAQ;AACnB,QAAI;AACJ,QAAI,CAAC;AACD,eAAS;AAEb,QAAI,KAAK;AACL,cAAQ,KAAK,KAAK,GAAG;AACrB,UAAI,OAAO,UAAU;AACjB,eAAO;AAAA,IACf;AACA,UAAM,SAAS,KAAK;AACpB,QAAI,WAAW,UAAU;AAErB,UAAI,CAAC,UAAW,OAAO,SAAS,UAAU,OAAO,UAAU,MAAO;AAC9D,eAAO;AAAA,MACX;AAEA,UAAI,UAAU,OAAO,SAAS,YAAY;AACtC,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,QAAI,CAAC;AACD,aAAO,YAAY,MAAM;AAE7B,UAAMC,QAAO,KAAK,KAAK;AACvB,QAAI,CAACA,MAAK;AACN,MAAAA,MAAK,WAAW,CAAC;AACrB,QAAI,OAAOA,MAAK,SAAS,MAAM,MAAM,aAAa;AAC9C,aAAOA,MAAK,SAAS,MAAM;AAAA,IAC/B;AACA,QAAI,WAAW,YAAY,WAAW,SAAS;AAC3C,aAAO,KAAK,YAAY,MAAM,MAAM;AAAA,IACxC,OACK;AACD,YAAM,SAAS,QAAQ,WAAW,MAAM;AACxC,UAAI,KAAK,MAAM,GAAG;AACd,gBAAQ,KAAK,MAAM,EAAEA,OAAM,IAAI;AAAA,MACnC,OACK;AACD,QAAAA,MAAK,KAAK,OAAK;AACX,kBAAQ,EAAE,KAAK,GAAG;AAClB,cAAI,OAAO,UAAU;AACjB,mBAAO;AAAA,QACf,CAAC;AAAA,MACL;AAAA,IACJ;AACA,QAAI,OAAO,UAAU;AACjB,cAAQ,YAAY,MAAM;AAC9B,IAAAA,MAAK,SAAS,MAAM,IAAI;AACxB,WAAO;AAAA,EACX;AAAA,EACA,eAAeA,OAAM;AACjB,QAAI;AACJ,IAAAA,MAAK,KAAK,OAAK;AACX,UAAI,EAAE,SAAS,EAAE,MAAM,SAAS,GAAG;AAC/B,YAAI,OAAO,EAAE,KAAK,UAAU,aAAa;AACrC,kBAAQ,EAAE,KAAK;AACf,cAAI,MAAM,SAAS,IAAI,GAAG;AACtB,oBAAQ,MAAM,QAAQ,WAAW,EAAE;AAAA,UACvC;AACA,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,QAAI;AACA,cAAQ,MAAM,QAAQ,OAAO,EAAE;AACnC,WAAO;AAAA,EACX;AAAA,EACA,iBAAiBA,OAAM,MAAM;AACzB,QAAI;AACJ,IAAAA,MAAK,aAAa,OAAK;AACnB,UAAI,OAAO,EAAE,KAAK,WAAW,aAAa;AACtC,gBAAQ,EAAE,KAAK;AACf,YAAI,MAAM,SAAS,IAAI,GAAG;AACtB,kBAAQ,MAAM,QAAQ,WAAW,EAAE;AAAA,QACvC;AACA,eAAO;AAAA,MACX;AAAA,IACJ,CAAC;AACD,QAAI,OAAO,UAAU,aAAa;AAC9B,cAAQ,KAAK,IAAI,MAAM,MAAM,YAAY;AAAA,IAC7C,WACS,OAAO;AACZ,cAAQ,MAAM,QAAQ,OAAO,EAAE;AAAA,IACnC;AACA,WAAO;AAAA,EACX;AAAA,EACA,cAAcA,OAAM,MAAM;AACtB,QAAI;AACJ,IAAAA,MAAK,UAAU,OAAK;AAChB,UAAI,OAAO,EAAE,KAAK,WAAW,aAAa;AACtC,gBAAQ,EAAE,KAAK;AACf,YAAI,MAAM,SAAS,IAAI,GAAG;AACtB,kBAAQ,MAAM,QAAQ,WAAW,EAAE;AAAA,QACvC;AACA,eAAO;AAAA,MACX;AAAA,IACJ,CAAC;AACD,QAAI,OAAO,UAAU,aAAa;AAC9B,cAAQ,KAAK,IAAI,MAAM,MAAM,YAAY;AAAA,IAC7C,WACS,OAAO;AACZ,cAAQ,MAAM,QAAQ,OAAO,EAAE;AAAA,IACnC;AACA,WAAO;AAAA,EACX;AAAA,EACA,cAAcA,OAAM;AAChB,QAAI;AACJ,IAAAA,MAAK,KAAK,OAAK;AACX,UAAI,EAAE,SAAS,QAAQ;AACnB,gBAAQ,EAAE,KAAK;AACf,YAAI,OAAO,UAAU;AACjB,iBAAO;AAAA,MACf;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,cAAcA,OAAM;AAChB,QAAI;AACJ,IAAAA,MAAK,KAAK,OAAK;AACX,UAAI,EAAE,UAAU,EAAE,WAAWA,SAAQA,MAAK,UAAU,IAAI;AACpD,YAAI,OAAO,EAAE,KAAK,WAAW,aAAa;AACtC,kBAAQ,EAAE,KAAK;AACf,cAAI,MAAM,SAAS,IAAI,GAAG;AACtB,oBAAQ,MAAM,QAAQ,WAAW,EAAE;AAAA,UACvC;AACA,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,QAAI;AACA,cAAQ,MAAM,QAAQ,OAAO,EAAE;AACnC,WAAO;AAAA,EACX;AAAA,EACA,SAASA,OAAM;AACX,QAAI;AACJ,IAAAA,MAAK,UAAU,OAAK;AAChB,UAAI,OAAO,EAAE,KAAK,YAAY,aAAa;AACvC,gBAAQ,EAAE,KAAK,QAAQ,QAAQ,WAAW,EAAE;AAC5C,eAAO;AAAA,MACX;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,aAAaA,OAAM;AACf,QAAI;AACJ,IAAAA,MAAK,KAAK,OAAK;AACX,UAAI,EAAE,SAAS,EAAE,MAAM,WAAW,GAAG;AACjC,gBAAQ,EAAE,KAAK;AACf,YAAI,OAAO,UAAU;AACjB,iBAAO;AAAA,MACf;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,UAAUA,OAAM;AACZ,QAAIA,MAAK,KAAK;AACV,aAAOA,MAAK,KAAK;AACrB,QAAI;AACJ,IAAAA,MAAK,KAAK,OAAK;AACX,YAAM,IAAI,EAAE;AACZ,UAAI,KAAK,MAAMA,SAAQ,EAAE,UAAU,EAAE,WAAWA,OAAM;AAClD,YAAI,OAAO,EAAE,KAAK,WAAW,aAAa;AACtC,gBAAM,QAAQ,EAAE,KAAK,OAAO,MAAM,IAAI;AACtC,kBAAQ,MAAM,MAAM,SAAS,CAAC;AAC9B,kBAAQ,MAAM,QAAQ,OAAO,EAAE;AAC/B,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,aAAaA,OAAM;AACf,QAAI;AACJ,IAAAA,MAAK,KAAK,OAAK;AACX,UAAI,EAAE,SAAS,EAAE,MAAM,UAAU,EAAE,KAAK,SAAS,QAAQ;AACrD,gBAAQ,EAAE,KAAK;AACf,YAAI,OAAO,UAAU;AACjB,iBAAO;AAAA,MACf;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,SAAS,MAAM,MAAM;AACjB,UAAM,QAAQ,KAAK,IAAI;AACvB,UAAM,MAAM,KAAK,KAAK,IAAI;AAC1B,QAAI,OAAO,IAAI,UAAU,OAAO;AAC5B,aAAO,IAAI;AAAA,IACf;AACA,WAAO;AAAA,EACX;AAAA,EACA,KAAK,MAAM;AACP,SAAK,KAAK,IAAI;AACd,QAAI,KAAK,KAAK;AACV,WAAK,QAAQ,KAAK,KAAK,KAAK;AAAA,EACpC;AAAA,EACA,KAAK,MAAM;AACP,SAAK,MAAM,MAAM,KAAK,SAAS,MAAM,UAAU,CAAC;AAChD,QAAI,KAAK,KAAK,cAAc;AACxB,WAAK,QAAQ,KAAK,KAAK,cAAc,MAAM,KAAK;AAAA,IACpD;AAAA,EACJ;AAAA,EACA,UAAU,MAAMF,YAAW;AAEvB,QAAI,CAAC,KAAK,KAAK,IAAI,GAAG;AAClB,YAAM,IAAI,MAAM,2BACZ,KAAK,OACL,iDAC+C;AAAA,IACvD;AAEA,SAAK,KAAK,IAAI,EAAE,MAAMA,UAAS;AAAA,EACnC;AACJ;;;ACzUO,SAAS,UAAU,MAAM,SAAS;AACrC,QAAMG,OAAM,IAAI,YAAY,OAAO;AACnC,EAAAA,KAAI,UAAU,IAAI;AACtB;AAHgB;;;ACDT,IAAM,UAAU,OAAO,SAAS;AAChC,IAAM,KAAK,OAAO,IAAI;;;ACG7B,SAAS,UAAU,KAAK,QAAQ;AAC5B,QAAM,SAAS,IAAI,IAAI,YAAY;AACnC,aAAW,KAAK,KAAK;AACjB,QAAI,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,GAAG;AAE/C;AAAA,IACJ;AACA,QAAI,MAAM;AACN;AACJ,QAAI,QAAQ,IAAI,CAAC;AACjB,UAAM,OAAO,OAAO;AACpB,QAAI,MAAM,YAAY,SAAS,UAAU;AACrC,UAAI;AACA,eAAO,CAAC,IAAI;AAAA,IACpB,WACS,MAAM,UAAU;AACrB,aAAO,CAAC,IAAI;AAAA,IAChB,WACS,MAAM,QAAQ,KAAK,GAAG;AAC3B,aAAO,CAAC,IAAI,MAAM,IAAI,OAAK,UAAU,GAAG,MAAM,CAAC;AAAA,IACnD,OACK;AACD,UAAI,SAAS,YAAY,UAAU;AAC/B,gBAAQ,UAAU,KAAK;AAC3B,aAAO,CAAC,IAAI;AAAA,IAChB;AAAA,EACJ;AACA,SAAO;AACX;AA5BS;AA6BT,SAAS,aAAa,UAAU,UAAU;AAEtC,MAAI,YACA,OAAO,SAAS,WAAW,aAAa;AACxC,WAAO,SAAS;AAAA,EACpB;AACA,MAAI,SAAS;AACb,MAAI,OAAO;AACX,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,QAAI,SAAS,SAAS,QAAQ,WAAW,SAAS,QAAQ;AACtD,eAAS;AACT;AAAA,IACJ;AACA,QAAI,SAAS,CAAC,MAAM,MAAM;AACtB,eAAS;AACT,cAAQ;AAAA,IACZ,OACK;AACD,gBAAU;AAAA,IACd;AAAA,EACJ;AACA,SAAO;AACX;AAvBS;AAwBF,IAAM,OAAN,MAAW;AAAA,EAzDlB,OAyDkB;AAAA;AAAA;AAAA,EACd,YAAY,WAAW,CAAC,GAAG;AACvB,SAAK,OAAO,CAAC;AACb,SAAK,OAAO,IAAI;AAChB,SAAK,EAAE,IAAI;AACX,eAAW,QAAQ,UAAU;AACzB,UAAI,SAAS,SAAS;AAClB,aAAK,QAAQ,CAAC;AACd,mBAAW,QAAQ,SAAS,IAAI,GAAG;AAC/B,cAAI,OAAO,KAAK,UAAU,YAAY;AAClC,iBAAK,OAAO,KAAK,MAAM,CAAC;AAAA,UAC5B,OACK;AACD,iBAAK,OAAO,IAAI;AAAA,UACpB;AAAA,QACJ;AAAA,MACJ,OACK;AACD,aAAK,IAAI,IAAI,SAAS,IAAI;AAAA,MAC9B;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,WAAW,OAAO;AACd,UAAM,cAAc;AACpB,QAAI,MAAM,SAAS,KAAK,UAAU,aAAa,KAAK,MAAM,KAAK,GAAG;AAC9D,YAAM,IAAI,KAAK;AACf,YAAM,QAAQ,MAAM,MAAM,QAAQ,cAAc,KAAK,EAAE,MAAM,IAAI,IAAI,EAAE,MAAM,IAAI,IAAI,EAAE,MAAM,MAAM,IAAI;AAAA,IAC3G;AACA,WAAO;AAAA,EACX;AAAA,EACA,MAAM,KAAK;AACP,SAAK,OAAO,YAAY,MAAM,GAAG;AACjC,WAAO;AAAA,EACX;AAAA,EACA,OAAO,YAAY,CAAC,GAAG;AACnB,eAAW,QAAQ,WAAW;AAC1B,WAAK,IAAI,IAAI,UAAU,IAAI;AAAA,IAC/B;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO,KAAK;AACR,SAAK,OAAO,aAAa,MAAM,GAAG;AAClC,WAAO;AAAA,EACX;AAAA,EACA,UAAU,aAAa;AACnB,WAAO,KAAK,KAAK;AACjB,WAAO,KAAK,KAAK;AACjB,QAAI,CAAC;AACD,aAAO,KAAK,KAAK;AAAA,EACzB;AAAA,EACA,MAAM,YAAY,CAAC,GAAG;AAClB,UAAM,SAAS,UAAU,IAAI;AAC7B,eAAW,QAAQ,WAAW;AAC1B,aAAO,IAAI,IAAI,UAAU,IAAI;AAAA,IACjC;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,YAAY,CAAC,GAAG;AACvB,UAAM,SAAS,KAAK,MAAM,SAAS;AACnC,SAAK,OAAO,YAAY,MAAM,MAAM;AACpC,WAAO;AAAA,EACX;AAAA,EACA,YAAY,YAAY,CAAC,GAAG;AACxB,UAAM,SAAS,KAAK,MAAM,SAAS;AACnC,SAAK,OAAO,aAAa,MAAM,MAAM;AACrC,WAAO;AAAA,EACX;AAAA,EACA,MAAM,SAAS,OAAO,CAAC,GAAG;AACtB,QAAI,KAAK,QAAQ;AACb,YAAM,EAAE,KAAK,MAAM,IAAI,KAAK,QAAQ,IAAI;AACxC,aAAO,KAAK,OAAO,MAAM,MAAM,SAAS,EAAE,QAAQ,MAAM,QAAQ,MAAM,MAAM,KAAK,GAAG,EAAE,QAAQ,IAAI,QAAQ,MAAM,IAAI,KAAK,GAAG,IAAI;AAAA,IACpI;AACA,WAAO,IAAI,eAAe,OAAO;AAAA,EACrC;AAAA,EACA,oBAAoB;AAChB,WAAO;AAAA,MACH,IAAI,MAAM,MAAM;AACZ,YAAI,SAAS,WAAW;AACpB,iBAAO;AAAA,QACX,WACS,SAAS,QAAQ;AACtB,iBAAO,MAAM,KAAK,KAAK,EAAE,QAAQ;AAAA,QACrC,OACK;AACD,iBAAO,KAAK,IAAI;AAAA,QACpB;AAAA,MACJ;AAAA,MACA,IAAI,MAAM,MAAM,OAAO;AACnB,YAAI,KAAK,IAAI,MAAM;AACf,iBAAO;AACX,aAAK,IAAI,IAAI;AACb,YAAI,SAAS,UACT,SAAS,WACT,SAAS,UACT,SAAS,YACT,SAAS;AAAA,QAET,SAAS,QAAQ;AACjB,eAAK,UAAU;AAAA,QACnB;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,YAAY;AACR,SAAK,OAAO,IAAI;AAAA,EACpB;AAAA,EACA,YAAY;AACR,QAAI,KAAK,OAAO,GAAG;AACf,WAAK,OAAO,IAAI;AAChB,UAAI,OAAO;AACX,aAAQ,OAAO,KAAK,QAAS;AACzB,aAAK,OAAO,IAAI;AAAA,MACpB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,OAAO;AACH,QAAI,CAAC,KAAK;AACN,aAAO;AACX,UAAM,QAAQ,KAAK,OAAO,MAAM,IAAI;AACpC,WAAO,KAAK,OAAO,MAAM,QAAQ,CAAC;AAAA,EACtC;AAAA,EACA,WAAW,MAAM;AACb,QAAI,MAAM,KAAK,OAAO;AACtB,QAAI,KAAK,OAAO;AACZ,YAAM,KAAK,eAAe,KAAK,KAAK;AAAA,IACxC,WACS,KAAK,MAAM;AAChB,YAAM,uBAAuB,KAAK,OAAO,MAAM,IAAI,MAAM,aAAa,KAAK,OAAO,MAAM,KAAK,KAAK,OAAO,KAAK,GAAG,aAAa,KAAK,OAAO,MAAM,KAAK,KAAK,OAAO,GAAG,CAAC;AACrK,YAAM,QAAQ,qBAAqB,QAAQ,KAAK,IAAI;AACpD,UAAI,UAAU;AACV,cAAM,KAAK,eAAe,KAAK;AAAA,IACvC;AACA,WAAO;AAAA,EACX;AAAA,EACA,eAAe,OAAO;AAClB,QAAI,SAAS,KAAK,OAAO,MAAM;AAC/B,QAAI,OAAO,KAAK,OAAO,MAAM;AAC7B,UAAM,SAAS,aAAa,KAAK,OAAO,MAAM,KAAK,KAAK,OAAO,KAAK;AACpE,UAAM,MAAM,SAAS;AACrB,aAAS,IAAI,QAAQ,IAAI,KAAK,KAAK;AAC/B,UAAI,KAAK,OAAO,MAAM,IAAI,CAAC,MAAM,MAAM;AACnC,iBAAS;AACT,gBAAQ;AAAA,MACZ,OACK;AACD,kBAAU;AAAA,MACd;AAAA,IACJ;AACA,WAAO,EAAE,QAAQ,KAAK;AAAA,EAC1B;AAAA,EACA,OAAO;AACH,QAAI,CAAC,KAAK;AACN,aAAO;AACX,UAAM,QAAQ,KAAK,OAAO,MAAM,IAAI;AACpC,WAAO,KAAK,OAAO,MAAM,QAAQ,CAAC;AAAA,EACtC;AAAA,EACA,QAAQ,MAAM;AACV,QAAI,QAAQ;AAAA,MACR,QAAQ,KAAK,OAAO,MAAM;AAAA,MAC1B,MAAM,KAAK,OAAO,MAAM;AAAA,IAC5B;AACA,QAAI,MAAM,KAAK,OAAO,MAChB;AAAA,MACE,QAAQ,KAAK,OAAO,IAAI,SAAS;AAAA,MACjC,MAAM,KAAK,OAAO,IAAI;AAAA,IAC1B,IACE;AAAA,MACE,QAAQ,MAAM,SAAS;AAAA,MACvB,MAAM,MAAM;AAAA,IAChB;AACJ,QAAI,KAAK,MAAM;AACX,YAAM,uBAAuB,KAAK,OAAO,MAAM,IAAI,MAAM,aAAa,KAAK,OAAO,MAAM,KAAK,KAAK,OAAO,KAAK,GAAG,aAAa,KAAK,OAAO,MAAM,KAAK,KAAK,OAAO,GAAG,CAAC;AACrK,YAAM,QAAQ,qBAAqB,QAAQ,KAAK,IAAI;AACpD,UAAI,UAAU,IAAI;AACd,gBAAQ,KAAK,eAAe,KAAK;AACjC,cAAM,KAAK,eAAe,QAAQ,KAAK,KAAK,MAAM;AAAA,MACtD;AAAA,IACJ,OACK;AACD,UAAI,KAAK,OAAO;AACZ,gBAAQ;AAAA,UACJ,QAAQ,KAAK,MAAM;AAAA,UACnB,MAAM,KAAK,MAAM;AAAA,QACrB;AAAA,MACJ,WACS,KAAK,OAAO;AACjB,gBAAQ,KAAK,eAAe,KAAK,KAAK;AAAA,MAC1C;AACA,UAAI,KAAK,KAAK;AACV,cAAM;AAAA,UACF,QAAQ,KAAK,IAAI;AAAA,UACjB,MAAM,KAAK,IAAI;AAAA,QACnB;AAAA,MACJ,WACS,OAAO,KAAK,aAAa,UAAU;AACxC,cAAM,KAAK,eAAe,KAAK,QAAQ;AAAA,MAC3C,WACS,KAAK,OAAO;AACjB,cAAM,KAAK,eAAe,KAAK,QAAQ,CAAC;AAAA,MAC5C;AAAA,IACJ;AACA,QAAI,IAAI,OAAO,MAAM,QAChB,IAAI,SAAS,MAAM,QAAQ,IAAI,UAAU,MAAM,QAAS;AACzD,YAAM,EAAE,QAAQ,MAAM,SAAS,GAAG,MAAM,MAAM,KAAK;AAAA,IACvD;AACA,WAAO,EAAE,KAAK,MAAM;AAAA,EACxB;AAAA,EACA,IAAI,MAAM,aAAa;AACnB,UAAMC,OAAM,IAAI,YAAY;AAC5B,WAAOA,KAAI,IAAI,MAAM,MAAM,WAAW;AAAA,EAC1C;AAAA,EACA,SAAS;AACL,QAAI,KAAK,QAAQ;AACb,WAAK,OAAO,YAAY,IAAI;AAAA,IAChC;AACA,SAAK,SAAS;AACd,WAAO;AAAA,EACX;AAAA,EACA,eAAe,OAAO;AAClB,QAAI,KAAK,QAAQ;AACb,UAAI,WAAW;AACf,UAAI,YAAY;AAChB,iBAAW,QAAQ,OAAO;AACtB,YAAI,SAAS,MAAM;AACf,sBAAY;AAAA,QAChB,WACS,WAAW;AAChB,eAAK,OAAO,YAAY,UAAU,IAAI;AACtC,qBAAW;AAAA,QACf,OACK;AACD,eAAK,OAAO,aAAa,UAAU,IAAI;AAAA,QAC3C;AAAA,MACJ;AACA,UAAI,CAAC,WAAW;AACZ,aAAK,OAAO;AAAA,MAChB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO;AACH,QAAI,SAAS;AACb,WAAO,OAAO,UAAU,OAAO,OAAO,SAAS,YAAY;AACvD,eAAS,OAAO;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO,GAAG,QAAQ;AACd,UAAM,QAAQ,CAAC;AACf,UAAM,aAAa,UAAU;AAC7B,aAAS,UAAU,oBAAI,IAAI;AAC3B,QAAI,kBAAkB;AACtB,eAAW,QAAQ,MAAM;AACrB,UAAI,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,IAAI,GAAG;AAEnD;AAAA,MACJ;AACA,UAAI,SAAS,YAAY,SAAS;AAC9B;AACJ,YAAM,QAAQ,KAAK,IAAI;AACvB,UAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,cAAM,IAAI,IAAI,MAAM,IAAI,OAAK;AACzB,cAAI,OAAO,MAAM,YAAY,EAAE,QAAQ;AACnC,mBAAO,EAAE,OAAO,MAAM,MAAM;AAAA,UAChC,OACK;AACD,mBAAO;AAAA,UACX;AAAA,QACJ,CAAC;AAAA,MACL,WACS,OAAO,UAAU,YAAY,MAAM,QAAQ;AAChD,cAAM,IAAI,IAAI,MAAM,OAAO,MAAM,MAAM;AAAA,MAC3C,WACS,SAAS,UAAU;AACxB,YAAI,UAAU,OAAO,IAAI,MAAM,KAAK;AACpC,YAAI,WAAW,MAAM;AACjB,oBAAU;AACV,iBAAO,IAAI,MAAM,OAAO,eAAe;AACvC;AAAA,QACJ;AACA,cAAM,IAAI,IAAI;AAAA,UACV,KAAK,MAAM;AAAA,UACX;AAAA,UACA,OAAO,MAAM;AAAA,QACjB;AAAA,MACJ,OACK;AACD,cAAM,IAAI,IAAI;AAAA,MAClB;AAAA,IACJ;AACA,QAAI,YAAY;AACZ,YAAM,SAAS,CAAC,GAAG,OAAO,KAAK,CAAC,EAAE,IAAI,WAAS,MAAM,OAAO,CAAC;AAAA,IACjE;AACA,WAAO;AAAA,EACX;AAAA,EACA,UAAU;AACN,QAAI,CAAC,KAAK,YAAY;AAClB,WAAK,aAAa,IAAI,MAAM,MAAM,KAAK,kBAAkB,CAAC;AAAA,IAC9D;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,SAAS,cAAc,WAAW;AAC9B,QAAI,YAAY;AACZ,oBAAc,YAAY;AAC9B,QAAI,SAAS;AACb,gBAAY,MAAM,OAAK;AACnB,gBAAU;AAAA,IACd,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,KAAK,QAAQ,MAAM,MAAM;AACrB,UAAM,OAAO,EAAE,MAAM,KAAK;AAC1B,eAAW,KAAK;AACZ,WAAK,CAAC,IAAI,KAAK,CAAC;AACpB,WAAO,OAAO,KAAK,MAAM,IAAI;AAAA,EACjC;AAAA,EACA,IAAI,UAAU;AACV,WAAO;AAAA,EACX;AACJ;;;ACzXO,IAAM,UAAN,cAAsB,KAAK;AAAA,EADlC,OACkC;AAAA;AAAA;AAAA,EAC9B,YAAY,UAAU;AAClB,UAAM,QAAQ;AACd,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACLO,IAAM,cAAN,cAA0B,KAAK;AAAA,EADtC,OACsC;AAAA;AAAA;AAAA,EAClC,YAAY,UAAU;AAClB,QAAI,YACA,OAAO,SAAS,UAAU,eAC1B,OAAO,SAAS,UAAU,UAAU;AACpC,iBAAW,EAAE,GAAG,UAAU,OAAO,OAAO,SAAS,KAAK,EAAE;AAAA,IAC5D;AACA,UAAM,QAAQ;AACd,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,IAAI,WAAW;AACX,WAAO,KAAK,KAAK,WAAW,IAAI,KAAK,KAAK,KAAK,CAAC,MAAM;AAAA,EAC1D;AACJ;;;ACVA,IAAI;AAAJ,IAAY;AAAZ,IAAmB;AAAnB,IAAyB;AACzB,SAAS,YAAY,OAAO;AACxB,SAAO,MAAM,IAAI,OAAK;AAClB,QAAI,EAAE;AACF,QAAE,QAAQ,YAAY,EAAE,KAAK;AACjC,WAAO,EAAE;AACT,WAAO;AAAA,EACX,CAAC;AACL;AAPS;AAQT,SAAS,cAAc,MAAM;AACzB,OAAK,OAAO,IAAI;AAChB,MAAI,KAAK,QAAQ,OAAO;AACpB,eAAW,KAAK,KAAK,QAAQ,OAAO;AAChC,oBAAc,CAAC;AAAA,IACnB;AAAA,EACJ;AACJ;AAPS;AAQF,IAAM,YAAN,MAAM,mBAAkB,KAAK;AAAA,EArBpC,OAqBoC;AAAA;AAAA;AAAA,EAChC,UAAU,UAAU;AAChB,eAAW,SAAS,UAAU;AAC1B,YAAM,QAAQ,KAAK,UAAU,OAAO,KAAK,IAAI;AAC7C,iBAAW,QAAQ;AACf,aAAK,QAAQ,MAAM,KAAK,IAAI;AAAA,IACpC;AACA,SAAK,UAAU;AACf,WAAO;AAAA,EACX;AAAA,EACA,UAAU,aAAa;AACnB,UAAM,UAAU,WAAW;AAC3B,QAAI,KAAK,OAAO;AACZ,iBAAW,QAAQ,KAAK;AACpB,aAAK,UAAU,WAAW;AAAA,IAClC;AAAA,EACJ;AAAA,EACA,KAAK,UAAU;AACX,QAAI,CAAC,KAAK,QAAQ;AACd,aAAO;AACX,UAAM,WAAW,KAAK,YAAY;AAClC,QAAI,OAAO;AACX,WAAO,KAAK,QAAQ,QAAQ,IAAI,KAAK,QAAQ,MAAM,QAAQ;AACvD,cAAQ,KAAK,QAAQ,QAAQ;AAC7B,eAAS,SAAS,KAAK,QAAQ,MAAM,KAAK,GAAG,KAAK;AAClD,UAAI,WAAW;AACX;AACJ,WAAK,QAAQ,QAAQ,KAAK;AAAA,IAC9B;AACA,WAAO,KAAK,QAAQ,QAAQ;AAC5B,WAAO;AAAA,EACX;AAAA,EACA,MAAM,WAAW;AACb,WAAO,KAAK,MAAM,MAAM,SAAS;AAAA,EACrC;AAAA,EACA,cAAc;AACV,QAAI,CAAC,KAAK;AACN,WAAK,WAAW;AACpB,QAAI,CAAC,KAAK;AACN,WAAK,UAAU,CAAC;AACpB,SAAK,YAAY;AACjB,UAAM,WAAW,KAAK;AACtB,SAAK,QAAQ,QAAQ,IAAI;AACzB,WAAO;AAAA,EACX;AAAA,EACA,oBAAoB;AAChB,WAAO;AAAA,MACH,IAAI,MAAM,MAAM;AACZ,YAAI,SAAS,WAAW;AACpB,iBAAO;AAAA,QACX,WACS,CAAC,KAAK,IAAI,GAAG;AAClB,iBAAO,KAAK,IAAI;AAAA,QACpB,WACS,SAAS,UACb,OAAO,SAAS,YAAY,KAAK,WAAW,MAAM,GAAI;AACvD,iBAAO,IAAI,SAAS;AAChB,mBAAO,KAAK,IAAI,EAAE,GAAG,KAAK,IAAI,OAAK;AAC/B,kBAAI,OAAO,MAAM,YAAY;AACzB,uBAAO,CAAC,OAAO,UAAU,EAAE,MAAM,QAAQ,GAAG,KAAK;AAAA,cACrD,OACK;AACD,uBAAO;AAAA,cACX;AAAA,YACJ,CAAC,CAAC;AAAA,UACN;AAAA,QACJ,WACS,SAAS,WAAW,SAAS,QAAQ;AAC1C,iBAAO,QAAM;AACT,mBAAO,KAAK,IAAI,EAAE,CAAC,UAAU,UAAU,GAAG,MAAM,QAAQ,GAAG,GAAG,KAAK,CAAC;AAAA,UACxE;AAAA,QACJ,WACS,SAAS,QAAQ;AACtB,iBAAO,MAAM,KAAK,KAAK,EAAE,QAAQ;AAAA,QACrC,WACS,SAAS,SAAS;AACvB,iBAAO,KAAK,MAAM,IAAI,OAAK,EAAE,QAAQ,CAAC;AAAA,QAC1C,WACS,SAAS,WAAW,SAAS,QAAQ;AAC1C,iBAAO,KAAK,IAAI,EAAE,QAAQ;AAAA,QAC9B,OACK;AACD,iBAAO,KAAK,IAAI;AAAA,QACpB;AAAA,MACJ;AAAA,MACA,IAAI,MAAM,MAAM,OAAO;AACnB,YAAI,KAAK,IAAI,MAAM;AACf,iBAAO;AACX,aAAK,IAAI,IAAI;AACb,YAAI,SAAS,UAAU,SAAS,YAAY,SAAS,YAAY;AAC7D,eAAK,UAAU;AAAA,QACnB;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,MAAM,OAAO;AACT,QAAI,OAAO,UAAU;AACjB,aAAO;AACX,QAAI,MAAM;AACN,cAAQ,MAAM;AAClB,WAAO,KAAK,QAAQ,MAAM,QAAQ,KAAK;AAAA,EAC3C;AAAA,EACA,YAAY,OAAO,KAAK;AACpB,QAAI,aAAa,KAAK,MAAM,KAAK;AACjC,UAAM,QAAQ,KAAK,UAAU,KAAK,KAAK,QAAQ,MAAM,UAAU,CAAC,EAAE,QAAQ;AAC1E,iBAAa,KAAK,MAAM,KAAK;AAC7B,eAAW,QAAQ;AACf,WAAK,QAAQ,MAAM,OAAO,aAAa,GAAG,GAAG,IAAI;AACrD,QAAI;AACJ,eAAWC,OAAM,KAAK,SAAS;AAC3B,cAAQ,KAAK,QAAQA,GAAE;AACvB,UAAI,aAAa,OAAO;AACpB,aAAK,QAAQA,GAAE,IAAI,QAAQ,MAAM;AAAA,MACrC;AAAA,IACJ;AACA,SAAK,UAAU;AACf,WAAO;AAAA,EACX;AAAA,EACA,aAAa,OAAO,KAAK;AACrB,QAAI,aAAa,KAAK,MAAM,KAAK;AACjC,UAAM,OAAO,eAAe,IAAI,YAAY;AAC5C,UAAM,QAAQ,KAAK,UAAU,KAAK,KAAK,QAAQ,MAAM,UAAU,GAAG,IAAI,EAAE,QAAQ;AAChF,iBAAa,KAAK,MAAM,KAAK;AAC7B,eAAW,QAAQ;AACf,WAAK,QAAQ,MAAM,OAAO,YAAY,GAAG,IAAI;AACjD,QAAI;AACJ,eAAWA,OAAM,KAAK,SAAS;AAC3B,cAAQ,KAAK,QAAQA,GAAE;AACvB,UAAI,cAAc,OAAO;AACrB,aAAK,QAAQA,GAAE,IAAI,QAAQ,MAAM;AAAA,MACrC;AAAA,IACJ;AACA,SAAK,UAAU;AACf,WAAO;AAAA,EACX;AAAA,EACA,UAAU,OAAO,QAAQ;AACrB,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,YAAY,MAAM,KAAK,EAAE,KAAK;AAAA,IAC1C,WACS,OAAO,UAAU,aAAa;AACnC,cAAQ,CAAC;AAAA,IACb,WACS,MAAM,QAAQ,KAAK,GAAG;AAC3B,cAAQ,MAAM,MAAM,CAAC;AACrB,iBAAW,KAAK,OAAO;AACnB,YAAI,EAAE;AACF,YAAE,OAAO,YAAY,GAAG,QAAQ;AAAA,MACxC;AAAA,IACJ,WACS,MAAM,SAAS,UAAU,KAAK,SAAS,YAAY;AACxD,cAAQ,MAAM,MAAM,MAAM,CAAC;AAC3B,iBAAW,KAAK,OAAO;AACnB,YAAI,EAAE;AACF,YAAE,OAAO,YAAY,GAAG,QAAQ;AAAA,MACxC;AAAA,IACJ,WACS,MAAM,MAAM;AACjB,cAAQ,CAAC,KAAK;AAAA,IAClB,WACS,MAAM,MAAM;AACjB,UAAI,OAAO,MAAM,UAAU,aAAa;AACpC,cAAM,IAAI,MAAM,wCAAwC;AAAA,MAC5D,WACS,OAAO,MAAM,UAAU,UAAU;AACtC,cAAM,QAAQ,OAAO,MAAM,KAAK;AAAA,MACpC;AACA,cAAQ,CAAC,IAAI,YAAY,KAAK,CAAC;AAAA,IACnC,WACS,MAAM,YAAY,MAAM,WAAW;AACxC,cAAQ,CAAC,IAAI,KAAK,KAAK,CAAC;AAAA,IAC5B,WACS,MAAM,MAAM;AACjB,cAAQ,CAAC,IAAI,OAAO,KAAK,CAAC;AAAA,IAC9B,WACS,MAAM,MAAM;AACjB,cAAQ,CAAC,IAAI,QAAQ,KAAK,CAAC;AAAA,IAC/B,OACK;AACD,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACxD;AACA,UAAM,YAAY,MAAM,IAAI,OAAK;AAE7B,UAAI,CAAC,EAAE,EAAE;AACL,mBAAU,QAAQ,CAAC;AACvB,UAAI,EAAE;AACN,UAAI,EAAE;AACF,UAAE,OAAO,YAAY,CAAC;AAC1B,UAAI,EAAE,OAAO;AACT,sBAAc,CAAC;AACnB,UAAI,CAAC,EAAE;AACH,UAAE,OAAO,CAAC;AACd,UAAI,OAAO,EAAE,KAAK,WAAW,aAAa;AACtC,YAAI,UAAU,OAAO,OAAO,KAAK,WAAW,aAAa;AACrD,YAAE,KAAK,SAAS,OAAO,KAAK,OAAO,QAAQ,OAAO,EAAE;AAAA,QACxD;AAAA,MACJ;AACA,QAAE,SAAS,KAAK;AAChB,aAAO;AAAA,IACX,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,WAAW,UAAU;AACjB,eAAW,SAAS,QAAQ;AAC5B,eAAW,SAAS,UAAU;AAC1B,YAAM,QAAQ,KAAK,UAAU,OAAO,KAAK,OAAO,SAAS,EAAE,QAAQ;AACnE,iBAAW,QAAQ;AACf,aAAK,QAAQ,MAAM,QAAQ,IAAI;AACnC,iBAAWA,OAAM,KAAK,SAAS;AAC3B,aAAK,QAAQA,GAAE,IAAI,KAAK,QAAQA,GAAE,IAAI,MAAM;AAAA,MAChD;AAAA,IACJ;AACA,SAAK,UAAU;AACf,WAAO;AAAA,EACX;AAAA,EACA,KAAK,OAAO;AACR,UAAM,SAAS;AACf,SAAK,QAAQ,MAAM,KAAK,KAAK;AAC7B,WAAO;AAAA,EACX;AAAA,EACA,YAAY;AACR,eAAW,QAAQ,KAAK,QAAQ;AAC5B,WAAK,SAAS;AAClB,SAAK,QAAQ,QAAQ,CAAC;AACtB,SAAK,UAAU;AACf,WAAO;AAAA,EACX;AAAA,EACA,YAAY,OAAO;AACf,YAAQ,KAAK,MAAM,KAAK;AACxB,SAAK,QAAQ,MAAM,KAAK,EAAE,SAAS;AACnC,SAAK,QAAQ,MAAM,OAAO,OAAO,CAAC;AAClC,QAAI;AACJ,eAAWA,OAAM,KAAK,SAAS;AAC3B,cAAQ,KAAK,QAAQA,GAAE;AACvB,UAAI,SAAS,OAAO;AAChB,aAAK,QAAQA,GAAE,IAAI,QAAQ;AAAA,MAC/B;AAAA,IACJ;AACA,SAAK,UAAU;AACf,WAAO;AAAA,EACX;AAAA,EACA,cAAc,SAAS,MAAM,UAAU;AACnC,QAAI,CAAC,UAAU;AACX,iBAAW;AACX,aAAO,CAAC;AAAA,IACZ;AACA,SAAK,UAAU,UAAQ;AACnB,UAAI,KAAK,SAAS,CAAC,KAAK,MAAM,SAAS,KAAK,IAAI;AAC5C;AACJ,UAAI,KAAK,QAAQ,CAAC,KAAK,MAAM,SAAS,KAAK,IAAI;AAC3C;AACJ,WAAK,QAAQ,KAAK,MAAM,QAAQ,SAAS,QAAQ;AAAA,IACrD,CAAC;AACD,SAAK,UAAU;AACf,WAAO;AAAA,EACX;AAAA,EACA,KAAK,WAAW;AACZ,WAAO,KAAK,MAAM,KAAK,SAAS;AAAA,EACpC;AAAA,EACA,KAAK,UAAU;AACX,WAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,UAAI;AACJ,UAAI;AACA,iBAAS,SAAS,OAAO,CAAC;AAAA,MAC9B,SACO,GAAG;AACN,cAAM,MAAM,WAAW,CAAC;AAAA,MAC5B;AACA,UAAI,WAAW,SAAS,MAAM,MAAM;AAChC,iBAAS,MAAM,KAAK,QAAQ;AAAA,MAChC;AACA,aAAO;AAAA,IACX,CAAC;AAAA,EACL;AAAA,EACA,YAAY,MAAM,UAAU;AACxB,QAAI,CAAC,UAAU;AACX,iBAAW;AACX,aAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,YAAI,MAAM,SAAS,UAAU;AACzB,iBAAO,SAAS,OAAO,CAAC;AAAA,QAC5B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAI,gBAAgB,QAAQ;AACxB,aAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,YAAI,MAAM,SAAS,YAAY,KAAK,KAAK,MAAM,IAAI,GAAG;AAClD,iBAAO,SAAS,OAAO,CAAC;AAAA,QAC5B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,UAAI,MAAM,SAAS,YAAY,MAAM,SAAS,MAAM;AAChD,eAAO,SAAS,OAAO,CAAC;AAAA,MAC5B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,aAAa,UAAU;AACnB,WAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,UAAI,MAAM,SAAS,WAAW;AAC1B,eAAO,SAAS,OAAO,CAAC;AAAA,MAC5B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,UAAU,MAAM,UAAU;AACtB,QAAI,CAAC,UAAU;AACX,iBAAW;AACX,aAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,YAAI,MAAM,SAAS,QAAQ;AACvB,iBAAO,SAAS,OAAO,CAAC;AAAA,QAC5B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAI,gBAAgB,QAAQ;AACxB,aAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,YAAI,MAAM,SAAS,UAAU,KAAK,KAAK,MAAM,IAAI,GAAG;AAChD,iBAAO,SAAS,OAAO,CAAC;AAAA,QAC5B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,UAAI,MAAM,SAAS,UAAU,MAAM,SAAS,MAAM;AAC9C,eAAO,SAAS,OAAO,CAAC;AAAA,MAC5B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,UAAUC,WAAU,UAAU;AAC1B,QAAI,CAAC,UAAU;AACX,iBAAWA;AACX,aAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,YAAI,MAAM,SAAS,QAAQ;AACvB,iBAAO,SAAS,OAAO,CAAC;AAAA,QAC5B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAIA,qBAAoB,QAAQ;AAC5B,aAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,YAAI,MAAM,SAAS,UAAUA,UAAS,KAAK,MAAM,QAAQ,GAAG;AACxD,iBAAO,SAAS,OAAO,CAAC;AAAA,QAC5B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO,KAAK,KAAK,CAAC,OAAO,MAAM;AAC3B,UAAI,MAAM,SAAS,UAAU,MAAM,aAAaA,WAAU;AACtD,eAAO,SAAS,OAAO,CAAC;AAAA,MAC5B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,IAAI,QAAQ;AACR,QAAI,CAAC,KAAK,QAAQ;AACd,aAAO;AACX,WAAO,KAAK,QAAQ,MAAM,CAAC;AAAA,EAC/B;AAAA,EACA,IAAI,OAAO;AACP,QAAI,CAAC,KAAK,QAAQ;AACd,aAAO;AACX,WAAO,KAAK,QAAQ,MAAM,KAAK,QAAQ,MAAM,SAAS,CAAC;AAAA,EAC3D;AACJ;AACA,UAAU,gBAAgB,eAAa;AACnC,UAAQ;AACZ;AACA,UAAU,eAAe,eAAa;AAClC,SAAO;AACX;AACA,UAAU,iBAAiB,eAAa;AACpC,WAAS;AACb;AACA,UAAU,eAAe,eAAa;AAClC,SAAO;AACX;AAEA,UAAU,UAAU,UAAQ;AACxB,MAAI,KAAK,SAAS,UAAU;AACxB,WAAO,eAAe,MAAM,OAAO,SAAS;AAAA,EAChD,WACS,KAAK,SAAS,QAAQ;AAC3B,WAAO,eAAe,MAAM,KAAK,SAAS;AAAA,EAC9C,WACS,KAAK,SAAS,QAAQ;AAC3B,WAAO,eAAe,MAAM,YAAY,SAAS;AAAA,EACrD,WACS,KAAK,SAAS,WAAW;AAC9B,WAAO,eAAe,MAAM,QAAQ,SAAS;AAAA,EACjD,WACS,KAAK,SAAS,QAAQ;AAC3B,WAAO,eAAe,MAAM,KAAK,SAAS;AAAA,EAC9C;AACA,OAAK,EAAE,IAAI;AACX,MAAI,KAAK,OAAO;AACZ,SAAK,MAAM,QAAQ,WAAS;AACxB,gBAAU,QAAQ,KAAK;AAAA,IAC3B,CAAC;AAAA,EACL;AACJ;;;AC7ZO,IAAMC,UAAN,cAAqB,UAAU;AAAA,EADtC,OACsC;AAAA;AAAA;AAAA,EAClC,YAAY,UAAU;AAClB,UAAM,QAAQ;AACd,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,UAAU,UAAU;AAChB,QAAI,CAAC,KAAK,QAAQ;AACd,WAAK,QAAQ,CAAC;AAClB,WAAO,MAAM,OAAO,GAAG,QAAQ;AAAA,EACnC;AAAA,EACA,WAAW,UAAU;AACjB,QAAI,CAAC,KAAK,QAAQ;AACd,WAAK,QAAQ,CAAC;AAClB,WAAO,MAAM,QAAQ,GAAG,QAAQ;AAAA,EACpC;AACJ;AACA,UAAU,eAAeA,OAAM;;;AChB/B,IAAI;AAAJ,IAAgB;AACT,IAAMC,QAAN,cAAmB,UAAU;AAAA,EAFpC,OAEoC;AAAA;AAAA;AAAA,EAChC,YAAY,UAAU;AAClB,UAAM,QAAQ;AACd,SAAK,OAAO;AACZ,QAAI,CAAC,KAAK;AACN,WAAK,QAAQ,CAAC;AAAA,EACtB;AAAA,EACA,UAAU,OAAO,QAAQ,MAAM;AAC3B,UAAM,QAAQ,MAAM,UAAU,KAAK;AACnC,QAAI,QAAQ;AACR,UAAI,SAAS,WAAW;AACpB,YAAI,KAAK,MAAM,SAAS,GAAG;AACvB,iBAAO,KAAK,SAAS,KAAK,MAAM,CAAC,EAAE,KAAK;AAAA,QAC5C,OACK;AACD,iBAAO,OAAO,KAAK;AAAA,QACvB;AAAA,MACJ,WACS,KAAK,UAAU,QAAQ;AAC5B,mBAAW,QAAQ,OAAO;AACtB,eAAK,KAAK,SAAS,OAAO,KAAK;AAAA,QACnC;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,YAAY,OAAO,QAAQ;AACvB,UAAM,QAAQ,KAAK,MAAM,KAAK;AAC9B,QAAI,CAAC,UAAU,UAAU,KAAK,KAAK,MAAM,SAAS,GAAG;AACjD,WAAK,MAAM,CAAC,EAAE,KAAK,SAAS,KAAK,MAAM,KAAK,EAAE,KAAK;AAAA,IACvD;AACA,WAAO,MAAM,YAAY,KAAK;AAAA,EAClC;AAAA,EACA,SAAS,OAAO,CAAC,GAAG;AAChB,UAAM,OAAO,IAAI,WAAW,IAAI,UAAU,GAAG,MAAM,IAAI;AACvD,WAAO,KAAK,UAAU;AAAA,EAC1B;AAAA,EACA,OAAO,qBAAqB,sCAAa;AACrC,iBAAa;AAAA,EACjB,GAF4B;AAAA,EAG5B,OAAO,oBAAoB,sCAAa;AACpC,gBAAY;AAAA,EAChB,GAF2B;AAG/B;AACA,UAAU,aAAaA,KAAI;;;AC9CpB,IAAM,OAAO;AAAA,EAChB,MAAMC,SAAQ;AACV,WAAO,KAAK,MAAMA,SAAQ,CAAC,GAAG,GAAG,IAAI;AAAA,EACzC;AAAA,EACA,MAAMA,SAAQ;AACV,UAAM,SAAS,CAAC,KAAK,MAAM,GAAI;AAC/B,WAAO,KAAK,MAAMA,SAAQ,MAAM;AAAA,EACpC;AAAA,EACA,MAAMA,SAAQ,YAAY,MAAM;AAC5B,UAAM,QAAQ,CAAC;AACf,QAAI,UAAU;AACd,QAAI,QAAQ;AACZ,QAAI,OAAO;AACX,QAAI,UAAU;AACd,QAAI,YAAY;AAChB,QAAI,SAAS;AACb,eAAW,UAAUA,SAAQ;AACzB,UAAI,QAAQ;AACR,iBAAS;AAAA,MACb,WACS,WAAW,MAAM;AACtB,iBAAS;AAAA,MACb,WACS,SAAS;AACd,YAAI,WAAW,WAAW;AACtB,oBAAU;AAAA,QACd;AAAA,MACJ,WACS,WAAW,OAAO,WAAW,KAAK;AACvC,kBAAU;AACV,oBAAY;AAAA,MAChB,WACS,WAAW,KAAK;AACrB,gBAAQ;AAAA,MACZ,WACS,WAAW,KAAK;AACrB,YAAI,OAAO;AACP,kBAAQ;AAAA,MAChB,WACS,SAAS,GAAG;AACjB,YAAI,WAAW,SAAS,MAAM;AAC1B,kBAAQ;AAAA,MAChB;AACA,UAAI,OAAO;AACP,YAAI,YAAY;AACZ,gBAAM,KAAK,QAAQ,KAAK,CAAC;AAC7B,kBAAU;AACV,gBAAQ;AAAA,MACZ,OACK;AACD,mBAAW;AAAA,MACf;AAAA,IACJ;AACA,QAAI,QAAQ,YAAY;AACpB,YAAM,KAAK,QAAQ,KAAK,CAAC;AAC7B,WAAO;AAAA,EACX;AACJ;;;ACvDO,IAAMC,QAAN,cAAmB,UAAU;AAAA,EAFpC,OAEoC;AAAA;AAAA;AAAA,EAChC,YAAY,UAAU;AAClB,UAAM,QAAQ;AACd,SAAK,OAAO;AACZ,QAAI,CAAC,KAAK;AACN,WAAK,QAAQ,CAAC;AAAA,EACtB;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,MAAM,KAAK,QAAQ;AAAA,EACnC;AAAA,EACA,IAAI,UAAU,QAAQ;AAClB,UAAM,QAAQ,KAAK,WAAW,KAAK,SAAS,MAAM,MAAM,IAAI;AAC5D,UAAM,MAAM,QAAQ,MAAM,CAAC,IAAI,MAAM,KAAK,IAAI,WAAW,YAAY;AACrE,SAAK,WAAW,OAAO,KAAK,GAAG;AAAA,EACnC;AACJ;AACA,UAAU,aAAaA,KAAI;;;ACjB3B,IAAM,kBAAkB,OAAO,iBAAiB;AACzC,IAAM,QAAN,MAAY;AAAA,EAFnB,OAEmB;AAAA;AAAA;AAAA,EACf,YAAY,KAAK,OAAO,CAAC,GAAG;AACxB,QAAI,QAAQ,QACR,OAAO,QAAQ,eACd,OAAO,QAAQ,YAAY,CAAC,IAAI,UAAW;AAC5C,YAAM,IAAI,MAAM,oBAAoB,GAAG,wBAAwB;AAAA,IACnE;AACA,SAAK,MAAM,IAAI,SAAS;AACxB,QAAI,KAAK,IAAI,CAAC,MAAM,YAAY,KAAK,IAAI,CAAC,MAAM,UAAU;AACtD,WAAK,SAAS;AACd,WAAK,MAAM,KAAK,IAAI,MAAM,CAAC;AAAA,IAC/B,OACK;AACD,WAAK,SAAS;AAAA,IAClB;AACA,QAAI,KAAK;AACL,WAAK,IAAI,OAAO,KAAK;AAAA,EAC7B;AAAA,EACA,MAAM,SAAS,MAAM,QAAQ,OAAO,CAAC,GAAG;AACpC,QAAI,WAAW,SAAS;AACxB,QAAI,QAAQ,OAAO,SAAS,UAAU;AAClC,YAAM,QAAQ;AACd,YAAM,MAAM;AACZ,UAAI,OAAO,MAAM,WAAW,UAAU;AAClC,cAAM,MAAM,KAAK,WAAW,MAAM,MAAM;AACxC,eAAO,IAAI;AACX,iBAAS,IAAI;AAAA,MACjB,OACK;AACD,eAAO,MAAM;AACb,iBAAS,MAAM;AAAA,MACnB;AACA,UAAI,OAAO,IAAI,WAAW,UAAU;AAChC,cAAM,MAAM,KAAK,WAAW,IAAI,MAAM;AACtC,kBAAU,IAAI;AACd,oBAAY,IAAI;AAAA,MACpB,OACK;AACD,kBAAU,IAAI;AACd,oBAAY,IAAI;AAAA,MACpB;AAAA,IACJ,WACS,CAAC,QAAQ;AACd,YAAM,MAAM,KAAK,WAAW,IAAI;AAChC,aAAO,IAAI;AACX,eAAS,IAAI;AAAA,IACjB;AACA,UAAM,SAAS,KAAK,OAAO,MAAM,QAAQ,SAAS,SAAS;AAC3D,QAAI,QAAQ;AACR,eAAS,IAAI,eAAe,SAAS,OAAO,YAAY,SAClD,OAAO,OACP,EAAE,QAAQ,OAAO,QAAQ,MAAM,OAAO,KAAK,GAAG,OAAO,YAAY,SACjE,OAAO,SACP,EAAE,QAAQ,OAAO,WAAW,MAAM,OAAO,QAAQ,GAAG,OAAO,QAAQ,OAAO,MAAM,KAAK,MAAM;AAAA,IACrG,OACK;AACD,eAAS,IAAI,eAAe,SAAS,YAAY,SAAY,OAAO,EAAE,QAAQ,KAAK,GAAG,YAAY,SAAY,SAAS,EAAE,QAAQ,WAAW,MAAM,QAAQ,GAAG,KAAK,KAAK,KAAK,MAAM,KAAK,MAAM;AAAA,IACjM;AACA,WAAO,QAAQ,EAAE,QAAQ,WAAW,SAAS,MAAM,QAAQ,KAAK,IAAI;AACpE,QAAI,KAAK,MAAM;AACX,aAAO,MAAM,OAAO,KAAK;AAAA,IAC7B;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,QAAQ;AACf,QAAI,UAAU;AACd,QAAI,CAAC,KAAK,eAAe,GAAG;AACxB,YAAM,QAAQ,KAAK,IAAI,MAAM,IAAI;AACjC,oBAAc,IAAI,MAAM,MAAM,MAAM;AACpC,UAAI,YAAY;AAChB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAC1C,oBAAY,CAAC,IAAI;AACjB,qBAAa,MAAM,CAAC,EAAE,SAAS;AAAA,MACnC;AACA,WAAK,eAAe,IAAI;AAAA,IAC5B,OACK;AACD,oBAAc,KAAK,eAAe;AAAA,IACtC;AACA,eAAW,YAAY,YAAY,SAAS,CAAC;AAC7C,QAAI,MAAM;AACV,QAAI,UAAU,UAAU;AACpB,YAAM,YAAY,SAAS;AAAA,IAC/B,OACK;AACD,UAAI,MAAM,YAAY,SAAS;AAC/B,UAAI;AACJ,aAAO,MAAM,KAAK;AACd,cAAM,OAAQ,MAAM,OAAQ;AAC5B,YAAI,SAAS,YAAY,GAAG,GAAG;AAC3B,gBAAM,MAAM;AAAA,QAChB,WACS,UAAU,YAAY,MAAM,CAAC,GAAG;AACrC,gBAAM,MAAM;AAAA,QAChB,OACK;AACD,gBAAM;AACN;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,MACH,KAAK,SAAS,YAAY,GAAG,IAAI;AAAA,MACjC,MAAM,MAAM;AAAA,IAChB;AAAA,EACJ;AAAA,EACA,OAAO,MAAM,QAAQ,SAAS,WAAW;AACrC,QAAI,CAAC,KAAK;AACN,aAAO;AACX,UAAM,WAAW,KAAK,IAAI,SAAS;AACnC,UAAM,OAAO,SAAS,oBAAoB,EAAE,QAAQ,KAAK,CAAC;AAC1D,QAAI,CAAC,KAAK;AACN,aAAO;AACX,QAAI;AACJ,QAAI,OAAO,YAAY,UAAU;AAC7B,WAAK,SAAS,oBAAoB,EAAE,QAAQ,WAAW,MAAM,QAAQ,CAAC;AAAA,IAC1E;AACA,QAAI;AACJ,cAAU,IAAI,IAAI,KAAK,QAAQ,KAAK,IAAI,SAAS,EAAE,cAAc,cAAc,KAAK,IAAI,OAAO,CAAC;AAChG,UAAM,SAAS;AAAA,MACX,QAAQ,KAAK;AAAA,MACb,WAAW,MAAM,GAAG;AAAA,MACpB,SAAS,MAAM,GAAG;AAAA,MAClB,MAAM,KAAK;AAAA,MACX,KAAK,QAAQ,SAAS;AAAA,IAC1B;AACA,UAAM,SAAS,SAAS,iBAAiB,KAAK,MAAM;AACpD,QAAI;AACA,aAAO,SAAS;AACpB,WAAO;AAAA,EACX;AAAA,EACA,SAAS;AACL,UAAM,OAAO,CAAC;AACd,eAAW,QAAQ,CAAC,UAAU,OAAO,QAAQ,IAAI,GAAG;AAChD,UAAI,KAAK,IAAI,KAAK,MAAM;AACpB,aAAK,IAAI,IAAI,KAAK,IAAI;AAAA,MAC1B;AAAA,IACJ;AACA,QAAI,KAAK,KAAK;AACV,WAAK,MAAM,EAAE,GAAG,KAAK,IAAI;AACzB,UAAI,KAAK,IAAI,eAAe;AACxB,aAAK,IAAI,gBAAgB;AAAA,MAC7B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,QAAQ,KAAK;AAAA,EAC7B;AACJ;;;ACvJA,IAAM,eAAe,IAAI,WAAW,CAAC;AACrC,IAAM,eAAe,IAAI,WAAW,CAAC;AACrC,IAAM,YAAY,KAAK,WAAW,CAAC;AACnC,IAAM,QAAQ,IAAI,WAAW,CAAC;AAC9B,IAAM,UAAU,KAAK,WAAW,CAAC;AACjC,IAAM,QAAQ,IAAI,WAAW,CAAC;AAC9B,IAAM,OAAO,KAAK,WAAW,CAAC;AAC9B,IAAM,MAAM,IAAK,WAAW,CAAC;AAC7B,IAAM,KAAK,KAAK,WAAW,CAAC;AAC5B,IAAM,cAAc,IAAI,WAAW,CAAC;AACpC,IAAM,eAAe,IAAI,WAAW,CAAC;AACrC,IAAM,mBAAmB,IAAI,WAAW,CAAC;AACzC,IAAM,oBAAoB,IAAI,WAAW,CAAC;AAC1C,IAAM,aAAa,IAAI,WAAW,CAAC;AACnC,IAAM,cAAc,IAAI,WAAW,CAAC;AACpC,IAAM,YAAY,IAAI,WAAW,CAAC;AAClC,IAAM,WAAW,IAAI,WAAW,CAAC;AACjC,IAAM,QAAQ,IAAI,WAAW,CAAC;AAC9B,IAAM,KAAK,IAAI,WAAW,CAAC;AAC3B,IAAM,YAAY;AAClB,IAAM,cAAc;AACpB,IAAM,iBAAiB;AACvB,IAAM,gBAAgB;AACf,SAAS,UAAU,OAAO,UAAU,CAAC,GAAG;AAC3C,QAAM,MAAM,MAAM,IAAI,QAAQ;AAC9B,QAAM,SAAS,QAAQ;AACvB,MAAI,MAAM,SAAS,QAAQ,MAAM;AACjC,MAAI,cAAc,SAAS,WAAW,GAAG;AACzC,QAAM,SAAS,IAAI;AACnB,MAAI,MAAM;AACV,QAAM,SAAS,CAAC;AAChB,QAAM,WAAW,CAAC;AAClB,WAAS,WAAW;AAChB,WAAO;AAAA,EACX;AAFS;AAGT,WAAS,SAAS,MAAM;AACpB,UAAM,MAAM,MAAM,cAAc,MAAM,GAAG;AAAA,EAC7C;AAFS;AAGT,WAAS,YAAY;AACjB,WAAO,SAAS,WAAW,KAAK,OAAO;AAAA,EAC3C;AAFS;AAGT,WAAS,UAAU,MAAM;AACrB,QAAI,SAAS;AACT,aAAO,SAAS,IAAI;AACxB,QAAI,OAAO;AACP;AACJ,UAAM,iBAAiB,OAAO,KAAK,iBAAiB;AACpD,WAAO,IAAI,WAAW,GAAG;AACzB,YAAQ,MAAM;AAAA,MACV,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,MAAM;AACP,eAAO;AACP,WAAG;AACC,kBAAQ;AACR,iBAAO,IAAI,WAAW,IAAI;AAAA,QAC9B,SAAS,SAAS,SACd,SAAS,WACT,SAAS,OACT,SAAS,MACT,SAAS;AACb,uBAAe,CAAC,SAAS,IAAI,MAAM,KAAK,IAAI,CAAC;AAC7C,cAAM,OAAO;AACb;AAAA,MACJ;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,mBAAmB;AACpB,cAAM,cAAc,OAAO,aAAa,IAAI;AAC5C,uBAAe,CAAC,aAAa,aAAa,GAAG;AAC7C;AAAA,MACJ;AAAA,MACA,KAAK,kBAAkB;AACnB,eAAO,OAAO,SAAS,OAAO,IAAI,EAAE,CAAC,IAAI;AACzC,YAAI,IAAI,WAAW,MAAM,CAAC;AAC1B,YAAI,SAAS,SACT,MAAM,gBACN,MAAM,gBACN,MAAM,SACN,MAAM,WACN,MAAM,OACN,MAAM,QACN,MAAM,IAAI;AACV,iBAAO;AACP,aAAG;AACC,sBAAU;AACV,mBAAO,IAAI,QAAQ,KAAK,OAAO,CAAC;AAChC,gBAAI,SAAS,IAAI;AACb,kBAAI,UAAU,gBAAgB;AAC1B,uBAAO;AACP;AAAA,cACJ,OACK;AACD,yBAAS,SAAS;AAAA,cACtB;AAAA,YACJ;AACA,wBAAY;AACZ,mBAAO,IAAI,WAAW,YAAY,CAAC,MAAM,WAAW;AAChD,2BAAa;AACb,wBAAU,CAAC;AAAA,YACf;AAAA,UACJ,SAAS;AACT,yBAAe,CAAC,YAAY,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,KAAK,IAAI;AAC/D,gBAAM;AAAA,QACV,OACK;AACD,iBAAO,IAAI,QAAQ,KAAK,MAAM,CAAC;AAC/B,oBAAU,IAAI,MAAM,KAAK,OAAO,CAAC;AACjC,cAAI,SAAS,MAAM,eAAe,KAAK,OAAO,GAAG;AAC7C,2BAAe,CAAC,KAAK,KAAK,GAAG;AAAA,UACjC,OACK;AACD,2BAAe,CAAC,YAAY,SAAS,KAAK,IAAI;AAC9C,kBAAM;AAAA,UACV;AAAA,QACJ;AACA;AAAA,MACJ;AAAA,MACA,KAAK;AAAA,MACL,KAAK,cAAc;AACf,gBAAQ,SAAS,eAAe,MAAM;AACtC,eAAO;AACP,WAAG;AACC,oBAAU;AACV,iBAAO,IAAI,QAAQ,OAAO,OAAO,CAAC;AAClC,cAAI,SAAS,IAAI;AACb,gBAAI,UAAU,gBAAgB;AAC1B,qBAAO,MAAM;AACb;AAAA,YACJ,OACK;AACD,uBAAS,QAAQ;AAAA,YACrB;AAAA,UACJ;AACA,sBAAY;AACZ,iBAAO,IAAI,WAAW,YAAY,CAAC,MAAM,WAAW;AAChD,yBAAa;AACb,sBAAU,CAAC;AAAA,UACf;AAAA,QACJ,SAAS;AACT,uBAAe,CAAC,UAAU,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,KAAK,IAAI;AAC7D,cAAM;AACN;AAAA,MACJ;AAAA,MACA,KAAK,IAAI;AACL,kBAAU,YAAY,MAAM;AAC5B,kBAAU,KAAK,GAAG;AAClB,YAAI,UAAU,cAAc,GAAG;AAC3B,iBAAO,IAAI,SAAS;AAAA,QACxB,OACK;AACD,iBAAO,UAAU,YAAY;AAAA,QACjC;AACA,uBAAe,CAAC,WAAW,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,KAAK,IAAI;AAC9D,cAAM;AACN;AAAA,MACJ;AAAA,MACA,KAAK,WAAW;AACZ,eAAO;AACP,iBAAS;AACT,eAAO,IAAI,WAAW,OAAO,CAAC,MAAM,WAAW;AAC3C,kBAAQ;AACR,mBAAS,CAAC;AAAA,QACd;AACA,eAAO,IAAI,WAAW,OAAO,CAAC;AAC9B,YAAI,UACA,SAAS,SACT,SAAS,SACT,SAAS,WACT,SAAS,OACT,SAAS,MACT,SAAS,MAAM;AACf,kBAAQ;AACR,cAAI,cAAc,KAAK,IAAI,OAAO,IAAI,CAAC,GAAG;AACtC,mBAAO,cAAc,KAAK,IAAI,OAAO,OAAO,CAAC,CAAC,GAAG;AAC7C,sBAAQ;AAAA,YACZ;AACA,gBAAI,IAAI,WAAW,OAAO,CAAC,MAAM,OAAO;AACpC,sBAAQ;AAAA,YACZ;AAAA,UACJ;AAAA,QACJ;AACA,uBAAe,CAAC,QAAQ,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,KAAK,IAAI;AAC3D,cAAM;AACN;AAAA,MACJ;AAAA,MACA,SAAS;AACL,YAAI,SAAS,SAAS,IAAI,WAAW,MAAM,CAAC,MAAM,UAAU;AACxD,iBAAO,IAAI,QAAQ,MAAM,MAAM,CAAC,IAAI;AACpC,cAAI,SAAS,GAAG;AACZ,gBAAI,UAAU,gBAAgB;AAC1B,qBAAO,IAAI;AAAA,YACf,OACK;AACD,uBAAS,SAAS;AAAA,YACtB;AAAA,UACJ;AACA,yBAAe,CAAC,WAAW,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,KAAK,IAAI;AAC9D,gBAAM;AAAA,QACV,OACK;AACD,sBAAY,YAAY,MAAM;AAC9B,sBAAY,KAAK,GAAG;AACpB,cAAI,YAAY,cAAc,GAAG;AAC7B,mBAAO,IAAI,SAAS;AAAA,UACxB,OACK;AACD,mBAAO,YAAY,YAAY;AAAA,UACnC;AACA,yBAAe,CAAC,QAAQ,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,KAAK,IAAI;AAC3D,iBAAO,KAAK,YAAY;AACxB,gBAAM;AAAA,QACV;AACA;AAAA,MACJ;AAAA,IACJ;AACA;AACA,WAAO;AAAA,EACX;AAvLS;AAwLT,WAAS,KAAK,OAAO;AACjB,aAAS,KAAK,KAAK;AAAA,EACvB;AAFS;AAGT,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAnNgB;;;ACjBhB,IAAM,wBAAwB;AAAA,EAC1B,OAAO;AAAA,EACP,OAAO;AACX;AACA,SAAS,qBAAqB,QAAQ;AAClC,WAAS,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AACzC,UAAM,QAAQ,OAAO,CAAC;AACtB,UAAM,MAAM,MAAM,CAAC,KAAK,MAAM,CAAC;AAC/B,QAAI;AACA,aAAO;AAAA,EACf;AACJ;AAPS;AAQF,IAAM,SAAN,MAAa;AAAA,EAlBpB,OAkBoB;AAAA;AAAA;AAAA,EAChB,YAAY,OAAO;AACf,SAAK,QAAQ;AACb,SAAK,OAAO,IAAIC,MAAK;AACrB,SAAK,UAAU,KAAK;AACpB,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,gBAAgB;AACrB,SAAK,KAAK,SAAS,EAAE,OAAO,OAAO,EAAE,QAAQ,GAAG,MAAM,GAAG,QAAQ,EAAE,EAAE;AAAA,EACzE;AAAA,EACA,OAAO,OAAO;AACV,UAAM,OAAO,IAAIC,QAAO;AACxB,SAAK,OAAO,MAAM,CAAC,EAAE,MAAM,CAAC;AAC5B,QAAI,KAAK,SAAS,IAAI;AAClB,WAAK,cAAc,MAAM,KAAK;AAAA,IAClC;AACA,SAAK,KAAK,MAAM,MAAM,CAAC,CAAC;AACxB,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,OAAO;AACX,QAAI,OAAO;AACX,UAAM,SAAS,CAAC;AAChB,UAAM,WAAW,CAAC;AAClB,WAAO,CAAC,KAAK,UAAU,UAAU,GAAG;AAChC,cAAQ,KAAK,UAAU,UAAU;AACjC,aAAO,MAAM,CAAC;AACd,UAAI,SAAS,OAAO,SAAS,KAAK;AAC9B,iBAAS,KAAK,SAAS,MAAM,MAAM,GAAG;AAAA,MAC1C,WACS,SAAS,OAAO,SAAS,SAAS,GAAG;AAC1C,iBAAS,KAAK,GAAG;AAAA,MACrB,WACS,SAAS,SAAS,SAAS,SAAS,CAAC,GAAG;AAC7C,iBAAS,IAAI;AAAA,MACjB;AACA,UAAI,SAAS,WAAW,GAAG;AACvB,YAAI,SAAS,KAAK;AACd,eAAK,OAAO,MAAM,KAAK,YAAY,MAAM,CAAC,CAAC;AAC3C,eAAK,OAAO,IAAI;AAChB,eAAK,YAAY;AACjB;AAAA,QACJ,WACS,SAAS,KAAK;AACnB,iBAAO;AACP;AAAA,QACJ,WACS,SAAS,KAAK;AACnB,cAAI,OAAO,SAAS,GAAG;AACnB,oBAAQ,OAAO,SAAS;AACxB,mBAAO,OAAO,KAAK;AACnB,mBAAO,QAAQ,KAAK,CAAC,MAAM,SAAS;AAChC,qBAAO,OAAO,EAAE,KAAK;AAAA,YACzB;AACA,gBAAI,MAAM;AACN,mBAAK,OAAO,MAAM,KAAK,YAAY,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC;AACrD,mBAAK,OAAO,IAAI;AAAA,YACpB;AAAA,UACJ;AACA,eAAK,IAAI,KAAK;AACd;AAAA,QACJ,OACK;AACD,iBAAO,KAAK,KAAK;AAAA,QACrB;AAAA,MACJ,OACK;AACD,eAAO,KAAK,KAAK;AAAA,MACrB;AACA,UAAI,KAAK,UAAU,UAAU,GAAG;AAC5B,eAAO;AACP;AAAA,MACJ;AAAA,IACJ;AACA,SAAK,KAAK,UAAU,KAAK,yBAAyB,MAAM;AACxD,QAAI,OAAO,QAAQ;AACf,WAAK,KAAK,YAAY,KAAK,2BAA2B,MAAM;AAC5D,WAAK,IAAI,MAAM,UAAU,MAAM;AAC/B,UAAI,MAAM;AACN,gBAAQ,OAAO,OAAO,SAAS,CAAC;AAChC,aAAK,OAAO,MAAM,KAAK,YAAY,MAAM,CAAC,KAAK,MAAM,CAAC,CAAC;AACvD,aAAK,OAAO,IAAI;AAChB,aAAK,SAAS,KAAK,KAAK;AACxB,aAAK,KAAK,UAAU;AAAA,MACxB;AAAA,IACJ,OACK;AACD,WAAK,KAAK,YAAY;AACtB,WAAK,SAAS;AAAA,IAClB;AACA,QAAI,MAAM;AACN,WAAK,QAAQ,CAAC;AACd,WAAK,UAAU;AAAA,IACnB;AAAA,EACJ;AAAA,EACA,qBAAqB,QAAQ;AACzB,UAAMC,SAAQ,KAAK,MAAM,MAAM;AAC/B,QAAIA,WAAU;AACV;AACJ,QAAI,UAAU;AACd,QAAI;AACJ,aAAS,IAAIA,SAAQ,GAAG,KAAK,GAAG,KAAK;AACjC,cAAQ,OAAO,CAAC;AAChB,UAAI,MAAM,CAAC,MAAM,SAAS;AACtB,mBAAW;AACX,YAAI,YAAY;AACZ;AAAA,MACR;AAAA,IACJ;AAIA,UAAM,KAAK,MAAM,MAAM,oBAAoB,MAAM,CAAC,MAAM,SAAS,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC;AAAA,EAC5F;AAAA,EACA,MAAM,QAAQ;AACV,QAAI,WAAW;AACf,QAAI,MAAM,OAAO;AACjB,eAAW,CAAC,GAAG,OAAO,KAAK,OAAO,QAAQ,GAAG;AACzC,cAAQ;AACR,aAAO,MAAM,CAAC;AACd,UAAI,SAAS,KAAK;AACd,oBAAY;AAAA,MAChB;AACA,UAAI,SAAS,KAAK;AACd,oBAAY;AAAA,MAChB;AACA,UAAI,aAAa,KAAK,SAAS,KAAK;AAChC,YAAI,CAAC,MAAM;AACP,eAAK,YAAY,KAAK;AAAA,QAC1B,WACS,KAAK,CAAC,MAAM,UAAU,KAAK,CAAC,MAAM,UAAU;AACjD;AAAA,QACJ,OACK;AACD,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,OAAO;AACX,UAAM,OAAO,IAAI,QAAQ;AACzB,SAAK,KAAK,MAAM,MAAM,CAAC,CAAC;AACxB,SAAK,OAAO,MAAM,KAAK,YAAY,MAAM,CAAC,KAAK,MAAM,CAAC,CAAC;AACvD,SAAK,OAAO,IAAI;AAChB,UAAM,OAAO,MAAM,CAAC,EAAE,MAAM,GAAG,EAAE;AACjC,QAAI,QAAQ,KAAK,IAAI,GAAG;AACpB,WAAK,OAAO;AACZ,WAAK,KAAK,OAAO;AACjB,WAAK,KAAK,QAAQ;AAAA,IACtB,OACK;AACD,YAAM,QAAQ,KAAK,MAAM,sBAAsB;AAC/C,WAAK,OAAO,MAAM,CAAC;AACnB,WAAK,KAAK,OAAO,MAAM,CAAC;AACxB,WAAK,KAAK,QAAQ,MAAM,CAAC;AAAA,IAC7B;AAAA,EACJ;AAAA,EACA,kBAAkB;AACd,SAAK,YAAY,UAAU,KAAK,KAAK;AAAA,EACzC;AAAA,EACA,KAAK,QAAQ,gBAAgB;AACzB,UAAM,OAAO,IAAI,YAAY;AAC7B,SAAK,KAAK,MAAM,OAAO,CAAC,EAAE,CAAC,CAAC;AAC5B,UAAM,OAAO,OAAO,OAAO,SAAS,CAAC;AACrC,QAAI,KAAK,CAAC,MAAM,KAAK;AACjB,WAAK,YAAY;AACjB,aAAO,IAAI;AAAA,IACf;AACA,SAAK,OAAO,MAAM,KAAK,YAAY,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,qBAAqB,MAAM,CAAC;AACrF,SAAK,OAAO,IAAI;AAChB,WAAO,OAAO,CAAC,EAAE,CAAC,MAAM,QAAQ;AAC5B,UAAI,OAAO,WAAW;AAClB,aAAK,YAAY,MAAM;AAC3B,WAAK,KAAK,UAAU,OAAO,MAAM,EAAE,CAAC;AAAA,IACxC;AACA,SAAK,OAAO,QAAQ,KAAK,YAAY,OAAO,CAAC,EAAE,CAAC,CAAC;AACjD,SAAK,OAAO;AACZ,WAAO,OAAO,QAAQ;AAClB,YAAM,OAAO,OAAO,CAAC,EAAE,CAAC;AACxB,UAAI,SAAS,OAAO,SAAS,WAAW,SAAS,WAAW;AACxD;AAAA,MACJ;AACA,WAAK,QAAQ,OAAO,MAAM,EAAE,CAAC;AAAA,IACjC;AACA,SAAK,KAAK,UAAU;AACpB,QAAI;AACJ,WAAO,OAAO,QAAQ;AAClB,cAAQ,OAAO,MAAM;AACrB,UAAI,MAAM,CAAC,MAAM,KAAK;AAClB,aAAK,KAAK,WAAW,MAAM,CAAC;AAC5B;AAAA,MACJ,OACK;AACD,YAAI,MAAM,CAAC,MAAM,UAAU,KAAK,KAAK,MAAM,CAAC,CAAC,GAAG;AAC5C,eAAK,YAAY,CAAC,KAAK,CAAC;AAAA,QAC5B;AACA,aAAK,KAAK,WAAW,MAAM,CAAC;AAAA,MAChC;AAAA,IACJ;AACA,QAAI,KAAK,KAAK,CAAC,MAAM,OAAO,KAAK,KAAK,CAAC,MAAM,KAAK;AAC9C,WAAK,KAAK,UAAU,KAAK,KAAK,CAAC;AAC/B,WAAK,OAAO,KAAK,KAAK,MAAM,CAAC;AAAA,IACjC;AACA,QAAI,cAAc,CAAC;AACnB,QAAI;AACJ,WAAO,OAAO,QAAQ;AAClB,aAAO,OAAO,CAAC,EAAE,CAAC;AAClB,UAAI,SAAS,WAAW,SAAS;AAC7B;AACJ,kBAAY,KAAK,OAAO,MAAM,CAAC;AAAA,IACnC;AACA,SAAK,wBAAwB,MAAM;AACnC,aAAS,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AACzC,cAAQ,OAAO,CAAC;AAChB,UAAI,MAAM,CAAC,EAAE,YAAY,MAAM,cAAc;AACzC,aAAK,YAAY;AACjB,YAAIC,UAAS,KAAK,WAAW,QAAQ,CAAC;AACtC,QAAAA,UAAS,KAAK,cAAc,MAAM,IAAIA;AACtC,YAAIA,YAAW;AACX,eAAK,KAAK,YAAYA;AAC1B;AAAA,MACJ,WACS,MAAM,CAAC,EAAE,YAAY,MAAM,aAAa;AAC7C,cAAM,QAAQ,OAAO,MAAM,CAAC;AAC5B,YAAIC,OAAM;AACV,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,gBAAM,OAAO,MAAM,CAAC,EAAE,CAAC;AACvB,cAAIA,KAAI,KAAK,EAAE,WAAW,GAAG,KAAK,SAAS,SAAS;AAChD;AAAA,UACJ;AACA,UAAAA,OAAM,MAAM,IAAI,EAAE,CAAC,IAAIA;AAAA,QAC3B;AACA,YAAIA,KAAI,KAAK,EAAE,WAAW,GAAG,GAAG;AAC5B,eAAK,YAAY;AACjB,eAAK,KAAK,YAAYA;AACtB,mBAAS;AAAA,QACb;AAAA,MACJ;AACA,UAAI,MAAM,CAAC,MAAM,WAAW,MAAM,CAAC,MAAM,WAAW;AAChD;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,UAAU,OAAO,KAAK,OAAK,EAAE,CAAC,MAAM,WAAW,EAAE,CAAC,MAAM,SAAS;AACvE,QAAI,SAAS;AACT,WAAK,KAAK,WAAW,YAAY,IAAI,OAAK,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE;AACvD,oBAAc,CAAC;AAAA,IACnB;AACA,SAAK,IAAI,MAAM,SAAS,YAAY,OAAO,MAAM,GAAG,cAAc;AAClE,QAAI,KAAK,MAAM,SAAS,GAAG,KAAK,CAAC,gBAAgB;AAC7C,WAAK,qBAAqB,MAAM;AAAA,IACpC;AAAA,EACJ;AAAA,EACA,YAAY,OAAO;AACf,UAAM,KAAK,MAAM,MAAM,gBAAgB,EAAE,QAAQ,MAAM,CAAC,EAAE,GAAG,EAAE,QAAQ,MAAM,CAAC,IAAI,MAAM,CAAC,EAAE,OAAO,CAAC;AAAA,EACvG;AAAA,EACA,UAAU,OAAO;AACb,UAAM,OAAO,IAAIC,MAAK;AACtB,SAAK,KAAK,MAAM,MAAM,CAAC,CAAC;AACxB,SAAK,WAAW;AAChB,SAAK,KAAK,UAAU;AACpB,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,IAAI,OAAO;AACP,QAAI,KAAK,QAAQ,SAAS,KAAK,QAAQ,MAAM,QAAQ;AACjD,WAAK,QAAQ,KAAK,YAAY,KAAK;AAAA,IACvC;AACA,SAAK,YAAY;AACjB,SAAK,QAAQ,KAAK,SAAS,KAAK,QAAQ,KAAK,SAAS,MAAM,KAAK;AACjE,SAAK,SAAS;AACd,QAAI,KAAK,QAAQ,QAAQ;AACrB,WAAK,QAAQ,OAAO,MAAM,KAAK,YAAY,MAAM,CAAC,CAAC;AACnD,WAAK,QAAQ,OAAO,IAAI;AACxB,WAAK,UAAU,KAAK,QAAQ;AAAA,IAChC,OACK;AACD,WAAK,gBAAgB,KAAK;AAAA,IAC9B;AAAA,EACJ;AAAA,EACA,UAAU;AACN,QAAI,KAAK,QAAQ;AACb,WAAK,cAAc;AACvB,QAAI,KAAK,QAAQ,SAAS,KAAK,QAAQ,MAAM,QAAQ;AACjD,WAAK,QAAQ,KAAK,YAAY,KAAK;AAAA,IACvC;AACA,SAAK,QAAQ,KAAK,SAAS,KAAK,QAAQ,KAAK,SAAS,MAAM,KAAK;AACjE,SAAK,KAAK,OAAO,MAAM,KAAK,YAAY,KAAK,UAAU,SAAS,CAAC;AAAA,EACrE;AAAA,EACA,cAAc,OAAO;AACjB,SAAK,UAAU,MAAM,CAAC;AACtB,QAAI,KAAK,QAAQ,OAAO;AACpB,YAAM,OAAO,KAAK,QAAQ,MAAM,KAAK,QAAQ,MAAM,SAAS,CAAC;AAC7D,UAAI,QAAQ,KAAK,SAAS,UAAU,CAAC,KAAK,KAAK,cAAc;AACzD,aAAK,KAAK,eAAe,KAAK;AAC9B,aAAK,SAAS;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,YAAY,QAAQ;AAChB,UAAM,MAAM,KAAK,MAAM,WAAW,MAAM;AACxC,WAAO;AAAA,MACH,QAAQ,IAAI;AAAA,MACZ,MAAM,IAAI;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,KAAK,MAAM,QAAQ;AACf,SAAK,QAAQ,KAAK,IAAI;AACtB,SAAK,SAAS;AAAA,MACV,OAAO,KAAK;AAAA,MACZ,OAAO,KAAK,YAAY,MAAM;AAAA,IAClC;AACA,SAAK,KAAK,SAAS,KAAK;AACxB,SAAK,SAAS;AACd,QAAI,KAAK,SAAS;AACd,WAAK,YAAY;AAAA,EACzB;AAAA,EACA,MAAM,OAAO;AACT,QAAI,MAAM;AACV,QAAI,OAAO;AACX,QAAIH,SAAQ;AACZ,QAAI,UAAU;AACd,UAAM,WAAW,CAAC;AAClB,UAAM,iBAAiB,MAAM,CAAC,EAAE,WAAW,IAAI;AAC/C,UAAM,SAAS,CAAC;AAChB,QAAI,QAAQ;AACZ,WAAO,OAAO;AACV,aAAO,MAAM,CAAC;AACd,aAAO,KAAK,KAAK;AACjB,UAAI,SAAS,OAAO,SAAS,KAAK;AAC9B,YAAI,CAAC;AACD,oBAAU;AACd,iBAAS,KAAK,SAAS,MAAM,MAAM,GAAG;AAAA,MAC1C,WACS,kBAAkBA,UAAS,SAAS,KAAK;AAC9C,YAAI,CAAC;AACD,oBAAU;AACd,iBAAS,KAAK,GAAG;AAAA,MACrB,WACS,SAAS,WAAW,GAAG;AAC5B,YAAI,SAAS,KAAK;AACd,cAAIA,QAAO;AACP,iBAAK,KAAK,QAAQ,cAAc;AAChC;AAAA,UACJ,OACK;AACD;AAAA,UACJ;AAAA,QACJ,WACS,SAAS,KAAK;AACnB,eAAK,KAAK,MAAM;AAChB;AAAA,QACJ,WACS,SAAS,KAAK;AACnB,eAAK,UAAU,KAAK,OAAO,IAAI,CAAC;AAChC,gBAAM;AACN;AAAA,QACJ,WACS,SAAS,KAAK;AACnB,UAAAA,SAAQ;AAAA,QACZ;AAAA,MACJ,WACS,SAAS,SAAS,SAAS,SAAS,CAAC,GAAG;AAC7C,iBAAS,IAAI;AACb,YAAI,SAAS,WAAW;AACpB,oBAAU;AAAA,MAClB;AACA,cAAQ,KAAK,UAAU,UAAU;AAAA,IACrC;AACA,QAAI,KAAK,UAAU,UAAU;AACzB,YAAM;AACV,QAAI,SAAS,SAAS;AAClB,WAAK,gBAAgB,OAAO;AAChC,QAAI,OAAOA,QAAO;AACd,UAAI,CAAC,gBAAgB;AACjB,eAAO,OAAO,QAAQ;AAClB,kBAAQ,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC;AACnC,cAAI,UAAU,WAAW,UAAU;AAC/B;AACJ,eAAK,UAAU,KAAK,OAAO,IAAI,CAAC;AAAA,QACpC;AAAA,MACJ;AACA,WAAK,KAAK,QAAQ,cAAc;AAAA,IACpC,OACK;AACD,WAAK,YAAY,MAAM;AAAA,IAC3B;AAAA,EACJ;AAAA,EACA,QAAQ;AACJ,QAAI;AACJ,WAAO,CAAC,KAAK,UAAU,UAAU,GAAG;AAChC,cAAQ,KAAK,UAAU,UAAU;AACjC,cAAQ,MAAM,CAAC,GAAG;AAAA,QACd,KAAK;AACD,eAAK,UAAU,MAAM,CAAC;AACtB;AAAA,QACJ,KAAK;AACD,eAAK,cAAc,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,eAAK,IAAI,KAAK;AACd;AAAA,QACJ,KAAK;AACD,eAAK,QAAQ,KAAK;AAClB;AAAA,QACJ,KAAK;AACD,eAAK,OAAO,KAAK;AACjB;AAAA,QACJ,KAAK;AACD,eAAK,UAAU,KAAK;AACpB;AAAA,QACJ;AACI,eAAK,MAAM,KAAK;AAChB;AAAA,MACR;AAAA,IACJ;AACA,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,0BAAuC;AAAA,EAEvC;AAAA,EACA,IAAI,MAAM,MAAM,QAAQ,gBAAgB;AACpC,QAAI,OAAO;AACX,UAAM,SAAS,OAAO;AACtB,QAAI,QAAQ;AACZ,QAAI,QAAQ;AACZ,QAAI,MAAM;AACV,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,cAAQ,OAAO,CAAC;AAChB,aAAO,MAAM,CAAC;AACd,UAAI,SAAS,WAAW,MAAM,SAAS,KAAK,CAAC,gBAAgB;AACzD,gBAAQ;AAAA,MACZ,WACS,SAAS,WAAW;AACzB,eAAO,OAAO,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI;AAC1C,eAAO,OAAO,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI;AAC1C,YAAI,CAAC,sBAAsB,IAAI,KAAK,CAAC,sBAAsB,IAAI,GAAG;AAC9D,cAAI,MAAM,MAAM,EAAE,MAAM,KAAK;AACzB,oBAAQ;AAAA,UACZ,OACK;AACD,qBAAS,MAAM,CAAC;AAAA,UACpB;AAAA,QACJ,OACK;AACD,kBAAQ;AAAA,QACZ;AAAA,MACJ,OACK;AACD,iBAAS,MAAM,CAAC;AAAA,MACpB;AAAA,IACJ;AACA,QAAI,CAAC,OAAO;AACR,YAAM,MAAM,OAAO,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,CAAC,GAAG,EAAE;AACpD,WAAK,KAAK,IAAI,IAAI,EAAE,KAAK,MAAM;AAAA,IACnC;AACA,SAAK,IAAI,IAAI;AAAA,EACjB;AAAA,EACA,KAAK,QAAQ;AACT,WAAO,IAAI;AACX,UAAM,OAAO,IAAIG,MAAK;AACtB,SAAK,KAAK,MAAM,OAAO,CAAC,EAAE,CAAC,CAAC;AAC5B,SAAK,KAAK,UAAU,KAAK,yBAAyB,MAAM;AACxD,SAAK,IAAI,MAAM,YAAY,MAAM;AACjC,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,yBAAyB,QAAQ;AAC7B,QAAI;AACJ,QAAI,SAAS;AACb,WAAO,OAAO,QAAQ;AAClB,sBAAgB,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC;AAC3C,UAAI,kBAAkB,WAAW,kBAAkB;AAC/C;AACJ,eAAS,OAAO,IAAI,EAAE,CAAC,IAAI;AAAA,IAC/B;AACA,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,2BAA2B,QAAQ;AAC/B,QAAI;AACJ,QAAI,SAAS;AACb,WAAO,OAAO,QAAQ;AAClB,aAAO,OAAO,CAAC,EAAE,CAAC;AAClB,UAAI,SAAS,WAAW,SAAS;AAC7B;AACJ,gBAAU,OAAO,MAAM,EAAE,CAAC;AAAA,IAC9B;AACA,WAAO;AAAA,EACX;AAAA,EACA,cAAc,QAAQ;AAClB,QAAI;AACJ,QAAI,SAAS;AACb,WAAO,OAAO,QAAQ;AAClB,sBAAgB,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC;AAC3C,UAAI,kBAAkB;AAClB;AACJ,eAAS,OAAO,IAAI,EAAE,CAAC,IAAI;AAAA,IAC/B;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,QAAQ,MAAM;AACrB,QAAI,SAAS;AACb,aAAS,IAAI,MAAM,IAAI,OAAO,QAAQ,KAAK;AACvC,gBAAU,OAAO,CAAC,EAAE,CAAC;AAAA,IACzB;AACA,WAAO,OAAO,MAAM,OAAO,SAAS,IAAI;AACxC,WAAO;AAAA,EACX;AAAA,EACA,gBAAgB;AACZ,UAAM,MAAM,KAAK,QAAQ,OAAO;AAChC,UAAM,KAAK,MAAM,MAAM,kBAAkB,IAAI,MAAM,IAAI,MAAM;AAAA,EACjE;AAAA,EACA,gBAAgB,SAAS;AACrB,UAAM,KAAK,MAAM,MAAM,oBAAoB,EAAE,QAAQ,QAAQ,CAAC,EAAE,GAAG,EAAE,QAAQ,QAAQ,CAAC,IAAI,EAAE,CAAC;AAAA,EACjG;AAAA,EACA,gBAAgB,OAAO;AACnB,UAAM,KAAK,MAAM,MAAM,gBAAgB,EAAE,QAAQ,MAAM,CAAC,EAAE,GAAG,EAAE,QAAQ,MAAM,CAAC,IAAI,EAAE,CAAC;AAAA,EACzF;AAAA,EACA,YAAY,QAAQ;AAChB,UAAM,KAAK,MAAM,MAAM,gBAAgB,EAAE,QAAQ,OAAO,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,QAAQ,OAAO,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC;AAAA,EACnH;AAAA,EACA,cAAc,MAAM,OAAO;AACvB,UAAM,KAAK,MAAM,MAAM,wBAAwB,EAAE,QAAQ,MAAM,CAAC,EAAE,GAAG,EAAE,QAAQ,MAAM,CAAC,IAAI,MAAM,CAAC,EAAE,OAAO,CAAC;AAAA,EAC/G;AACJ;;;AC7hBO,SAASC,OAAM,KAAK,MAAM;AAC7B,QAAM,QAAQ,IAAI,MAAM,KAAK,IAAI;AACjC,QAAMC,UAAS,IAAI,OAAO,KAAK;AAC/B,MAAI;AACA,IAAAA,QAAO,MAAM;AAAA,EACjB,SACO,GAAG;AACN,QAAI,QAAQ,IAAI,aAAa,cAAc;AACvC,UAAI,EAAE,SAAS,oBAAoB,QAAQ,KAAK,MAAM;AAClD,YAAI,WAAW,KAAK,KAAK,IAAI,GAAG;AAC5B,YAAE,WACE;AAAA,QAGR,WACS,UAAU,KAAK,KAAK,IAAI,GAAG;AAChC,YAAE,WACE;AAAA,QAGR,WACS,WAAW,KAAK,KAAK,IAAI,GAAG;AACjC,YAAE,WACE;AAAA,QAGR;AAAA,MACJ;AAAA,IACJ;AACA,UAAM;AAAA,EACV;AACA,SAAOA,QAAO;AAClB;AAhCgB,OAAAD,QAAA;AAiChB,UAAU,cAAcA,MAAK;;;ACnC7B,IAAIE;AAAJ,IAAgBC;AACT,IAAM,WAAN,cAAuB,UAAU;AAAA,EAFxC,OAEwC;AAAA;AAAA;AAAA,EACpC,YAAY,UAAU;AAElB,UAAM,EAAE,MAAM,YAAY,GAAG,SAAS,CAAC;AACvC,QAAI,CAAC,KAAK,OAAO;AACb,WAAK,QAAQ,CAAC;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,SAAS,OAAO,CAAC,GAAG;AAChB,UAAM,OAAO,IAAID,YAAW,IAAIC,WAAU,GAAG,MAAM,IAAI;AACvD,WAAO,KAAK,UAAU;AAAA,EAC1B;AACJ;AACA,SAAS,qBAAqB,eAAa;AACvC,EAAAD,cAAa;AACjB;AACA,SAAS,oBAAoB,eAAa;AACtC,EAAAC,aAAY;AAChB;;;ACdO,SAAS,SAAS,MAAM,QAAQ;AACnC,MAAI,MAAM,QAAQ,IAAI;AAClB,WAAO,KAAK,IAAI,OAAK,SAAS,CAAC,CAAC;AACpC,QAAM,EAAE,QAAQ,WAAW,GAAG,SAAS,IAAI;AAC3C,MAAI,WAAW;AACX,aAAS,CAAC;AACV,eAAW,SAAS,WAAW;AAC3B,YAAM,gBAAgB,EAAE,GAAG,OAAO,WAAW,MAAM,UAAU;AAC7D,UAAI,cAAc,KAAK;AACnB,sBAAc,MAAM;AAAA,UAChB,GAAG,cAAc;AAAA,QACrB;AAAA,MACJ;AACA,aAAO,KAAK,aAAa;AAAA,IAC7B;AAAA,EACJ;AACA,MAAI,SAAS,OAAO;AAChB,aAAS,QAAQ,KAAK,MAAM,IAAI,OAAK,SAAS,GAAG,MAAM,CAAC;AAAA,EAC5D;AACA,MAAI,SAAS,QAAQ;AACjB,UAAM,EAAE,SAAS,GAAG,OAAO,IAAI,SAAS;AACxC,aAAS,SAAS;AAClB,QAAI,WAAW,MAAM;AACjB,eAAS,OAAO,QAAQ,OAAO,OAAO;AAAA,IAC1C;AAAA,EACJ;AACA,MAAI,SAAS,SAAS,QAAQ;AAC1B,WAAO,IAAIC,MAAK,QAAQ;AAAA,EAC5B,WACS,SAAS,SAAS,QAAQ;AAC/B,WAAO,IAAI,YAAY,QAAQ;AAAA,EACnC,WACS,SAAS,SAAS,QAAQ;AAC/B,WAAO,IAAIC,MAAK,QAAQ;AAAA,EAC5B,WACS,SAAS,SAAS,WAAW;AAClC,WAAO,IAAI,QAAQ,QAAQ;AAAA,EAC/B,WACS,SAAS,SAAS,UAAU;AACjC,WAAO,IAAIC,QAAO,QAAQ;AAAA,EAC9B,OACK;AACD,UAAM,IAAI,MAAM,wBAAwB,KAAK,IAAI;AAAA,EACrD;AACJ;AA5CgB;;;ACLT,IAAM,eAAN,MAAmB;AAAA,EAD1B,OAC0B;AAAA;AAAA;AAAA,EACtB,YAAYC,YAAWC,OAAM,MAAM,WAAW;AAC1C,SAAK,YAAYD;AACjB,SAAK,UAAU,KAAK,OAAO,CAAC;AAC5B,SAAK,OAAOC;AACZ,SAAK,OAAO;AACZ,SAAK,MAAM;AACX,SAAK,cAAc;AACnB,SAAK,eAAe,CAAC,KAAK,QAAQ,QAAQ,KAAK,QAAQ;AACvD,SAAK,mBAAmB,oBAAI,IAAI;AAChC,SAAK,gBAAgB,oBAAI,IAAI;AAC7B,SAAK,eAAe,oBAAI,IAAI;AAAA,EAChC;AAAA,EACA,gBAAgB;AACZ,QAAI;AACJ,QAAI,KAAK,SAAS,GAAG;AACjB,gBACI,kCAAkC,KAAK,SAAS,KAAK,IAAI,SAAS,CAAC;AAAA,IAC3E,WACS,OAAO,KAAK,QAAQ,eAAe,UAAU;AAClD,gBAAU,KAAK,QAAQ;AAAA,IAC3B,WACS,OAAO,KAAK,QAAQ,eAAe,YAAY;AACpD,gBAAU,KAAK,QAAQ,WAAW,KAAK,KAAK,IAAI,KAAK,IAAI;AAAA,IAC7D,OACK;AACD,gBAAU,KAAK,WAAW,IAAI;AAAA,IAClC;AACA,QAAI,MAAM;AACV,QAAI,KAAK,IAAI,SAAS,MAAM;AACxB,YAAM;AACV,SAAK,OAAO,MAAM,0BAA0B,UAAU;AAAA,EAC1D;AAAA,EACA,gBAAgB;AAAA,EAChB;AAAA,EACA,kBAAkB;AACd,QAAI,KAAK,QAAQ,eAAe;AAC5B;AACJ,QAAI,KAAK,MAAM;AACX,UAAI;AACJ,eAAS,IAAI,KAAK,KAAK,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AAClD,eAAO,KAAK,KAAK,MAAM,CAAC;AACxB,YAAI,KAAK,SAAS;AACd;AACJ,YAAI,KAAK,KAAK,WAAW,qBAAqB,GAAG;AAC7C,eAAK,KAAK,YAAY,CAAC;AAAA,QAC3B;AAAA,MACJ;AAAA,IACJ,WACS,KAAK,KAAK;AACf,WAAK,MAAM,KAAK,IAAI,QAAQ,2BAA2B,EAAE;AAAA,IAC7D;AAAA,EACJ;AAAA,EACA,WAAW;AACP,SAAK,gBAAgB;AACrB,QAAI,SAAS;AACb,SAAK,UAAU,KAAK,MAAM,OAAK;AAC3B,gBAAU;AAAA,IACd,CAAC;AACD,WAAO,CAAC,MAAM;AAAA,EAClB;AAAA,EACA,cAAc;AACV,QAAI,KAAK,MAAM;AACX,WAAK,eAAe;AAAA,IACxB,WACS,KAAK,SAAS,EAAE,WAAW,GAAG;AACnC,YAAM,OAAO,KAAK,SAAS,EAAE,CAAC,EAAE,SAAS;AACzC,WAAK,OAAO,KAAK,WAAW;AAC5B,WAAK,MAAM,mBAAmB,cAAc,MAAM;AAAA,QAC9C,sBAAsB;AAAA,MAC1B,CAAC;AAAA,IACL,OACK;AACD,WAAK,MAAM,IAAI,mBAAmB;AAAA,QAC9B,MAAM,KAAK,WAAW;AAAA,QACtB,sBAAsB;AAAA,MAC1B,CAAC;AACD,WAAK,IAAI,WAAW;AAAA,QAChB,WAAW,EAAE,QAAQ,GAAG,MAAM,EAAE;AAAA,QAChC,UAAU,EAAE,QAAQ,GAAG,MAAM,EAAE;AAAA,QAC/B,QAAQ,KAAK,KAAK,OACZ,KAAK,MAAM,KAAK,KAAK,KAAK,KAAK,IAAI,CAAC,IACpC;AAAA,MACV,CAAC;AAAA,IACL;AACA,QAAI,KAAK,iBAAiB;AACtB,WAAK,kBAAkB;AAC3B,QAAI,KAAK,QAAQ,KAAK,SAAS,EAAE,SAAS;AACtC,WAAK,cAAc;AACvB,QAAI,KAAK,aAAa;AAClB,WAAK,cAAc;AACvB,QAAI,KAAK,SAAS,GAAG;AACjB,aAAO,CAAC,KAAK,GAAG;AAAA,IACpB,OACK;AACD,aAAO,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,IAC9B;AAAA,EACJ;AAAA,EACA,iBAAiB;AACb,SAAK,MAAM;AACX,SAAK,MAAM,IAAI,mBAAmB;AAAA,MAC9B,MAAM,KAAK,WAAW;AAAA,MACtB,sBAAsB;AAAA,IAC1B,CAAC;AACD,QAAI,OAAO;AACX,QAAI,SAAS;AACb,UAAM,WAAW;AACjB,UAAM,UAAU;AAAA,MACZ,WAAW,EAAE,QAAQ,GAAG,MAAM,EAAE;AAAA,MAChC,UAAU,EAAE,QAAQ,GAAG,MAAM,EAAE;AAAA,MAC/B,QAAQ;AAAA,IACZ;AACA,QAAI,MAAM;AACV,SAAK,UAAU,KAAK,MAAM,CAACC,MAAK,MAAM,SAAS;AAC3C,WAAK,OAAOA;AACZ,UAAI,QAAQ,SAAS,OAAO;AACxB,gBAAQ,UAAU,OAAO;AACzB,gBAAQ,UAAU,SAAS,SAAS;AACpC,YAAI,KAAK,UAAU,KAAK,OAAO,OAAO;AAClC,kBAAQ,SAAS,KAAK,WAAW,IAAI;AACrC,kBAAQ,SAAS,OAAO,KAAK,OAAO,MAAM;AAC1C,kBAAQ,SAAS,SAAS,KAAK,OAAO,MAAM,SAAS;AACrD,eAAK,IAAI,WAAW,OAAO;AAAA,QAC/B,OACK;AACD,kBAAQ,SAAS;AACjB,kBAAQ,SAAS,OAAO;AACxB,kBAAQ,SAAS,SAAS;AAC1B,eAAK,IAAI,WAAW,OAAO;AAAA,QAC/B;AAAA,MACJ;AACA,cAAQA,KAAI,MAAM,KAAK;AACvB,UAAI,OAAO;AACP,gBAAQ,MAAM;AACd,eAAOA,KAAI,YAAY,IAAI;AAC3B,iBAASA,KAAI,SAAS;AAAA,MAC1B,OACK;AACD,kBAAUA,KAAI;AAAA,MAClB;AACA,UAAI,QAAQ,SAAS,SAAS;AAC1B,cAAM,IAAI,KAAK,UAAU,EAAE,MAAM,CAAC,EAAE;AACpC,cAAM,YAAY,KAAK,SAAS,UAAW,KAAK,SAAS,YAAY,CAAC,KAAK;AAC3E,YAAI,CAAC,aAAa,SAAS,EAAE,QAAQ,EAAE,KAAK,WAAW;AACnD,cAAI,KAAK,UAAU,KAAK,OAAO,KAAK;AAChC,oBAAQ,SAAS,KAAK,WAAW,IAAI;AACrC,oBAAQ,SAAS,OAAO,KAAK,OAAO,IAAI;AACxC,oBAAQ,SAAS,SAAS,KAAK,OAAO,IAAI,SAAS;AACnD,oBAAQ,UAAU,OAAO;AACzB,oBAAQ,UAAU,SAAS,SAAS;AACpC,iBAAK,IAAI,WAAW,OAAO;AAAA,UAC/B,OACK;AACD,oBAAQ,SAAS;AACjB,oBAAQ,SAAS,OAAO;AACxB,oBAAQ,SAAS,SAAS;AAC1B,oBAAQ,UAAU,OAAO;AACzB,oBAAQ,UAAU,SAAS,SAAS;AACpC,iBAAK,IAAI,WAAW,OAAO;AAAA,UAC/B;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,eAAe;AACX,QAAI,KAAK,SAAS,GAAG;AACjB,aAAO;AAAA,IACX;AACA,QAAI,OAAO,KAAK,QAAQ,eAAe,aAAa;AAChD,aAAO,KAAK,QAAQ;AAAA,IACxB;AACA,QAAI,KAAK,SAAS,EAAE,QAAQ;AACxB,aAAO,KAAK,SAAS,EAAE,KAAK,OAAK,EAAE,UAAU;AAAA,IACjD;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW;AACP,QAAI,OAAO,KAAK,QAAQ,WAAW,aAAa;AAC5C,aAAO,KAAK,QAAQ;AAAA,IACxB;AACA,UAAM,aAAa,KAAK,QAAQ;AAChC,QAAI,OAAO,eAAe,eAAe,eAAe,MAAM;AAC1D,aAAO;AAAA,IACX;AACA,QAAI,KAAK,SAAS,EAAE,QAAQ;AACxB,aAAO,KAAK,SAAS,EAAE,KAAK,OAAK,EAAE,MAAM;AAAA,IAC7C;AACA,WAAO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,QAAI,OAAO,KAAK,KAAK,QAAQ,aAAa;AACtC,aAAO,CAAC,CAAC,KAAK,KAAK;AAAA,IACvB;AACA,WAAO,KAAK,SAAS,EAAE,SAAS;AAAA,EACpC;AAAA,EACA,mBAAmB;AACf,QAAI,OAAO,KAAK,QAAQ,mBAAmB,aAAa;AACpD,aAAO,KAAK,QAAQ;AAAA,IACxB;AACA,QAAI,KAAK,SAAS,EAAE,QAAQ;AACxB,aAAO,KAAK,SAAS,EAAE,KAAK,OAAK,EAAE,YAAY,CAAC;AAAA,IACpD;AACA,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AACT,QAAI,KAAK,KAAK,IAAI;AACd,aAAO,KAAK,KAAK,KAAK,KAAK,EAAE;AAAA,IACjC,WACS,KAAK,KAAK,MAAM;AACrB,aAAO,KAAK,KAAK,KAAK,KAAK,IAAI;AAAA,IACnC,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,KAAK,MAAM;AACP,WAAO;AAAA,EACX;AAAA,EACA,WAAW;AACP,QAAI,CAAC,KAAK,cAAc;AACpB,WAAK,eAAe,CAAC;AACrB,UAAI,KAAK,MAAM;AACX,aAAK,KAAK,KAAK,UAAQ;AACnB,cAAI,KAAK,UAAU,KAAK,OAAO,MAAM,KAAK;AACtC,kBAAM,MAAM,KAAK,OAAO,MAAM;AAC9B,gBAAI,CAAC,KAAK,aAAa,SAAS,GAAG,GAAG;AAClC,mBAAK,aAAa,KAAK,GAAG;AAAA,YAC9B;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL,OACK;AACD,cAAM,QAAQ,IAAI,MAAM,KAAK,aAAa,KAAK,IAAI;AACnD,YAAI,MAAM;AACN,eAAK,aAAa,KAAK,MAAM,GAAG;AAAA,MACxC;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,oBAAoB;AAChB,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACxD;AAAA,EACA,WAAW,MAAM;AACb,QAAI,KAAK,QAAQ,MAAM;AACnB,aAAO,KAAK,MAAM,KAAK,QAAQ,IAAI;AAAA,IACvC,WACS,KAAK,cAAc;AACxB,aAAO,KAAK,UAAU,KAAK,OAAO,MAAM,IAAI;AAAA,IAChD,OACK;AACD,aAAO,KAAK,MAAM,KAAK,KAAK,KAAK,OAAO,MAAM,IAAI,CAAC;AAAA,IACvD;AAAA,EACJ;AAAA,EACA,SAASA,MAAK;AACV,QAAI,QAAQ;AACR,aAAO,OAAO,KAAKA,IAAG,EAAE,SAAS,QAAQ;AAAA,IAC7C,OACK;AACD,aAAO,OAAO,KAAK,SAAS,mBAAmBA,IAAG,CAAC,CAAC;AAAA,IACxD;AAAA,EACJ;AAAA,EACA,UAAU,MAAM;AACZ,UAAM,SAAS,KAAK,iBAAiB,IAAI,IAAI;AAC7C,QAAI;AACA,aAAO;AACX,UAAM,IAAI,MAAM,8DAA8D;AAAA,EAClF;AAAA,EACA,MAAM,MAAM;AACR,UAAM,SAAS,KAAK,aAAa,IAAI,IAAI;AACzC,QAAI;AACA,aAAO;AACX,WAAO,KAAK,QAAQ,OAAO,GAAG;AAC9B,UAAM,MAAM,UAAU,IAAI,EAAE,QAAQ,SAAS,kBAAkB;AAC/D,SAAK,aAAa,IAAI,MAAM,GAAG;AAC/B,WAAO;AAAA,EACX;AACJ;;;ACrRA,IAAM,UAAU,CAAC;AACV,SAAS,SAAS,SAAS;AAC9B,MAAI,QAAQ,OAAO;AACf;AACJ,UAAQ,OAAO,IAAI;AACnB,MAAI,OAAO,YAAY,eAAe,QAAQ,MAAM;AAChD,YAAQ,KAAK,OAAO;AAAA,EACxB;AACJ;AAPgB;;;ACDT,IAAM,UAAN,MAAc;AAAA,EAArB,OAAqB;AAAA;AAAA;AAAA,EACjB,YAAY,MAAM,OAAO,CAAC,GAAG;AACzB,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,QAAI,KAAK,QAAQ,KAAK,KAAK,QAAQ;AAC/B,YAAM,QAAQ,KAAK,KAAK,QAAQ,IAAI;AACpC,WAAK,OAAO,MAAM,MAAM;AACxB,WAAK,SAAS,MAAM,MAAM;AAC1B,WAAK,UAAU,MAAM,IAAI;AACzB,WAAK,YAAY,MAAM,IAAI;AAAA,IAC/B;AACA,eAAW,OAAO;AACd,WAAK,GAAG,IAAI,KAAK,GAAG;AAAA,EAC5B;AAAA,EACA,WAAW;AACP,QAAI,KAAK,MAAM;AACX,aAAO,KAAK,KAAK,MAAM,KAAK,MAAM;AAAA,QAC9B,OAAO,KAAK;AAAA,QACZ,QAAQ,KAAK;AAAA,QACb,MAAM,KAAK;AAAA,MACf,CAAC,EAAE;AAAA,IACP;AACA,QAAI,KAAK,QAAQ;AACb,aAAO,KAAK,SAAS,OAAO,KAAK;AAAA,IACrC;AACA,WAAO,KAAK;AAAA,EAChB;AACJ;;;AC1BO,IAAM,SAAN,MAAa;AAAA,EADpB,OACoB;AAAA;AAAA;AAAA,EAChB,YAAY,WAAWC,OAAM,MAAM;AAC/B,SAAK,YAAY;AACjB,SAAK,WAAW,CAAC;AACjB,SAAK,OAAOA;AACZ,SAAK,OAAO;AACZ,SAAK,MAAM;AACX,SAAK,MAAM;AAAA,EACf;AAAA,EACA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,KAAK,MAAM,OAAO,CAAC,GAAG;AAClB,QAAI,CAAC,KAAK,QAAQ;AACd,UAAI,KAAK,cAAc,KAAK,WAAW,eAAe;AAClD,aAAK,SAAS,KAAK,WAAW;AAAA,MAClC;AAAA,IACJ;AACA,UAAM,UAAU,IAAI,QAAQ,MAAM,IAAI;AACtC,SAAK,SAAS,KAAK,OAAO;AAC1B,WAAO;AAAA,EACX;AAAA,EACA,WAAW;AACP,WAAO,KAAK,SAAS,OAAO,OAAK,EAAE,SAAS,SAAS;AAAA,EACzD;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK;AAAA,EAChB;AACJ;;;ACxBO,IAAM,eAAN,MAAmB;AAAA,EAL1B,OAK0B;AAAA;AAAA;AAAA,EACtB,YAAY,WAAW,KAAK,MAAM;AAC9B,UAAM,IAAI,SAAS;AACnB,SAAK,cAAc;AACnB,SAAK,aAAa;AAClB,SAAK,OAAO;AACZ,SAAK,QAAQ;AACb,SAAK,OAAO;AACZ,QAAIC;AACJ,UAAMC,OAAM;AACZ,SAAK,SAAS,IAAI,OAAO,KAAK,YAAYD,OAAM,KAAK,KAAK;AAC1D,SAAK,OAAO,MAAM;AAClB,UAAM,OAAO;AACb,WAAO,eAAe,KAAK,QAAQ,QAAQ;AAAA,MACvC,MAAM;AACF,eAAO,KAAK;AAAA,MAChB;AAAA,IACJ,CAAC;AACD,UAAM,MAAM,IAAI,aAAaC,MAAKD,OAAM,KAAK,OAAO,GAAG;AACvD,QAAI,IAAI,MAAM,GAAG;AACb,YAAM,CAAC,cAAc,YAAY,IAAI,IAAI,SAAS;AAClD,UAAI,cAAc;AACd,aAAK,OAAO,MAAM;AAAA,MACtB;AACA,UAAI,cAAc;AACd,aAAK,OAAO,MAAM;AAAA,MACtB;AAAA,IACJ,OACK;AACD,UAAI,gBAAgB;AACpB,WAAK,OAAO,MAAM,IAAI;AAAA,IAC1B;AAAA,EACJ;AAAA,EACA,QAAQ;AACJ,QAAI,KAAK;AACL,aAAO,QAAQ,OAAO,KAAK,KAAK;AACpC,WAAO,QAAQ,QAAQ,KAAK,MAAM;AAAA,EACtC;AAAA,EACA,MAAM,YAAY;AACd,WAAO,KAAK,MAAM,EAAE,MAAM,UAAU;AAAA,EACxC;AAAA,EACA,QAAQ,WAAW;AACf,WAAO,KAAK,MAAM,EAAE,KAAK,WAAW,SAAS;AAAA,EACjD;AAAA,EACA,OAAO;AACH,QAAI,KAAK;AACL,YAAM,KAAK;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,KAAK,aAAa,YAAY;AAC1B,QAAI,QAAQ,IAAI,aAAa,cAAc;AACvC,UAAI,EAAE,UAAU,KAAK,QAAQ;AACzB,iBAAS,yKAEuC;AAAA,MACpD;AAAA,IACJ;AACA,WAAO,KAAK,MAAM,EAAE,KAAK,aAAa,UAAU;AAAA,EACpD;AAAA,EACA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,WAAW;AACP,WAAO,CAAC;AAAA,EACZ;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,MAAM;AACN,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,MAAM;AACN,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,WAAW;AACX,WAAO,CAAC;AAAA,EACZ;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,OAAO;AACP,QAAI,KAAK,OAAO;AACZ,aAAO,KAAK;AAAA,IAChB;AACA,QAAIA;AACJ,UAAME,UAASC;AACf,QAAI;AACA,MAAAH,QAAOE,QAAO,KAAK,MAAM,KAAK,KAAK;AAAA,IACvC,SACO,OAAO;AACV,WAAK,QAAQ;AAAA,IACjB;AACA,QAAI,KAAK,OAAO;AACZ,YAAM,KAAK;AAAA,IACf,OACK;AACD,WAAK,QAAQF;AACb,aAAOA;AAAA,IACX;AAAA,EACJ;AAAA,EACA,KAAK,OAAO,WAAW,IAAI;AACvB,WAAO;AAAA,EACX;AACJ;;;ACtGA,IAAM,qBAAqB;AAAA,EACvB,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,MAAM;AAAA,EACN,UAAU;AAAA,EACV,MAAM;AAAA,EACN,MAAM;AACV;AACA,IAAM,eAAe;AAAA,EACjB,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,aAAa;AAAA,EACb,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,UAAU;AAAA,EACV,cAAc;AAAA,EACd,MAAM;AAAA,EACN,UAAU;AAAA,EACV,eAAe;AAAA,EACf,SAAS;AAAA,EACT,MAAM;AAAA,EACN,UAAU;AAAA,EACV,MAAM;AAAA,EACN,UAAU;AACd;AACA,IAAM,eAAe;AAAA,EACjB,MAAM;AAAA,EACN,eAAe;AAAA,EACf,SAAS;AACb;AACA,IAAM,WAAW;AACjB,SAAS,UAAU,KAAK;AACpB,SAAO,OAAO,QAAQ,YAAY,OAAO,IAAI,SAAS;AAC1D;AAFS;AAGT,SAAS,UAAU,MAAM;AACrB,MAAI,MAAM;AACV,QAAM,OAAO,mBAAmB,KAAK,IAAI;AACzC,MAAI,KAAK,SAAS,QAAQ;AACtB,UAAM,KAAK,KAAK,YAAY;AAAA,EAChC,WACS,KAAK,SAAS,UAAU;AAC7B,UAAM,KAAK,KAAK,YAAY;AAAA,EAChC;AACA,MAAI,OAAO,KAAK,QAAQ;AACpB,WAAO;AAAA,MACH;AAAA,MACA,OAAO,MAAM;AAAA,MACb;AAAA,MACA,OAAO;AAAA,MACP,OAAO,UAAU;AAAA,IACrB;AAAA,EACJ,WACS,KAAK;AACV,WAAO,CAAC,MAAM,OAAO,MAAM,KAAK,OAAO,QAAQ,OAAO,UAAU,GAAG;AAAA,EACvE,WACS,KAAK,QAAQ;AAClB,WAAO,CAAC,MAAM,UAAU,OAAO,MAAM;AAAA,EACzC,OACK;AACD,WAAO,CAAC,MAAM,OAAO,MAAM;AAAA,EAC/B;AACJ;AA3BS;AA4BT,SAAS,QAAQ,MAAM;AACnB,MAAI;AACJ,MAAI,KAAK,SAAS,YAAY;AAC1B,aAAS,CAAC,YAAY,UAAU,cAAc;AAAA,EAClD,WACS,KAAK,SAAS,QAAQ;AAC3B,aAAS,CAAC,QAAQ,UAAU,UAAU;AAAA,EAC1C,OACK;AACD,aAAS,UAAU,IAAI;AAAA,EAC3B;AACA,SAAO;AAAA,IACH,YAAY;AAAA,IACZ;AAAA,IACA,UAAU;AAAA,IACV;AAAA,IACA,cAAc;AAAA,IACd,UAAU,CAAC;AAAA,EACf;AACJ;AAnBS;AAoBT,SAAS,WAAW,MAAM;AACtB,OAAK,OAAO,IAAI;AAChB,MAAI,KAAK;AACL,SAAK,MAAM,QAAQ,OAAK,WAAW,CAAC,CAAC;AACzC,SAAO;AACX;AALS;AAMT,IAAI,UAAU,CAAC;AACR,IAAMI,cAAN,MAAM,YAAW;AAAA,EAnGxB,OAmGwB;AAAA;AAAA;AAAA,EACpB,YAAY,WAAW,KAAK,MAAM;AAC9B,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,QAAIC;AACJ,QAAI,OAAO,QAAQ,YACf,QAAQ,SACP,IAAI,SAAS,UAAU,IAAI,SAAS,aAAa;AAClD,MAAAA,QAAO,WAAW,GAAG;AAAA,IACzB,WACS,eAAe,eAAc,eAAe,QAAQ;AACzD,MAAAA,QAAO,WAAW,IAAI,IAAI;AAC1B,UAAI,IAAI,KAAK;AACT,YAAI,OAAO,KAAK,QAAQ;AACpB,eAAK,MAAM,CAAC;AAChB,YAAI,CAAC,KAAK,IAAI;AACV,eAAK,IAAI,SAAS;AACtB,aAAK,IAAI,OAAO,IAAI;AAAA,MACxB;AAAA,IACJ,OACK;AACD,UAAIC,UAASC;AACb,UAAI,KAAK;AACL,QAAAD,UAAS,KAAK,OAAO;AACzB,UAAI,KAAK;AACL,QAAAA,UAAS,KAAK;AAClB,UAAIA,QAAO;AACP,QAAAA,UAASA,QAAO;AACpB,UAAI;AACA,QAAAD,QAAOC,QAAO,KAAK,IAAI;AAAA,MAC3B,SACO,OAAO;AACV,aAAK,YAAY;AACjB,aAAK,QAAQ;AAAA,MACjB;AACA,UAAID,SAAQ,CAACA,MAAK,EAAE,GAAG;AAEnB,kBAAU,QAAQA,KAAI;AAAA,MAC1B;AAAA,IACJ;AACA,SAAK,SAAS,IAAI,OAAO,WAAWA,OAAM,IAAI;AAC9C,SAAK,UAAU,EAAE,GAAG,SAAS,SAAS,QAAQ,KAAK,OAAO;AAC1D,SAAK,UAAU,KAAK,UAAU,QAAQ,IAAI,CAAAG,YAAU;AAChD,UAAI,OAAOA,YAAW,YAAYA,QAAO,SAAS;AAC9C,eAAO,EAAE,GAAGA,SAAQ,GAAGA,QAAO,QAAQ,KAAK,MAAM,EAAE;AAAA,MACvD,OACK;AACD,eAAOA;AAAA,MACX;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,QAAQ;AACJ,QAAI,KAAK;AACL,aAAO,QAAQ,OAAO,KAAK,KAAK;AACpC,QAAI,KAAK;AACL,aAAO,QAAQ,QAAQ,KAAK,MAAM;AACtC,QAAI,CAAC,KAAK,YAAY;AAClB,WAAK,aAAa,KAAK,SAAS;AAAA,IACpC;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM,YAAY;AACd,WAAO,KAAK,MAAM,EAAE,MAAM,UAAU;AAAA,EACxC;AAAA,EACA,QAAQ,WAAW;AACf,WAAO,KAAK,MAAM,EAAE,KAAK,WAAW,SAAS;AAAA,EACjD;AAAA,EACA,gBAAgB;AACZ,UAAM,IAAI,MAAM,sDAAsD;AAAA,EAC1E;AAAA,EACA,YAAY,OAAO,MAAM;AACrB,UAAMA,UAAS,KAAK,OAAO;AAC3B,QAAI;AACA,UAAI;AACA,aAAK,WAAW,KAAK;AACzB,WAAK,QAAQ;AACb,UAAI,MAAM,SAAS,oBAAoB,CAAC,MAAM,QAAQ;AAClD,cAAM,SAASA,QAAO;AACtB,cAAM,WAAW;AAAA,MACrB,WACSA,QAAO,gBAAgB;AAC5B,YAAI,QAAQ,IAAI,aAAa,cAAc;AACvC,gBAAM,aAAaA,QAAO;AAC1B,gBAAM,YAAYA,QAAO;AACzB,gBAAM,aAAa,KAAK,OAAO,UAAU;AACzC,gBAAM,IAAI,UAAU,MAAM,GAAG;AAC7B,gBAAM,IAAI,WAAW,MAAM,GAAG;AAC9B,cAAI,EAAE,CAAC,MAAM,EAAE,CAAC,KAAK,OAAO,SAAS,EAAE,CAAC,CAAC,IAAI,OAAO,SAAS,EAAE,CAAC,CAAC,GAAG;AAEhE,oBAAQ,MAAM,wEAEV,aACA,WACA,aACA,WACA,YACA,kDAAkD;AAAA,UAC1D;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,SACO,KAAK;AAGR,UAAI,WAAW,QAAQ;AACnB,gBAAQ,MAAM,GAAG;AAAA,IACzB;AACA,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB;AACd,SAAK,YAAY,CAAC;AAClB,UAAM,MAAM,wBAACA,SAAQ,MAAM,OAAO;AAC9B,UAAI,CAAC,KAAK,UAAU,IAAI;AACpB,aAAK,UAAU,IAAI,IAAI,CAAC;AAC5B,WAAK,UAAU,IAAI,EAAE,KAAK,CAACA,SAAQ,EAAE,CAAC;AAAA,IAC1C,GAJY;AAKZ,eAAWA,WAAU,KAAK,SAAS;AAC/B,UAAI,OAAOA,YAAW,UAAU;AAC5B,mBAAW,SAASA,SAAQ;AACxB,cAAI,CAAC,aAAa,KAAK,KAAK,SAAS,KAAK,KAAK,GAAG;AAC9C,kBAAM,IAAI,MAAM,iBAAiB,KAAK,OAAOA,QAAO,aAAa,4BACnC,KAAK,UAAU,OAAO,QAAQ;AAAA,UAChE;AACA,cAAI,CAAC,aAAa,KAAK,GAAG;AACtB,gBAAI,OAAOA,QAAO,KAAK,MAAM,UAAU;AACnC,yBAAW,UAAUA,QAAO,KAAK,GAAG;AAChC,oBAAI,WAAW,KAAK;AAChB,sBAAIA,SAAQ,OAAOA,QAAO,KAAK,EAAE,MAAM,CAAC;AAAA,gBAC5C,OACK;AACD,sBAAIA,SAAQ,QAAQ,MAAM,OAAO,YAAY,GAAGA,QAAO,KAAK,EAAE,MAAM,CAAC;AAAA,gBACzE;AAAA,cACJ;AAAA,YACJ,WACS,OAAOA,QAAO,KAAK,MAAM,YAAY;AAC1C,kBAAIA,SAAQ,OAAOA,QAAO,KAAK,CAAC;AAAA,YACpC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,SAAK,cAAc,OAAO,KAAK,KAAK,SAAS,EAAE,SAAS;AAAA,EAC5D;AAAA,EACA,MAAM,WAAW;AACb,SAAK,SAAS;AACd,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KAAK;AAC1C,YAAMA,UAAS,KAAK,QAAQ,CAAC;AAC7B,YAAM,UAAU,KAAK,UAAUA,OAAM;AACrC,UAAI,UAAU,OAAO,GAAG;AACpB,YAAI;AACA,gBAAM;AAAA,QACV,SACO,OAAO;AACV,gBAAM,KAAK,YAAY,KAAK;AAAA,QAChC;AAAA,MACJ;AAAA,IACJ;AACA,SAAK,gBAAgB;AACrB,QAAI,KAAK,aAAa;AAClB,YAAMH,QAAO,KAAK,OAAO;AACzB,aAAO,CAACA,MAAK,OAAO,GAAG;AACnB,QAAAA,MAAK,OAAO,IAAI;AAChB,cAAM,QAAQ,CAAC,QAAQA,KAAI,CAAC;AAC5B,eAAO,MAAM,SAAS,GAAG;AACrB,gBAAM,UAAU,KAAK,UAAU,KAAK;AACpC,cAAI,UAAU,OAAO,GAAG;AACpB,gBAAI;AACA,oBAAM;AAAA,YACV,SACO,GAAG;AACN,oBAAM,OAAO,MAAM,MAAM,SAAS,CAAC,EAAE;AACrC,oBAAM,KAAK,YAAY,GAAG,IAAI;AAAA,YAClC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,KAAK,UAAU,UAAU;AACzB,mBAAW,CAACG,SAAQ,OAAO,KAAK,KAAK,UAAU,UAAU;AACrD,eAAK,OAAO,aAAaA;AACzB,cAAI;AACA,gBAAIH,MAAK,SAAS,YAAY;AAC1B,oBAAM,QAAQA,MAAK,MAAM,IAAI,aAAW,QAAQ,SAAS,KAAK,OAAO,CAAC;AACtE,oBAAM,QAAQ,IAAI,KAAK;AAAA,YAC3B,OACK;AACD,oBAAM,QAAQA,OAAM,KAAK,OAAO;AAAA,YACpC;AAAA,UACJ,SACO,GAAG;AACN,kBAAM,KAAK,YAAY,CAAC;AAAA,UAC5B;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,SAAK,YAAY;AACjB,WAAO,KAAK,UAAU;AAAA,EAC1B;AAAA,EACA,UAAUG,SAAQ;AACd,SAAK,OAAO,aAAaA;AACzB,QAAI;AACA,UAAI,OAAOA,YAAW,YAAYA,QAAO,MAAM;AAC3C,YAAI,KAAK,OAAO,KAAK,SAAS,YAAY;AACtC,gBAAM,QAAQ,KAAK,OAAO,KAAK,MAAM,IAAI,CAAAH,UAAQG,QAAO,KAAKH,OAAM,KAAK,OAAO,CAAC;AAChF,cAAI,UAAU,MAAM,CAAC,CAAC,GAAG;AACrB,mBAAO,QAAQ,IAAI,KAAK;AAAA,UAC5B;AACA,iBAAO;AAAA,QACX;AACA,eAAOG,QAAO,KAAK,KAAK,OAAO,MAAM,KAAK,OAAO;AAAA,MACrD,WACS,OAAOA,YAAW,YAAY;AACnC,eAAOA,QAAO,KAAK,OAAO,MAAM,KAAK,MAAM;AAAA,MAC/C;AAAA,IACJ,SACO,OAAO;AACV,YAAM,KAAK,YAAY,KAAK;AAAA,IAChC;AAAA,EACJ;AAAA,EACA,YAAY;AACR,QAAI,KAAK;AACL,YAAM,KAAK;AACf,QAAI,KAAK;AACL,aAAO,KAAK;AAChB,SAAK,cAAc;AACnB,SAAK,KAAK;AACV,UAAM,OAAO,KAAK,OAAO;AACzB,QAAIC,OAAM;AACV,QAAI,KAAK;AACL,MAAAA,OAAM,KAAK,OAAO;AACtB,QAAI,KAAK;AACL,MAAAA,OAAM,KAAK;AACf,QAAIA,KAAI;AACJ,MAAAA,OAAMA,KAAI;AACd,UAAM,MAAM,IAAI,aAAaA,MAAK,KAAK,OAAO,MAAM,KAAK,OAAO,IAAI;AACpE,UAAM,OAAO,IAAI,SAAS;AAC1B,SAAK,OAAO,MAAM,KAAK,CAAC;AACxB,SAAK,OAAO,MAAM,KAAK,CAAC;AACxB,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,OAAO;AACH,QAAI,KAAK;AACL,YAAM,KAAK;AACf,QAAI,KAAK;AACL,aAAO,KAAK;AAChB,SAAK,YAAY;AACjB,QAAI,KAAK,YAAY;AACjB,YAAM,KAAK,cAAc;AAAA,IAC7B;AACA,eAAWD,WAAU,KAAK,SAAS;AAC/B,YAAM,UAAU,KAAK,UAAUA,OAAM;AACrC,UAAI,UAAU,OAAO,GAAG;AACpB,cAAM,KAAK,cAAc;AAAA,MAC7B;AAAA,IACJ;AACA,SAAK,gBAAgB;AACrB,QAAI,KAAK,aAAa;AAClB,YAAMH,QAAO,KAAK,OAAO;AACzB,aAAO,CAACA,MAAK,OAAO,GAAG;AACnB,QAAAA,MAAK,OAAO,IAAI;AAChB,aAAK,SAASA,KAAI;AAAA,MACtB;AACA,UAAI,KAAK,UAAU,UAAU;AACzB,YAAIA,MAAK,SAAS,YAAY;AAC1B,qBAAW,WAAWA,MAAK,OAAO;AAC9B,iBAAK,UAAU,KAAK,UAAU,UAAU,OAAO;AAAA,UACnD;AAAA,QACJ,OACK;AACD,eAAK,UAAU,KAAK,UAAU,UAAUA,KAAI;AAAA,QAChD;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,KAAK,aAAa,YAAY;AAC1B,QAAI,QAAQ,IAAI,aAAa,cAAc;AACvC,UAAI,EAAE,UAAU,KAAK,OAAO;AACxB,iBAAS,yKAEuC;AAAA,MACpD;AAAA,IACJ;AACA,WAAO,KAAK,MAAM,EAAE,KAAK,aAAa,UAAU;AAAA,EACpD;AAAA,EACA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,UAAU,UAAU,MAAM;AACtB,eAAW,CAACG,SAAQ,OAAO,KAAK,UAAU;AACtC,WAAK,OAAO,aAAaA;AACzB,UAAI;AACJ,UAAI;AACA,kBAAU,QAAQ,MAAM,KAAK,OAAO;AAAA,MACxC,SACO,GAAG;AACN,cAAM,KAAK,YAAY,GAAG,KAAK,OAAO;AAAA,MAC1C;AACA,UAAI,KAAK,SAAS,UAAU,KAAK,SAAS,cAAc,CAAC,KAAK,QAAQ;AAClE,eAAO;AAAA,MACX;AACA,UAAI,UAAU,OAAO,GAAG;AACpB,cAAM,KAAK,cAAc;AAAA,MAC7B;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,UAAU,OAAO;AACb,UAAM,QAAQ,MAAM,MAAM,SAAS,CAAC;AACpC,UAAM,EAAE,MAAM,SAAS,IAAI;AAC3B,QAAI,KAAK,SAAS,UAAU,KAAK,SAAS,cAAc,CAAC,KAAK,QAAQ;AAClE,YAAM,IAAI;AACV;AAAA,IACJ;AACA,QAAI,SAAS,SAAS,KAAK,MAAM,eAAe,SAAS,QAAQ;AAC7D,YAAM,CAACA,SAAQ,OAAO,IAAI,SAAS,MAAM,YAAY;AACrD,YAAM,gBAAgB;AACtB,UAAI,MAAM,iBAAiB,SAAS,QAAQ;AACxC,cAAM,WAAW,CAAC;AAClB,cAAM,eAAe;AAAA,MACzB;AACA,WAAK,OAAO,aAAaA;AACzB,UAAI;AACA,eAAO,QAAQ,KAAK,QAAQ,GAAG,KAAK,OAAO;AAAA,MAC/C,SACO,GAAG;AACN,cAAM,KAAK,YAAY,GAAG,IAAI;AAAA,MAClC;AAAA,IACJ;AACA,QAAI,MAAM,aAAa,GAAG;AACtB,YAAM,WAAW,MAAM;AACvB,UAAI;AACJ,aAAQ,QAAQ,KAAK,MAAM,KAAK,QAAQ,QAAQ,CAAC,GAAI;AACjD,aAAK,QAAQ,QAAQ,KAAK;AAC1B,YAAI,CAAC,MAAM,OAAO,GAAG;AACjB,gBAAM,OAAO,IAAI;AACjB,gBAAM,KAAK,QAAQ,KAAK,CAAC;AACzB;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,WAAW;AACjB,aAAO,KAAK,QAAQ,QAAQ;AAAA,IAChC;AACA,UAAM,SAAS,MAAM;AACrB,WAAO,MAAM,aAAa,OAAO,QAAQ;AACrC,YAAM,QAAQ,OAAO,MAAM,UAAU;AACrC,YAAM,cAAc;AACpB,UAAI,UAAU,UAAU;AACpB,YAAI,KAAK,SAAS,KAAK,MAAM,QAAQ;AACjC,eAAK,OAAO,IAAI;AAChB,gBAAM,WAAW,KAAK,YAAY;AAAA,QACtC;AACA;AAAA,MACJ,WACS,KAAK,UAAU,KAAK,GAAG;AAC5B,cAAM,WAAW,KAAK,UAAU,KAAK;AACrC;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,IAAI;AAAA,EACd;AAAA,EACA,SAAS,MAAM;AACX,SAAK,OAAO,IAAI;AAChB,UAAM,SAAS,UAAU,IAAI;AAC7B,eAAW,SAAS,QAAQ;AACxB,UAAI,UAAU,UAAU;AACpB,YAAI,KAAK,OAAO;AACZ,eAAK,KAAK,WAAS;AACf,gBAAI,CAAC,MAAM,OAAO;AACd,mBAAK,SAAS,KAAK;AAAA,UAC3B,CAAC;AAAA,QACL;AAAA,MACJ,OACK;AACD,cAAM,WAAW,KAAK,UAAU,KAAK;AACrC,YAAI,UAAU;AACV,cAAI,KAAK,UAAU,UAAU,KAAK,QAAQ,CAAC;AACvC;AAAA,QACR;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,WAAW;AACP,WAAO,KAAK,KAAK,EAAE,SAAS;AAAA,EAChC;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,UAAU,EAAE;AAAA,EAC5B;AAAA,EACA,IAAI,MAAM;AACN,WAAO,KAAK,UAAU,EAAE;AAAA,EAC5B;AAAA,EACA,IAAI,MAAM;AACN,WAAO,KAAK,UAAU,EAAE;AAAA,EAC5B;AAAA,EACA,IAAI,WAAW;AACX,WAAO,KAAK,KAAK,EAAE;AAAA,EACvB;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,KAAK,EAAE;AAAA,EACvB;AAAA,EACA,KAAK,OAAO,WAAW,IAAI;AACvB,WAAO;AAAA,EACX;AACJ;AACAJ,YAAW,kBAAkB,eAAa;AACtC,YAAU;AACd;AACAM,MAAK,mBAAmBN,WAAU;AAClC,SAAS,mBAAmBA,WAAU;;;AC3f/B,IAAMO,aAAN,MAAgB;AAAA,EAJvB,OAIuB;AAAA;AAAA;AAAA,EACnB,YAAY,UAAU,CAAC,GAAG;AACtB,SAAK,UAAU;AACf,SAAK,UAAU,KAAK,UAAU,OAAO;AAAA,EACzC;AAAA,EACA,UAAU,SAAS;AACf,QAAI,aAAa,CAAC;AAClB,aAAS,KAAK,SAAS;AACnB,UAAI,EAAE,YAAY,MAAM;AACpB,YAAI,EAAE;AAAA,MACV,WACS,EAAE,SAAS;AAChB,YAAI,EAAE;AAAA,MACV;AACA,UAAI,OAAO,MAAM,YAAY,MAAM,QAAQ,EAAE,OAAO,GAAG;AACnD,qBAAa,WAAW,OAAO,EAAE,OAAO;AAAA,MAC5C,WACS,OAAO,MAAM,YAAY,EAAE,eAAe;AAC/C,mBAAW,KAAK,CAAC;AAAA,MACrB,WACS,OAAO,MAAM,YAAY;AAC9B,mBAAW,KAAK,CAAC;AAAA,MACrB,WACS,OAAO,MAAM,aAAa,EAAE,SAAS,EAAE,YAAY;AACxD,YAAI,QAAQ,IAAI,aAAa,cAAc;AACvC,gBAAM,IAAI,MAAM,gKAE2B;AAAA,QAC/C;AAAA,MACJ,OACK;AACD,cAAM,IAAI,MAAM,IAAI,0BAA0B;AAAA,MAClD;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,KAAK,OAAO,CAAC,GAAG;AACpB,QAAI,CAAC,KAAK,QAAQ,UACd,CAAC,KAAK,UACN,CAAC,KAAK,eACN,CAAC,KAAK,QAAQ;AACd,aAAO,IAAI,aAAa,MAAM,KAAK,IAAI;AAAA,IAC3C,OACK;AACD,aAAO,IAAIC,YAAW,MAAM,KAAK,IAAI;AAAA,IACzC;AAAA,EACJ;AAAA,EACA,IAAIC,SAAQ;AACR,SAAK,UAAU,KAAK,QAAQ,OAAO,KAAK,UAAU,CAACA,OAAM,CAAC,CAAC;AAC3D,WAAO;AAAA,EACX;AACJ;AACAC,MAAK,kBAAkBH,UAAS;AAChC,SAAS,kBAAkBA,UAAS;;;ACvCpCI,YAAW,gBAAgBC,QAAO;AAClC,SAASA,YAAW,SAAS;AACzB,MAAI,QAAQ,WAAW,KAAK,MAAM,QAAQ,QAAQ,CAAC,CAAC,GAAG;AACnD,cAAU,QAAQ,CAAC;AAAA,EACvB;AACA,SAAO,IAAIC,WAAU,OAAO;AAChC;AALS,OAAAD,UAAA;AAMTA,SAAQ,SAAS,gCAAS,OAAO,MAAM,aAAa;AAChD,MAAI,iBAAiB;AACrB,WAAS,WAAW,MAAM;AAEtB,UAAM,cAAc,YAAY,GAAG,IAAI;AACvC,gBAAY,gBAAgB;AAC5B,gBAAY,iBAAiB,IAAIC,WAAU,EAAE;AAC7C,WAAO;AAAA,EACX;AANS;AAOT,MAAI;AACJ,SAAO,eAAe,SAAS,WAAW;AAAA,IACtC,MAAM;AACF,UAAI,CAAC;AACD,gBAAQ,QAAQ;AACpB,aAAO;AAAA,IACX;AAAA,EACJ,CAAC;AACD,UAAQ,UAAU,CAAC,KAAK,aAAa,eAAeD,SAAQ,CAAC,QAAQ,UAAU,CAAC,CAAC,EAAE,QAAQ,KAAK,WAAW;AAC3G,SAAO;AACX,GAnBiB;AAoBjBA,SAAQ,YAAY;AACpBA,SAAQ,QAAQE;AAChBF,SAAQ,WAAW;AACnBA,SAAQ,OAAO;AACfA,SAAQ,UAAU,cAAY,IAAI,QAAQ,QAAQ;AAClDA,SAAQ,SAAS,cAAY,IAAIG,QAAO,QAAQ;AAChDH,SAAQ,OAAO,cAAY,IAAI,YAAY,QAAQ;AACnDA,SAAQ,OAAO,cAAY,IAAII,MAAK,QAAQ;AAC5CJ,SAAQ,OAAO,cAAY,IAAIK,MAAK,QAAQ;AAC5CL,SAAQ,WAAW,cAAY,IAAI,SAAS,QAAQ;AACpDA,SAAQ,iBAAiB;AACzBA,SAAQ,cAAc;AACtBA,SAAQ,YAAY;AACpBA,SAAQ,YAAYC;AACpBD,SAAQ,WAAW;AACnBA,SAAQ,UAAU;AAClBA,SAAQ,UAAU;AAClBA,SAAQ,SAASG;AACjBH,SAAQ,SAAS;AACjBA,SAAQ,QAAQ;AAChBA,SAAQ,OAAOI;AACfJ,SAAQ,OAAOK;AACfL,SAAQ,OAAO;AACf,IAAO,kBAAQA;;;AC7Df,SAAS,UAAUM,MAAK;AACpB,QAAM,QAAQA,KAAI,YAAY;AAC9B,MAAIC,OAAM;AACV,MAAI,kBAAkB;AACtB,WAAS,IAAI,GAAG,IAAI,KAAK,MAAM,CAAC,MAAM,QAAW,KAAK;AAClD,UAAM,OAAO,MAAM,WAAW,CAAC;AAE/B,UAAM,QAAS,QAAQ,MAAM,QAAQ,OAAS,QAAQ,MAAM,QAAQ;AAEpE,sBAAkB,SAAS;AAC3B,QAAI,CAAC,OAAO;AACR;AAAA,IACJ;AACA,IAAAA,QAAO,MAAM,CAAC;AAAA,EAClB;AACA,MAAIA,KAAI,WAAW,GAAG;AAClB,WAAO;AAAA,EACX;AACA,QAAM,YAAY,SAASA,MAAK,EAAE;AAClC,QAAM,cAAc,aAAa,SAAU,aAAa;AAIxD,MAAI,eAAe,cAAc,KAAU,YAAY,SAAU;AAC7D,WAAO,CAAC,UAAUA,KAAI,UAAU,kBAAkB,IAAI,EAAE;AAAA,EAC5D;AACA,SAAO;AAAA,IACH,OAAO,cAAc,SAAS;AAAA,IAC9BA,KAAI,UAAU,kBAAkB,IAAI;AAAA,EACxC;AACJ;AA9BS;AA+BT,IAAM,kBAAkB;AACT,SAAR,MAAuBD,MAAK;AAC/B,MAAI,gBAAgB,gBAAgB,KAAKA,IAAG;AAC5C,MAAI,CAAC,eAAe;AAChB,WAAOA;AAAA,EACX;AACA,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAIA,KAAI,QAAQ,KAAK;AACjC,QAAKA,KAAI,CAAC,MAAM,MAAO;AACnB,YAAM,UAAU,UAAUA,KAAI,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC;AACjD,UAAI,YAAY,QAAW;AACvB,eAAO,QAAQ,CAAC;AAChB,aAAK,QAAQ,CAAC;AACd;AAAA,MACJ;AAGA,UAAIA,KAAI,IAAI,CAAC,MAAM,MAAM;AACrB,eAAO;AACP;AACA;AAAA,MACJ;AAGA,UAAIA,KAAI,WAAW,IAAI,GAAG;AACtB,eAAOA,KAAI,CAAC;AAAA,MAChB;AACA;AAAA,IACJ;AACA,WAAOA,KAAI,CAAC;AAAA,EAChB;AACA,SAAO;AACX;AA/BwB;;;ACvCT,SAAR,QAAyB,QAAQ,OAAO;AAC3C,SAAO,MAAM,SAAS,GAAG;AACrB,UAAM,OAAO,MAAM,MAAM;AACzB,QAAI,CAAC,IAAI,IAAI,GAAG;AACZ,aAAO;AAAA,IACX;AACA,UAAM,IAAI,IAAI;AAAA,EAClB;AACA,SAAO;AACX;AATwB;;;ACAT,SAAR,aAA8B,QAAQ,OAAO;AAChD,SAAO,MAAM,SAAS,GAAG;AACrB,UAAM,OAAO,MAAM,MAAM;AACzB,QAAI,CAAC,IAAI,IAAI,GAAG;AACZ,UAAI,IAAI,IAAI,CAAC;AAAA,IACjB;AACA,UAAM,IAAI,IAAI;AAAA,EAClB;AACJ;AARwB;;;ACCxB,IAAIE,aAAY,gCAAU,KAAK,QAAQ;AACnC,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AACzC,WAAO;AAAA,EACX;AACA,MAAI,SAAS,IAAI,IAAI,YAAY;AACjC,WAAS,KAAK,KAAK;AACf,QAAI,CAAC,IAAI,eAAe,CAAC,GAAG;AACxB;AAAA,IACJ;AACA,QAAI,QAAQ,IAAI,CAAC;AACjB,QAAI,OAAO,OAAO;AAClB,QAAI,MAAM,YAAY,SAAS,UAAU;AACrC,UAAI,QAAQ;AACR,eAAO,CAAC,IAAI;AAAA,MAChB;AAAA,IACJ,WACS,iBAAiB,OAAO;AAC7B,aAAO,CAAC,IAAI,MAAM,IAAI,OAAKA,WAAU,GAAG,MAAM,CAAC;AAAA,IACnD,OACK;AACD,aAAO,CAAC,IAAIA,WAAU,OAAO,MAAM;AAAA,IACvC;AAAA,EACJ;AACA,SAAO;AACX,GAxBgB;AAyBhB,IAAqBC,QAArB,MAA0B;AAAA,EA1B1B,OA0B0B;AAAA;AAAA;AAAA,EACtB,YAAY,OAAO,CAAC,GAAG;AACnB,WAAO,OAAO,MAAM,IAAI;AACxB,SAAK,SAAS,KAAK,UAAU,CAAC;AAC9B,SAAK,OAAO,SAAS,KAAK,OAAO,UAAU;AAC3C,SAAK,OAAO,QAAQ,KAAK,OAAO,SAAS;AAAA,EAC7C;AAAA,EACA,SAAS;AACL,QAAI,KAAK,QAAQ;AACb,WAAK,OAAO,YAAY,IAAI;AAAA,IAChC;AACA,SAAK,SAAS;AACd,WAAO;AAAA,EACX;AAAA,EACA,cAAc;AACV,QAAI,KAAK,QAAQ;AACb,eAAS,SAAS,WAAW;AACzB,aAAK,OAAO,aAAa,MAAM,UAAU,KAAK,CAAC;AAAA,MACnD;AACA,WAAK,OAAO;AAAA,IAChB;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO;AACH,WAAO,KAAK,OAAO,GAAG,KAAK,OAAO,MAAM,IAAI,IAAI,CAAC;AAAA,EACrD;AAAA,EACA,OAAO;AACH,WAAO,KAAK,OAAO,GAAG,KAAK,OAAO,MAAM,IAAI,IAAI,CAAC;AAAA,EACrD;AAAA,EACA,MAAM,YAAY,CAAC,GAAG;AAClB,QAAI,SAASD,WAAU,IAAI;AAC3B,aAAS,QAAQ,WAAW;AACxB,aAAO,IAAI,IAAI,UAAU,IAAI;AAAA,IACjC;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,0BAA0B,MAAM,OAAO,cAAc;AACjD,QAAI,CAAC,KAAK,MAAM;AACZ,WAAK,OAAO,CAAC;AAAA,IACjB;AACA,QAAI,gBAAgB,KAAK,IAAI;AAC7B,QAAI,kBAAkB,KAAK,KAAK,IAAI;AACpC,SAAK,IAAI,IAAI,gBAAgB;AAC7B,QAAI,mBAAmB,iBAAiB,OAAO;AAC3C,WAAK,KAAK,IAAI,KAAK,mBAAmB,iBAAiB;AAAA,IAC3D,OACK;AACD,aAAO,KAAK,KAAK,IAAI;AAAA,IACzB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,qBAAqB,MAAM,OAAO,cAAc;AAC5C,QAAI,CAAC,KAAK,MAAM;AACZ,WAAK,OAAO,CAAC;AAAA,IACjB;AACA,SAAK,IAAI,IAAI;AACb,SAAK,KAAK,IAAI,IAAI;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,yBAAyB,MAAM,OAAO;AAClC,SAAK,IAAI,IAAI;AACb,QAAI,KAAK,MAAM;AACX,aAAO,KAAK,KAAK,IAAI;AAAA,IACzB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,MAAM,QAAQ;AACvB,QAAI,KAAK,UAAU,KAAK,OAAO,SAAS,KAAK,OAAO,KAAK;AACrD,UAAI,KAAK,OAAO,MAAM,OAAO,MAAM;AAC/B,eAAO;AAAA,MACX;AACA,UAAI,KAAK,OAAO,IAAI,OAAO,MAAM;AAC7B,eAAO;AAAA,MACX;AACA,UAAI,KAAK,OAAO,MAAM,SAAS,QAAQ,KAAK,OAAO,MAAM,SAAS,QAAQ;AACtE,eAAO;AAAA,MACX;AACA,UAAI,KAAK,OAAO,IAAI,SAAS,QAAQ,KAAK,OAAO,IAAI,SAAS,QAAQ;AAClE,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB,MAAM;AACpB,WAAQ,KAAK,QAAQ,KAAK,KAAK,IAAI,KAAM,KAAK,IAAI;AAAA,EACtD;AAAA,EACA,IAAI,iBAAiB;AACjB,QAAI,WAAW,KAAK,QAAQ,KAAK,KAAK,UAAU,KAAK,KAAK,OAAO;AACjE,QAAI,aAAa,QAAW;AACxB,iBAAW,KAAK,UAAU,KAAK,OAAO;AAAA,IAC1C;AACA,WAAO,YAAY;AAAA,EACvB;AAAA,EACA,IAAI,eAAe,KAAK;AACpB,iBAAa,MAAM,QAAQ,QAAQ;AACnC,SAAK,KAAK,OAAO,SAAS;AAAA,EAC9B;AAAA,EACA,IAAI,gBAAgB;AAChB,QAAI,WAAW,KAAK,QAAQ,KAAK,KAAK,UAAU,KAAK,KAAK,OAAO;AACjE,QAAI,aAAa,QAAW;AACxB,iBAAW,KAAK,OAAO;AAAA,IAC3B;AACA,WAAO,YAAY;AAAA,EACvB;AAAA,EACA,IAAI,cAAc,KAAK;AACnB,iBAAa,MAAM,QAAQ,QAAQ;AACnC,SAAK,KAAK,OAAO,QAAQ;AAAA,EAC7B;AAAA,EACA,gBAAgB;AACZ,WAAO,OAAO,KAAK,kBAAkB,OAAO,CAAC;AAAA,EACjD;AAAA,EACA,WAAW;AACP,WAAO;AAAA,MACH,KAAK;AAAA,MACL,KAAK,cAAc;AAAA,MACnB,KAAK;AAAA,IACT,EAAE,KAAK,EAAE;AAAA,EACb;AACJ;;;AC3KO,IAAM,MAAM;AACZ,IAAM,SAAS;AACf,IAAM,WAAW;AACjB,IAAM,OAAO;AACb,IAAM,SAAS;AACf,IAAM,UAAU;AAChB,IAAM,KAAK;AACX,IAAM,UAAU;AAChB,IAAM,aAAa;AACnB,IAAM,QAAQ;AACd,IAAM,YAAY;AAClB,IAAM,YAAY;;;ACTzB,IAAqBE,aAArB,cAAuCC,MAAK;AAAA,EAF5C,OAE4C;AAAA;AAAA;AAAA,EACxC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,QAAI,CAAC,KAAK,OAAO;AACb,WAAK,QAAQ,CAAC;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,OAAOC,WAAU;AACb,IAAAA,UAAS,SAAS;AAClB,SAAK,MAAM,KAAKA,SAAQ;AACxB,WAAO;AAAA,EACX;AAAA,EACA,QAAQA,WAAU;AACd,IAAAA,UAAS,SAAS;AAClB,SAAK,MAAM,QAAQA,SAAQ;AAC3B,aAASC,OAAM,KAAK,SAAS;AACzB,WAAK,QAAQA,GAAE;AAAA,IACnB;AACA,WAAO;AAAA,EACX;AAAA,EACA,GAAG,OAAO;AACN,WAAO,KAAK,MAAM,KAAK;AAAA,EAC3B;AAAA,EACA,MAAM,OAAO;AACT,QAAI,OAAO,UAAU,UAAU;AAC3B,aAAO;AAAA,IACX;AACA,WAAO,KAAK,MAAM,QAAQ,KAAK;AAAA,EACnC;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,KAAK,GAAG,CAAC;AAAA,EACpB;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,GAAG,KAAK,SAAS,CAAC;AAAA,EAClC;AAAA,EACA,IAAI,SAAS;AACT,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EACA,YAAY,OAAO;AACf,YAAQ,KAAK,MAAM,KAAK;AACxB,SAAK,GAAG,KAAK,EAAE,SAAS;AACxB,SAAK,MAAM,OAAO,OAAO,CAAC;AAC1B,QAAI;AACJ,aAASA,OAAM,KAAK,SAAS;AACzB,cAAQ,KAAK,QAAQA,GAAE;AACvB,UAAI,SAAS,OAAO;AAChB,aAAK,QAAQA,GAAE,IAAI,QAAQ;AAAA,MAC/B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,YAAY;AACR,aAAS,QAAQ,KAAK,OAAO;AACzB,WAAK,SAAS;AAAA,IAClB;AACA,SAAK,QAAQ,CAAC;AACd,WAAO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,WAAO,KAAK,UAAU;AAAA,EAC1B;AAAA,EACA,YAAY,SAAS,SAAS;AAC1B,YAAQ,SAAS;AACjB,QAAI,WAAW,KAAK,MAAM,OAAO;AACjC,SAAK,MAAM,OAAO,WAAW,GAAG,GAAG,OAAO;AAC1C,YAAQ,SAAS;AACjB,QAAI;AACJ,aAASA,OAAM,KAAK,SAAS;AACzB,cAAQ,KAAK,QAAQA,GAAE;AACvB,UAAI,WAAW,OAAO;AAClB,aAAK,QAAQA,GAAE,IAAI,QAAQ;AAAA,MAC/B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,aAAa,SAAS,SAAS;AAC3B,YAAQ,SAAS;AACjB,QAAI,WAAW,KAAK,MAAM,OAAO;AACjC,SAAK,MAAM,OAAO,UAAU,GAAG,OAAO;AACtC,YAAQ,SAAS;AACjB,QAAI;AACJ,aAASA,OAAM,KAAK,SAAS;AACzB,cAAQ,KAAK,QAAQA,GAAE;AACvB,UAAI,SAAS,UAAU;AACnB,aAAK,QAAQA,GAAE,IAAI,QAAQ;AAAA,MAC/B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,qBAAqB,MAAM,KAAK;AAC5B,QAAI,QAAQ;AACZ,SAAK,KAAK,UAAQ;AACd,UAAI,KAAK,YAAY;AACjB,YAAI,aAAa,KAAK,WAAW,MAAM,GAAG;AAC1C,YAAI,YAAY;AACZ,kBAAQ;AACR,iBAAO;AAAA,QACX;AAAA,MACJ,WACS,KAAK,aAAa,MAAM,GAAG,GAAG;AACnC,gBAAQ;AACR,eAAO;AAAA,MACX;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,WAAW,MAAM,KAAK;AAClB,QAAI,KAAK,aAAa,MAAM,GAAG,GAAG;AAC9B,aAAO,KAAK,qBAAqB,MAAM,GAAG,KAAK;AAAA,IACnD,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,oBAAoB;AAChB,QAAI,KAAK,QAAQ,KAAK,KAAK,UAAU,KAAK,KAAK,OAAO,KAAK;AACvD,WAAK,SAAS,KAAK,UAAU,CAAC;AAC9B,WAAK,OAAO,MAAM,KAAK,OAAO,OAAO,CAAC;AACtC,aAAO,OAAO,KAAK,OAAO,KAAK,KAAK,KAAK,OAAO,GAAG;AAAA,IACvD;AAAA,EACJ;AAAA,EACA,KAAK,UAAU;AACX,QAAI,CAAC,KAAK,UAAU;AAChB,WAAK,WAAW;AAAA,IACpB;AACA,QAAI,CAAC,KAAK,SAAS;AACf,WAAK,UAAU,CAAC;AAAA,IACpB;AACA,SAAK;AACL,QAAIA,MAAK,KAAK;AACd,SAAK,QAAQA,GAAE,IAAI;AACnB,QAAI,CAAC,KAAK,QAAQ;AACd,aAAO;AAAA,IACX;AACA,QAAI,OAAO;AACX,WAAO,KAAK,QAAQA,GAAE,IAAI,KAAK,QAAQ;AACnC,cAAQ,KAAK,QAAQA,GAAE;AACvB,eAAS,SAAS,KAAK,GAAG,KAAK,GAAG,KAAK;AACvC,UAAI,WAAW,OAAO;AAClB;AAAA,MACJ;AACA,WAAK,QAAQA,GAAE,KAAK;AAAA,IACxB;AACA,WAAO,KAAK,QAAQA,GAAE;AACtB,QAAI,WAAW,OAAO;AAClB,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,KAAK,UAAU;AACX,WAAO,KAAK,KAAK,CAAC,MAAM,MAAM;AAC1B,UAAI,SAAS,SAAS,MAAM,CAAC;AAC7B,UAAI,WAAW,SAAS,KAAK,QAAQ;AACjC,iBAAS,KAAK,KAAK,QAAQ;AAAA,MAC/B;AACA,UAAI,WAAW,OAAO;AAClB,eAAO;AAAA,MACX;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,eAAe,UAAU;AACrB,WAAO,KAAK,KAAK,CAACD,cAAa;AAC3B,UAAIA,UAAS,SAAe,WAAW;AACnC,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,YAAY,UAAU;AAClB,WAAO,KAAK,KAAK,CAACA,cAAa;AAC3B,UAAIA,UAAS,SAAe,OAAO;AAC/B,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,gBAAgB,UAAU;AACtB,WAAO,KAAK,KAAK,CAACA,cAAa;AAC3B,UAAIA,UAAS,SAAe,YAAY;AACpC,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,aAAa,UAAU;AACnB,WAAO,KAAK,KAAK,CAACA,cAAa;AAC3B,UAAIA,UAAS,SAAe,SAAS;AACjC,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,QAAQ,UAAU;AACd,WAAO,KAAK,KAAK,CAACA,cAAa;AAC3B,UAAIA,UAAS,SAAe,IAAI;AAC5B,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,YAAY,UAAU;AAClB,WAAO,KAAK,KAAK,CAAAA,cAAY;AACzB,UAAIA,UAAS,SAAe,SAAS;AACjC,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,YAAY,UAAU;AAClB,WAAO,KAAK,KAAK,CAACA,cAAa;AAC3B,UAAIA,UAAS,SAAe,QAAQ;AAChC,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,SAAS,UAAU;AACf,WAAO,KAAK,KAAK,CAACA,cAAa;AAC3B,UAAIA,UAAS,SAAe,KAAK;AAC7B,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,eAAe,UAAU;AACrB,WAAO,KAAK,KAAK,CAACA,cAAa;AAC3B,UAAIA,UAAS,SAAe,WAAW;AACnC,eAAO,SAAS,KAAK,MAAMA,SAAQ;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,MAAM,UAAU;AACZ,QAAI,UAAU,CAAC;AACf,WAAO,KAAK,OAAO,CAAC,MAAM,MAAM,UAAU;AACtC,UAAI,QAAQ,SAAS,KAAK,MAAM,IAAI;AACpC,cAAQ,KAAK,IAAI;AACjB,UAAI,OAAO;AACP,aAAK,KAAK,OAAO;AACjB,kBAAU,CAAC;AAAA,MACf,WACS,UAAU,KAAK,SAAS,GAAG;AAChC,aAAK,KAAK,OAAO;AAAA,MACrB;AACA,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAAA,EACT;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAClC;AAAA,EACA,OAAO,UAAU,MAAM;AACnB,WAAO,KAAK,MAAM,OAAO,UAAU,IAAI;AAAA,EAC3C;AAAA,EACA,MAAM,UAAU;AACZ,WAAO,KAAK,MAAM,MAAM,QAAQ;AAAA,EACpC;AAAA,EACA,KAAK,UAAU;AACX,WAAO,KAAK,MAAM,KAAK,QAAQ;AAAA,EACnC;AAAA,EACA,OAAO,UAAU;AACb,WAAO,KAAK,MAAM,OAAO,QAAQ;AAAA,EACrC;AAAA,EACA,KAAK,UAAU;AACX,WAAO,KAAK,MAAM,KAAK,QAAQ;AAAA,EACnC;AAAA,EACA,WAAW;AACP,WAAO,KAAK,IAAI,MAAM,EAAE,KAAK,EAAE;AAAA,EACnC;AACJ;;;AC/QA,IAAqBE,QAArB,cAAkCC,WAAU;AAAA,EAF5C,OAE4C;AAAA;AAAA;AAAA,EACxC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,WAAW;AACP,QAAIC,OAAM,KAAK,OAAO,CAAC,MAAMC,cAAa;AACtC,WAAK,KAAK,OAAOA,SAAQ,CAAC;AAC1B,aAAO;AAAA,IACX,GAAG,CAAC,CAAC,EAAE,KAAK,GAAG;AACf,WAAO,KAAK,gBAAgBD,OAAM,MAAMA;AAAA,EAC5C;AAAA,EACA,MAAM,SAAS,SAAS;AACpB,QAAI,KAAK,QAAQ;AACb,aAAO,KAAK,OAAO,SAAS,OAAO;AAAA,IACvC,OACK;AACD,aAAO,IAAI,MAAM,OAAO;AAAA,IAC5B;AAAA,EACJ;AAAA,EACA,IAAI,eAAe,SAAS;AACxB,SAAK,SAAS;AAAA,EAClB;AACJ;;;ACvBA,IAAqB,WAArB,cAAsCE,WAAU;AAAA,EAFhD,OAEgD;AAAA;AAAA;AAAA,EAC5C,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACPA,IAAM,SAAS,CAAC;AAChB,IAAM,iBAAiB,OAAO;AAC9B,IAAM,QAAQ,wBAAC,SAAS,aAAa;AACjC,MAAI,CAAC,SAAS;AACV,WAAO;AAAA,EACX;AACA,QAAM,SAAS,CAAC;AAChB,aAAW,OAAO,UAAU;AAGxB,WAAO,GAAG,IAAI,eAAe,KAAK,SAAS,GAAG,IACxC,QAAQ,GAAG,IACX,SAAS,GAAG;AAAA,EACtB;AACA,SAAO;AACX,GAbc;AAcd,IAAM,uBAAuB;AAC7B,IAAM,oBAAoB;AAE1B,IAAM,uBAAuB;AAE7B,IAAM,SAAS,mDAACC,SAAQ,YAAY;AAChC,YAAU,MAAM,SAAS,OAAO,OAAO;AACvC,MAAI,QAAQ,UAAU,YAAY,QAAQ,UAAU,UAAU;AAC1D,YAAQ,SAAS;AAAA,EACrB;AACA,QAAM,QAAQ,QAAQ,UAAU,WAAW,MAAM;AACjD,QAAMC,gBAAe,QAAQ;AAC7B,QAAM,YAAYD,QAAO,OAAO,CAAC;AACjC,MAAI,SAAS;AACb,MAAI,UAAU;AACd,QAAM,SAASA,QAAO;AACtB,SAAO,UAAU,QAAQ;AACrB,UAAM,YAAYA,QAAO,OAAO,SAAS;AACzC,QAAI,YAAY,UAAU,WAAW;AACrC,QAAI;AAEJ,QAAI,YAAY,MAAQ,YAAY,KAAM;AACtC,UAAI,aAAa,SAAU,aAAa,SAAU,UAAU,QAAQ;AAEhE,cAAM,QAAQA,QAAO,WAAW,SAAS;AACzC,aAAK,QAAQ,UAAW,OAAQ;AAC5B,wBAAc,YAAY,SAAU,OAAO,QAAQ,QAAS;AAAA,QAChE,OACK;AAGD;AAAA,QACJ;AAAA,MACJ;AACA,cAAQ,OAAO,UAAU,SAAS,EAAE,EAAE,YAAY,IAAI;AAAA,IAC1D,OACK;AACD,UAAI,QAAQ,kBAAkB;AAC1B,YAAI,qBAAqB,KAAK,SAAS,GAAG;AACtC,kBAAQ,OAAO;AAAA,QACnB,OACK;AACD,kBAAQ,OAAO,UAAU,SAAS,EAAE,EAAE,YAAY,IAAI;AAAA,QAC1D;AAAA,MACJ,WACS,iBAAiB,KAAK,SAAS,GAAG;AACvC,gBAAQ,OAAO,UAAU,SAAS,EAAE,EAAE,YAAY,IAAI;AAAA,MAC1D,WACS,aAAa,QACjB,CAACC,kBACI,aAAa,OAAO,SAAS,aAC1B,aAAa,OAAQ,SAAS,cACtCA,iBAAgB,kBAAkB,KAAK,SAAS,GAAI;AACrD,gBAAQ,OAAO;AAAA,MACnB,OACK;AACD,gBAAQ;AAAA,MACZ;AAAA,IACJ;AACA,cAAU;AAAA,EACd;AACA,MAAIA,eAAc;AACd,QAAI,UAAU,KAAK,MAAM,GAAG;AACxB,eAAS,QAAQ,OAAO,MAAM,CAAC;AAAA,IACnC,WACS,KAAK,KAAK,SAAS,GAAG;AAC3B,eAAS,QAAQ,YAAY,MAAM,OAAO,MAAM,CAAC;AAAA,IACrD;AAAA,EACJ;AAIA,WAAS,OAAO,QAAQ,sBAAsB,CAAC,IAAI,IAAI,OAAO;AAC1D,QAAI,MAAM,GAAG,SAAS,GAAG;AAErB,aAAO;AAAA,IACX;AAEA,YAAQ,MAAM,MAAM;AAAA,EACxB,CAAC;AACD,MAAI,CAACA,iBAAgB,QAAQ,MAAM;AAC/B,WAAO,QAAQ,SAAS;AAAA,EAC5B;AACA,SAAO;AACX,GA/Ee;AAiFf,OAAO,UAAU;AAAA,EACb,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,UAAU;AAAA,EACV,QAAQ;AACZ;AACA,IAAO,iBAAQ;;;ACxGf,IAAqB,YAArB,cAAuCC,MAAK;AAAA,EAJ5C,OAI4C;AAAA;AAAA;AAAA,EACxC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AACZ,SAAK,eAAe;AAAA,EACxB;AAAA,EACA,IAAI,MAAM,GAAG;AACT,QAAI,KAAK,cAAc;AACnB,YAAM,UAAU,eAAO,GAAG,EAAE,cAAc,KAAK,CAAC;AAChD,UAAI,YAAY,GAAG;AACf,qBAAa,MAAM,MAAM;AACzB,aAAK,KAAK,QAAQ;AAAA,MACtB,WACS,KAAK,MAAM;AAChB,eAAO,KAAK,KAAK;AAAA,MACrB;AAAA,IACJ;AACA,SAAK,SAAS;AAAA,EAClB;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,gBAAgB;AACZ,WAAO,MAAM,MAAM,cAAc;AAAA,EACrC;AACJ;;;AC3BA,IAAqBC,WAArB,cAAqCC,MAAK;AAAA,EAF1C,OAE0C;AAAA;AAAA;AAAA,EACtC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACLA,IAAqBC,MAArB,cAAgCC,MAAK;AAAA,EAFrC,OAEqC;AAAA;AAAA;AAAA,EACjC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,gBAAgB;AACZ,WAAO,MAAM,MAAM,cAAc;AAAA,EACrC;AACJ;;;ACPA,IAAqB,YAArB,cAAuCC,MAAK;AAAA,EAH5C,OAG4C;AAAA;AAAA;AAAA,EACxC,IAAI,YAAY;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,UAAU,WAAW;AACrB,QAAI,cAAc,QAAQ,cAAc,OAAO,cAAc,KAAK;AAC9D,WAAK,aAAa;AAClB,UAAI,KAAK,MAAM;AACX,eAAO,KAAK,KAAK;AAAA,MACrB;AACA;AAAA,IACJ;AACA,UAAM,UAAU,eAAO,WAAW,EAAE,cAAc,KAAK,CAAC;AACxD,SAAK,aAAa;AAClB,QAAI,YAAY,WAAW;AACvB,mBAAa,MAAM,MAAM;AACzB,WAAK,KAAK,YAAY;AAAA,IAC1B,WACS,KAAK,MAAM;AAChB,aAAO,KAAK,KAAK;AAAA,IACrB;AAAA,EACJ;AAAA,EACA,IAAI,KAAK;AACL,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,GAAG,WAAW;AACd,SAAK,YAAY;AAAA,EACrB;AAAA,EACA,IAAI,kBAAkB;AAClB,QAAI,KAAK,WAAW;AAChB,YAAM,KAAK,KAAK,kBAAkB,WAAW;AAC7C,UAAI,OAAO,MAAM;AACb,eAAO;AAAA,MACX,OACK;AACD,eAAO;AAAA,MACX;AAAA,IACJ,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,cAAc,OAAO;AACjB,QAAI,KAAK,WAAW;AAChB,aAAO,GAAG,KAAK,eAAe,IAAI,KAAK;AAAA,IAC3C,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,gBAAgB;AACZ,WAAO,KAAK,cAAc,MAAM,cAAc,CAAC;AAAA,EACnD;AACJ;;;ACtDA,IAAqB,MAArB,cAAiC,UAAU;AAAA,EAF3C,OAE2C;AAAA;AAAA;AAAA,EACvC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACLA,IAAqBC,UAArB,cAAoCC,MAAK;AAAA,EAFzC,OAEyC;AAAA;AAAA;AAAA,EACrC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACLA,IAAqB,SAArB,cAAoCC,WAAU;AAAA,EAF9C,OAE8C;AAAA;AAAA;AAAA,EAC1C,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,WAAW;AACP,QAAI,SAAS,KAAK,SAAS,MAAM,KAAK,IAAI,MAAM,EAAE,KAAK,GAAG,IAAI,MAAM;AACpE,WAAO;AAAA,MACH,KAAK;AAAA,MACL,KAAK,kBAAkB,OAAO;AAAA,MAC9B;AAAA,MACA,KAAK;AAAA,IACT,EAAE,KAAK,EAAE;AAAA,EACb;AACJ;;;ACZA,IAAM,oBAAoB;AACnB,SAAS,cAAc,OAAO;AACjC,MAAI,kBAAkB;AACtB,MAAI,YAAY;AAChB,MAAI,YAAY;AAChB,QAAM,IAAI,UAAU,MAAM,iBAAiB;AAC3C,MAAI,GAAG;AACH,gBAAY,EAAE,CAAC;AACf,gBAAY,EAAE,CAAC;AAAA,EACnB;AACA,cAAY,MAAM,SAAS;AAC3B,MAAI,cAAc,OAAO;AACrB,sBAAkB;AAAA,EACtB;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAlBgB;AAmBhB,SAAS,+BAA+B,MAAM;AAC1C,MAAI,KAAK,cAAc,QAAW;AAC9B,WAAO;AAAA,EACX;AACA,MAAI,KAAK,UAAU,QAAW;AAC1B,WAAO;AAAA,EACX;AACA,8BAA4B;AAC5B,QAAM,EAAE,WAAW,UAAU,IAAI,cAAc,KAAK,KAAK;AACzD,MAAI,CAAC,KAAK,MAAM;AACZ,SAAK,OAAO,CAAC;AAAA,EACjB;AACA,MAAI,KAAK,KAAK,UAAU,QAAW;AAC/B,SAAK,KAAK,QAAQ,KAAK;AAAA,EAC3B;AACA,OAAK,QAAQ;AACb,OAAK,YAAY;AACjB,SAAO;AACX;AAlBS;AAmBT,IAAqB,YAArB,MAAqB,mBAAkB,UAAU;AAAA,EA3CjD,OA2CiD;AAAA;AAAA;AAAA,EAC7C,OAAO,WAAW;AAAA,EAClB,OAAO,eAAe;AAAA,EACtB,OAAO,eAAe;AAAA,EACtB,YAAY,OAAO,CAAC,GAAG;AACnB,UAAM,+BAA+B,IAAI,CAAC;AAC1C,SAAK,OAAO;AACZ,SAAK,OAAO,KAAK,QAAQ,CAAC;AAC1B,SAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,eAAe,UAAU,CAAC,GAAG;AACzB,UAAM,YAAY,KAAK,oBAAoB,OAAO;AAClD,UAAM,aAAa,qBAAqB,SAAS;AACjD,UAAM,UAAU,eAAO,KAAK,QAAQ,UAAU;AAC9C,WAAO;AAAA,EACX;AAAA,EACA,oBAAoB,SAAS;AACzB,WAAQ,QAAQ,QAAS,KAAK,eAAe,OAAO,IAAI,KAAK,mBAAmB,OAAO;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,OAAO,UAAU,CAAC,GAAG;AAC1B,SAAK,SAAS;AACd,SAAK,aAAa,KAAK,oBAAoB,OAAO;AAClD,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,eAAe,SAAS;AACpB,UAAM,IAAI,KAAK;AACf,UAAM,kBAAkB,EAAE,QAAQ,SAAS,EAAE,EAAE;AAC/C,UAAM,kBAAkB,EAAE,QAAQ,SAAS,EAAE,EAAE;AAC/C,QAAI,kBAAkB,oBAAoB,GAAG;AACzC,YAAM,UAAU,eAAO,GAAG,EAAE,cAAc,KAAK,CAAC;AAChD,UAAI,YAAY,GAAG;AACf,eAAO,WAAU;AAAA,MACrB,OACK;AACD,cAAM,OAAO,KAAK,mBAAmB,OAAO;AAC5C,YAAI,SAAS,WAAU,UAAU;AAE7B,gBAAM,QAAQ,KAAK,aAAa,QAAQ,aAAa,WAAU;AAC/D,gBAAM,OAAO,qBAAqB,KAAK;AACvC,gBAAM,aAAa,eAAO,GAAG,IAAI;AACjC,cAAI,WAAW,SAAS,QAAQ,QAAQ;AACpC,mBAAO;AAAA,UACX;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAAA,IACJ,WACS,oBAAoB,iBAAiB;AAC1C,aAAO,KAAK,mBAAmB,OAAO;AAAA,IAC1C,WACS,kBAAkB,iBAAiB;AACxC,aAAO,WAAU;AAAA,IACrB,OACK;AACD,aAAO,WAAU;AAAA,IACrB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBAAmB,SAAS;AACxB,QAAI,YAAa,QAAQ,yBAA0B,KAAK,YAAY,QAAQ;AAC5E,QAAI,cAAc,QAAW;AACzB,kBAAa,QAAQ,yBAA0B,QAAQ,YAAY,KAAK;AAAA,IAC5E;AACA,QAAI,cAAc,QAAW;AACzB,kBAAY,WAAU;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AAAA,EACA,IAAI,SAAS;AACT,UAAM,KAAK,KAAK;AAChB,WAAO,OAAO,OAAO,OAAO;AAAA,EAChC;AAAA,EACA,IAAI,OAAO,OAAO;AACd,qCAAiC;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,YAAY;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,UAAU,WAAW;AACrB,QAAI,CAAC,KAAK,cAAc;AACpB,WAAK,aAAa;AAClB;AAAA,IACJ;AACA,QAAI,KAAK,eAAe,WAAW;AAC/B,WAAK,aAAa;AAClB,WAAK,cAAc;AAAA,IACvB;AAAA,EACJ;AAAA,EACA,gBAAgB;AACZ,UAAM,WAAW,eAAO,KAAK,QAAQ,qBAAqB,KAAK,SAAS,CAAC;AACzE,QAAI,aAAa,KAAK,QAAQ;AAC1B,UAAI,KAAK,MAAM;AACX,eAAO,KAAK,KAAK;AAAA,MACrB;AAAA,IACJ,OACK;AACD,WAAK,KAAK,QAAQ;AAAA,IACtB;AAAA,EACJ;AAAA,EACA,IAAI,qBAAqB;AACrB,WAAO,KAAK,cAAc,KAAK,KAAK,aAAa,KAAK,SAAS;AAAA,EACnE;AAAA,EACA,IAAI,kBAAkB;AAClB,WAAO,KAAK,cAAc,MAAM;AAAA,EACpC;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,cAAc;AACd,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,YAAY,aAAa;AACzB,QAAI,CAAC,aAAa;AACd,WAAK,eAAe;AAGpB,UAAI,KAAK,SAAS,KAAK,KAAK,oBAAoB,OAAO,KAAK,KAAK,oBAAoB,MAAM;AACvF,aAAK,KAAK,kBAAkB;AAAA,MAChC;AAAA,IACJ;AACA,SAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,IAAI,MAAM,GAAG;AACT,QAAI,KAAK,cAAc;AACnB,YAAM,EAAE,iBAAiB,WAAW,UAAW,IAAI,cAAc,CAAC;AAClE,UAAI,iBAAiB;AACjB,wCAAgC;AAAA,MACpC;AACA,UAAI,cAAc,KAAK,UAAU,cAAc,KAAK,YAAY;AAC5D;AAAA,MACJ;AACA,WAAK,SAAS;AACd,WAAK,aAAa;AAClB,WAAK,cAAc;AAAA,IACvB,OACK;AACD,WAAK,SAAS;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,UAAU,MAAM;AAChB,SAAK,eAAe,aAAa,IAAI;AACrC,SAAK,aAAa;AAAA,EACtB;AAAA,EACA,eAAe,MAAM,OAAO;AACxB,QAAI,KAAK,cAAc;AACnB,YAAM,UAAU,eAAO,OAAO,EAAE,cAAc,KAAK,CAAC;AACpD,UAAI,YAAY,OAAO;AACnB,aAAK,KAAK,IAAI,IAAI;AAAA,MACtB,OACK;AACD,eAAO,KAAK,KAAK,IAAI;AAAA,MACzB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,WAAW,MAAM;AACb,UAAM,aAAa,EAAE,QAAQ,IAAI,OAAO,GAAG;AAC3C,UAAM,SAAS,KAAK,OAAO,IAAI,KAAK,CAAC;AACrC,UAAM,YAAa,KAAK,KAAK,UAAU,KAAK,KAAK,OAAO,IAAI,KAAM,CAAC;AACnE,WAAO,OAAO,OAAO,YAAY,QAAQ,SAAS;AAAA,EACtD;AAAA,EACA,WAAW,MAAM,YAAY,MAAM,SAAS,mBAAmB;AAC3D,UAAM,aAAa,KAAK,WAAW,SAAS;AAC5C,WAAO,OAAO,KAAK,kBAAkB,IAAI,GAAG,UAAU;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,SAAS,MAAM;AACX,QAAI,QAAQ;AACZ,UAAM,kBAAkB,KAAK,WAAW,WAAW;AACnD,aAAS,gBAAgB,OAAO;AAChC,QAAI,SAAS,eAAe,SAAS,MAAM;AACvC,aAAQ,KAAK,YAAa,QAAQ;AAAA,IACtC;AACA,QAAI,SAAS,eAAe;AACxB,aAAO;AAAA,IACX;AACA,aAAS,KAAK,gBAAgB;AAC9B,QAAI,KAAK,WAAW;AAChB,eAAS;AAAA,IACb;AACA,QAAI,SAAS,aAAa;AACtB,aAAO;AAAA,IACX;AACA,aAAS,KAAK,kBAAkB,WAAW,EAAE;AAC7C,aAAS,gBAAgB,MAAM;AAC/B,UAAM,iBAAiB,KAAK,WAAW,UAAU;AACjD,aAAS,eAAe,OAAO;AAC/B,UAAM,WAAW,KAAK,kBAAkB,UAAU;AAClD,QAAI,SAAS,YAAY;AACrB,aAAO,WAAW,QAAQ;AAAA,IAC9B;AACA,aAAS,SAAS;AAClB,aAAS,eAAe,MAAM;AAC9B,UAAM,cAAc,KAAK,WAAW,OAAO;AAC3C,aAAS,YAAY,OAAO;AAC5B,UAAM,QAAQ,KAAK,kBAAkB,OAAO;AAC5C,QAAI,SAAS,SAAS;AAClB,aAAO,QAAQ,QAAQ;AAAA,IAC3B;AACA,aAAS,MAAM;AACf,aAAS,YAAY,MAAM;AAC3B,UAAM,oBAAoB,KAAK,WAAW,aAAa;AACvD,aAAS,kBAAkB,OAAO;AAClC,QAAI,SAAS,eAAe;AACxB,aAAQ,KAAK,cAAe,QAAQ;AAAA,IACxC;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW;AACP,UAAMC,YAAW;AAAA,MACb,KAAK;AAAA,MACL;AAAA,IACJ;AACA,IAAAA,UAAS,KAAK,KAAK,WAAW,sBAAsB,WAAW,CAAC;AAChE,QAAI,KAAK,aAAa,KAAK,SAAS,KAAK,UAAU,KAAK;AACpD,MAAAA,UAAS,KAAK,KAAK,WAAW,UAAU,CAAC;AACzC,MAAAA,UAAS,KAAK,KAAK,WAAW,OAAO,CAAC;AACtC,MAAAA,UAAS,KAAK,KAAK,WAAW,mBAAmB,eAAe,CAAC,WAAW,eAAe;AACvF,YAAI,UAAU,SAAS,KAChB,CAAC,KAAK,UACN,WAAW,OAAO,WAAW,KAC7B,EAAE,KAAK,OAAO,SAAS,KAAK,OAAO,MAAM,QAAQ;AACpD,qBAAW,SAAS;AAAA,QACxB;AACA,eAAO,kBAAkB,WAAW,UAAU;AAAA,MAClD,CAAC,CAAC;AAAA,IACN;AACA,IAAAA,UAAS,KAAK,GAAG;AACjB,IAAAA,UAAS,KAAK,KAAK,aAAa;AAChC,WAAOA,UAAS,KAAK,EAAE;AAAA,EAC3B;AACJ;AACA,IAAM,uBAAuB;AAAA,EACzB,KAAK,EAAE,QAAQ,UAAU,MAAM,KAAK;AAAA,EACpC,KAAK,EAAE,QAAQ,UAAU,MAAM,KAAK;AAAA,EACpC,CAAC,IAAI,GAAG,EAAE,cAAc,KAAK;AACjC;AACA,SAAS,kBAAkB,WAAW,YAAY;AAC9C,SAAO,GAAG,WAAW,MAAM,GAAG,SAAS,GAAG,WAAW,KAAK;AAC9D;AAFS;;;AC/WT,IAAqB,YAArB,cAAuC,UAAU;AAAA,EAFjD,OAEiD;AAAA;AAAA;AAAA,EAC7C,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AACZ,SAAK,QAAQ;AAAA,EACjB;AACJ;;;ACNA,IAAqB,aAArB,cAAwCC,MAAK;AAAA,EAF7C,OAE6C;AAAA;AAAA;AAAA,EACzC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACLA,IAAqB,UAArB,cAAqCC,MAAK;AAAA,EAF1C,OAE0C;AAAA;AAAA;AAAA,EACtC,YAAY,MAAM;AACd,UAAM,IAAI;AACV,SAAK,OAAO;AACZ,SAAK,QAAQ;AAAA,EACjB;AACJ;;;ACRe,SAAR,cAA+BC,OAAM;AACxC,SAAOA,MAAK,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AACpC;AAFwB;;;ACAjB,IAAM,YAAY;AAClB,IAAM,WAAW;AAEjB,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,YAAY;AAClB,IAAM,kBAAkB;AACxB,IAAM,mBAAmB;AACzB,IAAM,aAAa;AACnB,IAAM,cAAc;AACpB,IAAM,SAAS;AACf,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,OAAO;AACb,IAAM,SAAS;AACf,IAAM,OAAO;AACb,IAAM,cAAc;AACpB,IAAM,QAAQ;AACd,IAAM,cAAc;AACpB,IAAM,cAAc;AACpB,IAAM,QAAQ;AACd,IAAM,OAAO;AACb,IAAM,YAAY;AAClB,IAAM,KAAK;AACX,IAAM,OAAO;AACb,IAAM,UAAU;AAChB,IAAM,MAAM;AAEZ,IAAM,MAAM;AAEZ,IAAM,UAAU;AAChB,IAAM,OAAO;AACb,IAAM,aAAa;;;AC/B1B,IAAM,cAAc;AAAA,EAChB,CAAG,GAAG,GAAG;AAAA,EACT,CAAG,OAAO,GAAG;AAAA,EACb,CAAG,EAAE,GAAG;AAAA,EACR,CAAG,IAAI,GAAG;AACd;AACA,IAAM,iBAAiB;AAAA,EACnB,CAAG,KAAK,GAAG;AAAA,EACX,CAAG,GAAG,GAAG;AAAA,EACT,CAAG,OAAO,GAAG;AAAA,EACb,CAAG,EAAE,GAAG;AAAA,EACR,CAAG,IAAI,GAAG;AAAA,EACV,CAAG,SAAS,GAAG;AAAA,EACf,CAAG,QAAQ,GAAG;AAAA,EACd,CAAG,IAAI,GAAG;AAAA,EACV,CAAG,KAAK,GAAG;AAAA,EACX,CAAG,KAAK,GAAG;AAAA,EACX,CAAG,SAAS,GAAG;AAAA,EACf,CAAG,eAAe,GAAG;AAAA,EACrB,CAAG,gBAAgB,GAAG;AAAA,EACtB,CAAG,UAAU,GAAG;AAAA,EAChB,CAAG,WAAW,GAAG;AAAA,EACjB,CAAG,WAAW,GAAG;AAAA,EACjB,CAAG,WAAW,GAAG;AAAA,EACjB,CAAG,IAAI,GAAG;AAAA,EACV,CAAG,IAAI,GAAG;AAAA,EACV,CAAG,KAAK,GAAG;AAAA,EACX,CAAG,WAAW,GAAG;AAAA,EACjB,CAAG,MAAM,GAAG;AAAA,EACZ,CAAG,MAAM,GAAG;AAAA,EACZ,CAAG,KAAK,GAAG;AAAA,EACX,CAAG,KAAK,GAAG;AACf;AACA,IAAM,MAAM,CAAC;AACb,IAAM,WAAW;AACjB,SAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,MAAI,SAAS,WAAW,CAAC,CAAC,IAAI;AAClC;AAMA,SAAS,YAAY,KAAK,OAAO;AAC7B,MAAI,OAAO;AACX,MAAI;AACJ,KAAG;AACC,WAAO,IAAI,WAAW,IAAI;AAC1B,QAAI,eAAe,IAAI,GAAG;AACtB,aAAO,OAAO;AAAA,IAClB,WACS,SAAW,WAAW;AAC3B,aAAO,cAAc,KAAK,IAAI,IAAI;AAAA,IACtC,OACK;AAED;AAAA,IACJ;AAAA,EACJ,SAAS,OAAO,IAAI;AACpB,SAAO,OAAO;AAClB;AAjBS;AAuBT,SAAS,cAAc,KAAK,OAAO;AAC/B,MAAI,OAAO;AACX,MAAI,OAAO,IAAI,WAAW,OAAO,CAAC;AAClC,MAAI,YAAY,IAAI,GAAG;AAAA,EAEvB,WACS,IAAI,IAAI,GAAG;AAChB,QAAI,YAAY;AAEhB,OAAG;AACC;AACA;AACA,aAAO,IAAI,WAAW,OAAO,CAAC;AAAA,IAClC,SAAS,IAAI,IAAI,KAAK,YAAY;AAElC,QAAI,YAAY,KAAK,SAAW,OAAO;AACnC;AAAA,IACJ;AAAA,EACJ,OACK;AAED;AAAA,EACJ;AACA,SAAO;AACX;AAxBS;AAyBF,IAAM,SAAS;AAAA,EAClB,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,UAAU;AAAA,EACV,SAAS;AAAA,EACT,WAAW;AAAA,EACX,SAAS;AACb;AACe,SAAR,SAA0B,OAAO;AACpC,QAAM,SAAS,CAAC;AAChB,MAAI,MAAM,MAAM,IAAI,QAAQ;AAC5B,MAAI,EAAE,OAAO,IAAI;AACjB,MAAI,SAAS;AACb,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,MAAI,MAAM;AACV,MAAI,MAAM,SAAS,WAAW,SAAS,SAAS,WAAW,MAAM,OAAO,MAAM,UAAU,YAAY,OAAO;AAC3G,WAAS,SAAS,MAAM,KAAK;AACzB,QAAI,MAAM,MAAM;AACZ,aAAO;AACP,aAAO,IAAI,SAAS;AAAA,IACxB,OACK;AACD,YAAM,MAAM,MAAM,cAAc,MAAM,MAAM,QAAQ,QAAQ,KAAK;AAAA,IACrE;AAAA,EACJ;AARS;AAST,SAAO,QAAQ,QAAQ;AACnB,WAAO,IAAI,WAAW,KAAK;AAC3B,QAAI,SAAW,SAAS;AACpB,eAAS;AACT,cAAQ;AAAA,IACZ;AACA,YAAQ,MAAM;AAAA,MACV,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AACH,eAAO;AACP,WAAG;AACC,kBAAQ;AACR,iBAAO,IAAI,WAAW,IAAI;AAC1B,cAAI,SAAW,SAAS;AACpB,qBAAS;AACT,oBAAQ;AAAA,UACZ;AAAA,QACJ,SAAS,SAAW,SAChB,SAAW,WACX,SAAW,OACX,SAAW,MACX,SAAW;AACf,oBAAc;AACd,kBAAU;AACV,oBAAY,OAAO,SAAS;AAC5B,cAAM;AACN;AAAA,MACJ,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AACH,eAAO;AACP,WAAG;AACC,kBAAQ;AACR,iBAAO,IAAI,WAAW,IAAI;AAAA,QAC9B,SAAS,SAAW,QAChB,SAAW,eACX,SAAW,SACX,SAAW;AACf,oBAAc;AACd,kBAAU;AACV,oBAAY,QAAQ;AACpB,cAAM;AACN;AAAA;AAAA,MAEJ,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AAAA,MACP,KAAO;AACH,eAAO;AACP,oBAAY;AACZ,kBAAU;AACV,oBAAY,QAAQ;AACpB,cAAM,OAAO;AACb;AAAA,MACJ,KAAO;AAAA,MACP,KAAO;AACH,gBAAQ,SAAW,cAAc,MAAM;AACvC,eAAO;AACP,WAAG;AACC,oBAAU;AACV,iBAAO,IAAI,QAAQ,OAAO,OAAO,CAAC;AAClC,cAAI,SAAS,IAAI;AACb,qBAAS,SAAS,KAAK;AAAA,UAC3B;AACA,sBAAY;AACZ,iBAAO,IAAI,WAAW,YAAY,CAAC,MAAQ,WAAW;AAClD,yBAAa;AACb,sBAAU,CAAC;AAAA,UACf;AAAA,QACJ,SAAS;AACT,oBAAc;AACd,kBAAU;AACV,oBAAY,QAAQ;AACpB,cAAM,OAAO;AACb;AAAA,MACJ;AACI,YAAI,SAAW,SAAS,IAAI,WAAW,QAAQ,CAAC,MAAQ,UAAU;AAC9D,iBAAO,IAAI,QAAQ,MAAM,QAAQ,CAAC,IAAI;AACtC,cAAI,SAAS,GAAG;AACZ,qBAAS,WAAW,IAAI;AAAA,UAC5B;AACA,oBAAU,IAAI,MAAM,OAAO,OAAO,CAAC;AACnC,kBAAQ,QAAQ,MAAM,IAAI;AAC1B,iBAAO,MAAM,SAAS;AACtB,cAAI,OAAO,GAAG;AACV,uBAAW,OAAO;AAClB,yBAAa,OAAO,MAAM,IAAI,EAAE;AAAA,UACpC,OACK;AACD,uBAAW;AACX,yBAAa;AAAA,UACjB;AACA,sBAAc;AACd,iBAAO;AACP,oBAAU;AACV,sBAAY,OAAO;AAAA,QACvB,WACS,SAAW,OAAO;AACvB,iBAAO;AACP,sBAAY;AACZ,oBAAU;AACV,sBAAY,QAAQ;AACpB,gBAAM,OAAO;AAAA,QACjB,OACK;AACD,iBAAO,YAAY,KAAK,KAAK;AAC7B,sBAAc;AACd,oBAAU;AACV,sBAAY,OAAO;AAAA,QACvB;AACA,cAAM,OAAO;AACb;AAAA,IACR;AAEA,WAAO,KAAK;AAAA,MACR;AAAA;AAAA,MACA;AAAA;AAAA,MACA,QAAQ;AAAA;AAAA,MACR;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,IACJ,CAAC;AAED,QAAI,YAAY;AACZ,eAAS;AACT,mBAAa;AAAA,IACjB;AACA,YAAQ;AAAA,EACZ;AACA,SAAO;AACX;AAlKwB;;;ACpFxB,IAAM,oBAAoB;AAAA,EACtB,CAAQ,KAAK,GAAG;AAAA,EAChB,CAAQ,EAAE,GAAG;AAAA,EACb,CAAQ,IAAI,GAAG;AAAA,EACf,CAAQ,OAAO,GAAG;AAAA,EAClB,CAAQ,GAAG,GAAG;AAClB;AACA,IAAM,0BAA0B;AAAA,EAC5B,GAAG;AAAA,EACH,CAAQ,OAAO,GAAG;AACtB;AACA,SAAS,WAAW,OAAO;AACvB,SAAO;AAAA,IACH,MAAM,MAAM,OAAM,UAAU;AAAA,IAC5B,QAAQ,MAAM,OAAM,SAAS;AAAA,EACjC;AACJ;AALS;AAMT,SAAS,SAAS,OAAO;AACrB,SAAO;AAAA,IACH,MAAM,MAAM,OAAM,QAAQ;AAAA,IAC1B,QAAQ,MAAM,OAAM,OAAO;AAAA,EAC/B;AACJ;AALS;AAMT,SAAS,UAAU,WAAW,aAAa,SAAS,WAAW;AAC3D,SAAO;AAAA,IACH,OAAO;AAAA,MACH,MAAM;AAAA,MACN,QAAQ;AAAA,IACZ;AAAA,IACA,KAAK;AAAA,MACD,MAAM;AAAA,MACN,QAAQ;AAAA,IACZ;AAAA,EACJ;AACJ;AAXS;AAYT,SAAS,eAAe,OAAO;AAC3B,SAAO,UAAU,MAAM,OAAM,UAAU,GAAG,MAAM,OAAM,SAAS,GAAG,MAAM,OAAM,QAAQ,GAAG,MAAM,OAAM,OAAO,CAAC;AACjH;AAFS;AAGT,SAAS,mBAAmB,YAAY,UAAU;AAC9C,MAAI,CAAC,YAAY;AACb,WAAO;AAAA,EACX;AACA,SAAO,UAAU,WAAW,OAAM,UAAU,GAAG,WAAW,OAAM,SAAS,GAAG,SAAS,OAAM,QAAQ,GAAG,SAAS,OAAM,OAAO,CAAC;AACjI;AALS;AAMT,SAAS,aAAa,MAAM,MAAM;AAC9B,MAAI,QAAQ,KAAK,IAAI;AACrB,MAAI,OAAO,UAAU,UAAU;AAC3B;AAAA,EACJ;AACA,MAAI,MAAM,QAAQ,IAAI,MAAM,IAAI;AAC5B,iBAAa,MAAM,MAAM;AACzB,SAAK,IAAI,IAAI,MAAM,KAAK;AACxB,QAAI,KAAK,KAAK,IAAI,MAAM,QAAW;AAC/B,WAAK,KAAK,IAAI,IAAI;AAAA,IACtB;AAAA,EACJ;AACA,SAAO;AACX;AAbS;AAcT,SAAS,UAAU,OAAO,MAAM;AAC5B,MAAI,IAAI;AACR,QAAM,UAAU,CAAC;AACjB,UAAQ,IAAI,MAAM,QAAQ,MAAM,IAAI,CAAC,OAAO,IAAI;AAC5C,YAAQ,KAAK,CAAC;AAAA,EAClB;AACA,SAAO;AACX;AAPS;AAQT,SAAS,QAAQ;AACb,QAAMC,QAAO,MAAM,UAAU,OAAO,MAAM,CAAC,GAAG,SAAS;AACvD,SAAOA,MAAK,OAAO,CAAC,MAAM,MAAM,MAAMA,MAAK,QAAQ,IAAI,CAAC;AAC5D;AAHS;AAIT,IAAqBC,UAArB,MAA4B;AAAA,EAvF5B,OAuF4B;AAAA;AAAA;AAAA,EACxB,YAAY,MAAM,UAAU,CAAC,GAAG;AAC5B,SAAK,OAAO;AACZ,SAAK,UAAU,OAAO,OAAO,EAAE,OAAO,OAAO,MAAM,MAAM,GAAG,OAAO;AACnE,SAAK,WAAW;AAChB,SAAK,MAAM,OAAO,KAAK,SAAS,WAAW,KAAK,OAAO,KAAK,KAAK;AACjE,SAAK,SAAS,SAAS;AAAA,MACnB,KAAK,KAAK;AAAA,MACV,OAAO,KAAK,gBAAgB;AAAA,MAC5B,MAAM,KAAK,QAAQ;AAAA,IACvB,CAAC;AACD,QAAI,aAAa,mBAAmB,KAAK,OAAO,CAAC,GAAG,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,CAAC;AACvF,SAAK,OAAO,IAAIC,MAAK,EAAE,QAAQ,WAAW,CAAC;AAC3C,SAAK,KAAK,iBAAiB,KAAK,gBAAgB;AAChD,UAAMC,YAAW,IAAI,SAAS;AAAA,MAC1B,QAAQ,EAAE,OAAO,EAAE,MAAM,GAAG,QAAQ,EAAE,EAAE;AAAA,MACxC,aAAa;AAAA,IACjB,CAAC;AACD,SAAK,KAAK,OAAOA,SAAQ;AACzB,SAAK,UAAUA;AACf,SAAK,KAAK;AAAA,EACd;AAAA,EACA,kBAAkB;AACd,WAAO,CAAC,SAAS,iBAAiB;AAC9B,UAAI,OAAO,KAAK,SAAS,UAAU;AAC/B,eAAO,IAAI,MAAM,OAAO;AAAA,MAC5B;AACA,aAAO,KAAK,KAAK,MAAM,SAAS,YAAY;AAAA,IAChD;AAAA,EACJ;AAAA,EACA,YAAY;AACR,UAAM,OAAO,CAAC;AACd,UAAM,gBAAgB,KAAK;AAC3B,SAAK;AACL,WAAO,KAAK,WAAW,KAAK,OAAO,UAC/B,KAAK,UAAU,OAAM,IAAI,MAAa,aAAa;AACnD,WAAK,KAAK,KAAK,SAAS;AACxB,WAAK;AAAA,IACT;AACA,QAAI,KAAK,UAAU,OAAM,IAAI,MAAa,aAAa;AACnD,aAAO,KAAK,SAAS,0BAA0B,KAAK,UAAU,OAAM,SAAS,CAAC;AAAA,IAClF;AACA,UAAM,MAAM,KAAK;AACjB,UAAM,OAAO;AAAA,MACT,QAAQ,UAAU,cAAc,CAAC,GAAG,cAAc,CAAC,GAAG,KAAK,UAAU,CAAC,GAAG,KAAK,UAAU,CAAC,CAAC;AAAA,MAC1F,aAAa,cAAc,OAAM,SAAS;AAAA,IAC9C;AACA,QAAI,QAAQ,KAAK,CAAC,CAAC,CAAQ,IAAI,EAAE,QAAQ,KAAK,CAAC,EAAE,OAAM,IAAI,CAAC,GAAG;AAC3D,aAAO,KAAK,SAAS,aAAa,KAAK,CAAC,EAAE,OAAM,SAAS,CAAC;AAAA,IAC9D;AACA,QAAI,MAAM;AACV,QAAI,cAAc;AAClB,QAAI,gBAAgB;AACpB,QAAI,YAAY;AAChB,QAAI,4BAA4B;AAChC,WAAO,MAAM,KAAK;AACd,YAAM,QAAQ,KAAK,GAAG;AACtB,YAAM,UAAU,KAAK,QAAQ,KAAK;AAClC,YAAM,OAAO,KAAK,MAAM,CAAC;AACzB,cAAQ,MAAM,OAAM,IAAI,GAAG;AAAA,QACvB,KAAY;AAOR,sCAA4B;AAC5B,cAAI,KAAK,QAAQ,OAAO;AACpB;AAAA,UACJ;AACA,cAAI,WAAW;AACX,yBAAa,MAAM,UAAU,SAAS;AACtC,kBAAM,cAAc,KAAK,OAAO,SAAS,EAAE,SAAS;AACpD,iBAAK,OAAO,SAAS,EAAE,QAAQ,cAAc;AAC7C,kBAAM,kBAAkB,QAAQ,MAAM,QAAQ,UAAU,WAAW,OAAO,KAAK;AAC/E,gBAAI,iBAAiB;AACjB,mBAAK,KAAK,OAAO,SAAS,EAAE,QAAQ,kBAAkB;AAAA,YAC1D;AAAA,UACJ,OACK;AACD,0BAAc,cAAc;AAC5B,4BAAgB,gBAAgB;AAAA,UACpC;AACA;AAAA,QACJ,KAAY;AACR,cAAI,KAAK,OAAM,IAAI,MAAa,QAAQ;AACpC,iBAAK,WAAW;AAChB,wBAAY;AAAA,UAChB,YACU,CAAC,KAAK,aAAc,cAAc,eAAe,CAAC,8BAA+B,MAAM;AAC7F,gBAAI,aAAa;AACb,2BAAa,MAAM,UAAU,WAAW;AACxC,mBAAK,OAAO,UAAU,SAAS;AAC/B,4BAAc;AAAA,YAClB;AACA,gBAAI,eAAe;AACf,2BAAa,MAAM,QAAQ,UAAU,WAAW;AAChD,mBAAK,KAAK,OAAO,UAAU,SAAS;AACpC,8BAAgB;AAAA,YACpB;AACA,iBAAK,aAAa,KAAK,aAAa,MAAM;AAC1C,kBAAM,WAAW,QAAQ,MAAM,QAAQ,WAAW,KAAK;AACvD,gBAAI,UAAU;AACV,mBAAK,KAAK,aAAa;AAAA,YAC3B;AACA,wBAAY;AAAA,UAChB;AACA,sCAA4B;AAC5B;AAAA,QACJ,KAAY;AACR,cAAI,cAAc,SAAS;AACvB,gBAAI,cAAc,QAAQ,MAAM,QAAQ,OAAO;AAC/C,iBAAK,SAAS;AACd,gBAAI,aAAa;AACb,mBAAK,KAAK,QAAQ,cAAc;AAAA,YACpC;AACA;AAAA,UACJ;AAAA;AAAA,QAEJ,KAAY;AACR,cAAI,KAAK,OAAM,IAAI,MAAa,QAAQ;AACpC,iBAAK,WAAW;AAChB,wBAAY;AAAA,UAChB;AACA,sCAA4B;AAC5B;AAAA,QACJ,KAAY;AACR,cAAI,YAAY,OAAO,KAAK,OAAM,IAAI,MAAa,QAAQ;AACvD,iBAAK,WAAW;AAChB,wBAAY;AAAA,UAChB;AACA,cAAI,YAAY,KAAK;AACjB,wCAA4B;AAC5B;AAAA,UACJ;AACA,cAAI,KAAK,OAAM,IAAI,MAAa,QAAQ;AACpC,iBAAK,WAAW;AAChB,wBAAY;AAAA,UAChB,WACS,CAAC,KAAK,aAAa,CAAC,KAAK,WAAW;AACzC,iBAAK,YAAY;AAAA,UACrB;AACA,sCAA4B;AAC5B;AAAA,QACJ,KAAY;AACR,cAAI,QACA,KAAK,QAAQ,IAAI,MAAM,QACtB,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC,EAAE,OAAM,IAAI,MAAa;AAAA,UACvD,CAAC,KAAK,YACN,CAAC,KAAK,WAAW;AACjB,iBAAK,YAAY;AACjB,wBAAY;AAAA,UAChB,WACS,CAAC,KAAK,aAAc,cAAc,eAAe,CAAC,2BAA4B;AACnF,gBAAI,aAAa;AACb,2BAAa,MAAM,UAAU,WAAW;AACxC,mBAAK,OAAO,UAAU,SAAS;AAC/B,4BAAc;AAAA,YAClB;AACA,gBAAI,eAAe;AACf,2BAAa,MAAM,QAAQ,UAAU,WAAW;AAChD,mBAAK,KAAK,OAAO,UAAU,SAAS;AACpC,8BAAgB;AAAA,YACpB;AACA,iBAAK,aAAa,KAAK,aAAa,MAAM;AAC1C,kBAAM,WAAW,QAAQ,MAAM,QAAQ,WAAW,KAAK;AACvD,gBAAI,UAAU;AACV,mBAAK,KAAK,aAAa;AAAA,YAC3B;AACA,wBAAY;AAAA,UAChB,WACU,CAAC,KAAK,SAAS,KAAK,UAAU,MAAQ,cAAc,WAAW,EAAE,6BAA6B,KAAK,YAAa;AACtH,gBAAIC,aAAY,MAAM,OAAO;AAC7B,gBAAI,cAAc,QAAQ,MAAM,QAAQ,OAAO,KAAK;AACpD,gBAAI,WAAW,KAAK,SAAS;AAC7B,iBAAK,QAAQ,WAAWA;AACxB,iBAAK,YAAY;AACjB,gBAAIA,eAAc,WAAW,aAAa;AACtC,2BAAa,MAAM,MAAM;AACzB,mBAAK,KAAK,SAAS,eAAe,YAAY;AAAA,YAClD;AACA,wBAAY;AAAA,UAChB,OACK;AACD,gBAAI,cAAe,YAAY,OAAO,YAAY;AAClD,iBAAK,KAAK,SAAS,KAAK,UAAU,QAAQ,KAAK,aAAa,4BAA4B;AACpF,mBAAK,cAAc;AACnB,kBAAI,CAAC,eAAe,YAAY,KAAK;AACjC,6BAAa,MAAM,MAAM;AACzB,qBAAK,KAAK,kBAAkB;AAAA,cAChC;AACA,0BAAY;AACZ,kBAAI,aAAa;AACb,6BAAa,MAAM,UAAU,aAAa;AAC1C,qBAAK,OAAO,YAAY,SAAS;AACjC,8BAAc;AAAA,cAClB;AACA,kBAAI,eAAe;AACf,6BAAa,MAAM,QAAQ,UAAU,aAAa;AAClD,qBAAK,KAAK,OAAO,YAAY,SAAS;AACtC,gCAAgB;AAAA,cACpB;AAAA,YACJ,WACS,KAAK,SAAS,KAAK,UAAU,IAAI;AACtC,0BAAY;AACZ,mBAAK,SAAS;AACd,kBAAI,KAAK,KAAK,OAAO;AACjB,qBAAK,KAAK,SAAS;AAAA,cACvB;AAAA,YACJ;AAAA,UACJ;AACA,sCAA4B;AAC5B;AAAA,QACJ,KAAY;AACR,cAAI,CAAC,KAAK,aAAa,CAAC,KAAK,UAAU;AACnC,mBAAO,KAAK,MAAM,uEAAuE;AAAA,cACrF,OAAO,MAAM,OAAM,SAAS;AAAA,YAChC,CAAC;AAAA,UACL;AACA,cAAI,EAAE,WAAW,UAAU,IAAI,cAAc,OAAO;AACpD,eAAK,QAAQ;AACb,eAAK,YAAY;AACjB,sBAAY;AACZ,uBAAa,MAAM,MAAM;AACzB,eAAK,KAAK,QAAQ;AAClB,sCAA4B;AAC5B;AAAA,QACJ,KAAY;AACR,cAAI,CAAC,KAAK,WAAW;AACjB,mBAAO,KAAK,SAAS,aAAa,MAAM,OAAM,SAAS,GAAG,OAAO;AAAA,UACrE;AACA,cAAI,KAAK,OAAO;AACZ,mBAAO,KAAK,MAAM,0DAA0D,EAAE,OAAO,MAAM,OAAM,SAAS,EAAE,CAAC;AAAA,UACjH;AACA,eAAK,WAAW,KAAK,WAAW,KAAK,WAAW,UAAU;AAC1D,sBAAY;AACZ,sCAA4B;AAC5B;AAAA,QACJ,KAAY;AACR,cAAI,WAAW;AACX,gBAAI,6BAA8B,QAAQ,KAAK,OAAM,IAAI,MAAa,SAClE,cAAc,eAAe;AAC7B,oBAAM,cAAc,QAAQ,MAAM,UAAU,WAAW,OAAO,KAAK;AACnE,oBAAM,iBAAiB,QAAQ,MAAM,QAAQ,UAAU,WAAW,OAAO,KAAK;AAC9E,2BAAa,MAAM,QAAQ,UAAU,SAAS;AAC9C,mBAAK,KAAK,OAAO,SAAS,EAAE,QAAQ,iBAAiB;AAAA,YACzD,OACK;AACD,oBAAM,YAAY,KAAK,SAAS,KAAK;AACrC,oBAAM,eAAe,QAAQ,MAAM,QAAQ,SAAS,KAAK;AACzD,2BAAa,MAAM,MAAM;AACzB,mBAAK,KAAK,SAAS,IAAI,eAAe;AAAA,YAC1C;AAAA,UACJ,OACK;AACD,4BAAgB,gBAAgB;AAAA,UACpC;AACA;AAAA,QACJ;AACI,iBAAO,KAAK,MAAM,eAAe,OAAO,YAAY,EAAE,OAAO,MAAM,OAAM,SAAS,EAAE,CAAC;AAAA,MAC7F;AACA;AAAA,IACJ;AACA,iBAAa,MAAM,WAAW;AAC9B,iBAAa,MAAM,WAAW;AAC9B,SAAK,QAAQ,IAAI,UAAU,IAAI,CAAC;AAChC,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,gCAAgC,cAAc;AAC1C,QAAI,eAAe,GAAG;AAClB,qBAAe,KAAK,OAAO;AAAA,IAC/B;AACA,QAAI,gBAAgB,KAAK;AACzB,QAAI,QAAQ,CAAC;AACb,QAAIC,SAAQ;AACZ,QAAI,cAAc;AAClB,OAAG;AACC,UAAI,kBAAkB,KAAK,UAAU,OAAM,IAAI,CAAC,GAAG;AAC/C,YAAI,CAAC,KAAK,QAAQ,OAAO;AACrB,UAAAA,UAAS,KAAK,QAAQ;AAAA,QAC1B;AAAA,MACJ,WACS,KAAK,UAAU,OAAM,IAAI,MAAa,SAAS;AACpD,YAAI,SAAS,CAAC;AACd,YAAIA,QAAO;AACP,iBAAO,SAASA;AAChB,UAAAA,SAAQ;AAAA,QACZ;AACA,sBAAc,IAAIC,SAAQ;AAAA,UACtB,OAAO,KAAK,QAAQ;AAAA,UACpB,QAAQ,eAAe,KAAK,SAAS;AAAA,UACrC,aAAa,KAAK,UAAU,OAAM,SAAS;AAAA,UAC3C;AAAA,QACJ,CAAC;AACD,cAAM,KAAK,WAAW;AAAA,MAC1B;AAAA,IACJ,SAAS,EAAE,KAAK,WAAW;AAC3B,QAAID,QAAO;AACP,UAAI,aAAa;AACb,oBAAY,OAAO,QAAQA;AAAA,MAC/B,WACS,CAAC,KAAK,QAAQ,OAAO;AAC1B,YAAI,aAAa,KAAK,OAAO,aAAa;AAC1C,YAAI,YAAY,KAAK,OAAO,KAAK,WAAW,CAAC;AAC7C,cAAM,KAAK,IAAIE,QAAI;AAAA,UACf,OAAO;AAAA,UACP,QAAQ,UAAU,WAAW,OAAM,UAAU,GAAG,WAAW,OAAM,SAAS,GAAG,UAAU,OAAM,QAAQ,GAAG,UAAU,OAAM,OAAO,CAAC;AAAA,UAChI,aAAa,WAAW,OAAM,SAAS;AAAA,UACvC,QAAQ,EAAE,QAAQF,QAAO,OAAO,GAAG;AAAA,QACvC,CAAC,CAAC;AAAA,MACN;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,8BAA8B,OAAO,gBAAgB,OAAO;AACxD,QAAIA,SAAQ;AACZ,QAAI,WAAW;AACf,UAAM,QAAQ,OAAK;AACf,UAAI,cAAc,KAAK,WAAW,EAAE,OAAO,QAAQ,aAAa;AAChE,UAAI,iBAAiB,KAAK,WAAW,EAAE,gBAAgB,aAAa;AACpE,MAAAA,UAAS,cAAc,KAAK,WAAW,EAAE,OAAO,OAAO,iBAAiB,YAAY,WAAW,CAAC;AAChG,kBAAY,cAAc,EAAE,QAAQ,KAAK,WAAW,EAAE,eAAe,iBAAiB,eAAe,WAAW,CAAC;AAAA,IACrH,CAAC;AACD,QAAI,aAAaA,QAAO;AACpB,iBAAW;AAAA,IACf;AACA,QAAI,SAAS,EAAE,OAAAA,QAAO,SAAS;AAC/B,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB,WAAW,KAAK,UAAU;AACxC,WAAO,KAAK,OAAO,WAAW,CAAC,KAAK,KAAK,OAAO,WAAW,CAAC,EAAE,OAAM,IAAI,MAAa,SACjF,KAAK,OAAO,WAAW,CAAC,KAAK,KAAK,OAAO,WAAW,CAAC,EAAE,OAAM,IAAI,MAAa,QAC9E,KAAK,OAAO,WAAW,CAAC,KAAK,KAAK,OAAO,WAAW,CAAC,EAAE,OAAM,IAAI,MAAa;AAAA,EACtF;AAAA,EACA,kBAAkB;AACd,QAAI,KAAK,kBAAkB,GAAG;AAC1B,UAAI,UAAU,KAAK,QAAQ,KAAK,OAAO,KAAK,WAAW,CAAC,CAAC;AACzD,UAAI,OAAO,MAAM,OAAO,EAAE,YAAY;AACtC,UAAI,OAAO,CAAC;AACZ,UAAI,SAAS,SAAS;AAClB,aAAK,QAAQ,IAAI,OAAO;AAAA,MAC5B;AACA,UAAI,OAAO,IAAI,WAAW;AAAA,QACtB,OAAO,IAAI,IAAI;AAAA,QACf,QAAQ,UAAU,KAAK,UAAU,OAAM,UAAU,GAAG,KAAK,UAAU,OAAM,SAAS,GAAG,KAAK,OAAO,KAAK,WAAW,CAAC,EAAE,OAAM,QAAQ,GAAG,KAAK,OAAO,KAAK,WAAW,CAAC,EAAE,OAAM,OAAO,CAAC;AAAA,QAClL,aAAa,KAAK,UAAU,OAAM,SAAS;AAAA,QAC3C;AAAA,MACJ,CAAC;AACD,WAAK,WAAW,KAAK,WAAW;AAChC,aAAO;AAAA,IACX,OACK;AACD,WAAK,WAAW;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,aAAa;AACT,QAAI,KAAK,QAAQ,MAAM,KAAK;AACxB,aAAO,KAAK,UAAU;AAAA,IAC1B;AAEA,QAAI,kBAAkB,KAAK,0BAA0B,KAAK,QAAQ;AAClE,QAAI,kBAAkB,KAAK,KAAK,OAAO,eAAe,EAAE,OAAM,IAAI,MAAa,SAAS,KAAK,OAAO,eAAe,EAAE,OAAM,IAAI,MAAa,kBAAkB;AAC1J,UAAI,QAAQ,KAAK,gCAAgC,eAAe;AAChE,UAAI,MAAM,SAAS,GAAG;AAClB,YAAI,OAAO,KAAK,QAAQ;AACxB,YAAI,MAAM;AACN,cAAI,EAAE,OAAAA,QAAO,SAAS,IAAI,KAAK,8BAA8B,KAAK;AAClE,cAAI,aAAa,QAAW;AACxB,iBAAK,iBAAiB;AAAA,UAC1B;AACA,eAAK,OAAO,SAASA;AAAA,QACzB,OACK;AACD,gBAAM,QAAQ,OAAK,KAAK,QAAQ,CAAC,CAAC;AAAA,QACtC;AAAA,MACJ;AACA;AAAA,IACJ;AACA,QAAI,aAAa,KAAK;AACtB,QAAI,iCAAiC;AACrC,QAAI,kBAAkB,KAAK,UAAU;AACjC,uCAAiC,KAAK,gCAAgC,eAAe;AAAA,IACzF;AACA,QAAI;AACJ,QAAI,KAAK,kBAAkB,GAAG;AAC1B,aAAO,KAAK,gBAAgB;AAAA,IAChC,WACS,KAAK,UAAU,OAAM,IAAI,MAAa,YAAY;AACvD,aAAO,IAAI,WAAW;AAAA,QAClB,OAAO,KAAK,QAAQ;AAAA,QACpB,QAAQ,eAAe,KAAK,SAAS;AAAA,QACrC,aAAa,KAAK,UAAU,OAAM,SAAS;AAAA,MAC/C,CAAC;AACD,WAAK;AAAA,IACT,WACS,kBAAkB,KAAK,UAAU,OAAM,IAAI,CAAC,GAAG;AAAA,IAExD,WACS,CAAC,gCAAgC;AACtC,WAAK,WAAW;AAAA,IACpB;AACA,QAAI,MAAM;AACN,UAAI,gCAAgC;AAChC,YAAI,EAAE,OAAAA,QAAO,SAAS,IAAI,KAAK,8BAA8B,8BAA8B;AAC3F,aAAK,OAAO,SAASA;AACrB,aAAK,iBAAiB;AAAA,MAC1B;AAAA,IACJ,OACK;AAED,UAAI,EAAE,OAAAA,QAAO,SAAS,IAAI,KAAK,8BAA8B,gCAAgC,IAAI;AACjG,UAAI,CAAC,UAAU;AACX,mBAAWA;AAAA,MACf;AACA,UAAI,SAAS,CAAC;AACd,UAAI,OAAO,EAAE,QAAQ,CAAC,EAAE;AACxB,UAAIA,OAAM,SAAS,GAAG,KAAK,SAAS,SAAS,GAAG,GAAG;AAC/C,eAAO,SAASA,OAAM,MAAM,GAAGA,OAAM,SAAS,CAAC;AAC/C,aAAK,OAAO,SAAS,SAAS,MAAM,GAAG,SAAS,SAAS,CAAC;AAAA,MAC9D,WACSA,OAAM,WAAW,GAAG,KAAK,SAAS,WAAW,GAAG,GAAG;AACxD,eAAO,QAAQA,OAAM,MAAM,CAAC;AAC5B,aAAK,OAAO,QAAQ,SAAS,MAAM,CAAC;AAAA,MACxC,OACK;AACD,aAAK,QAAQ;AAAA,MACjB;AACA,aAAO,IAAI,WAAW;AAAA,QAClB,OAAO;AAAA,QACP,QAAQ,mBAAmB,YAAY,KAAK,OAAO,KAAK,WAAW,CAAC,CAAC;AAAA,QACrE,aAAa,WAAW,OAAM,SAAS;AAAA,QACvC;AAAA,QACA;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAI,KAAK,aAAa,KAAK,UAAU,OAAM,IAAI,MAAa,OAAO;AAC/D,WAAK,OAAO,QAAQ,KAAK,cAAc,KAAK,QAAQ,CAAC;AACrD,WAAK;AAAA,IACT;AACA,WAAO,KAAK,QAAQ,IAAI;AAAA,EAC5B;AAAA,EACA,QAAQ;AACJ,QAAI,KAAK,aAAa,KAAK,OAAO,SAAS,GAAG;AAC1C,WAAK,KAAK,gBAAgB;AAC1B,WAAK;AACL;AAAA,IACJ;AACA,SAAK,QAAQ,kBAAkB;AAC/B,UAAMF,YAAW,IAAI,SAAS;AAAA,MAC1B,QAAQ;AAAA,QACJ,OAAO,WAAW,KAAK,OAAO,KAAK,WAAW,CAAC,CAAC;AAAA,MACpD;AAAA,MACA,aAAa,KAAK,OAAO,KAAK,WAAW,CAAC,EAAE,OAAM,SAAS;AAAA,IAC/D,CAAC;AACD,SAAK,QAAQ,OAAO,OAAOA,SAAQ;AACnC,SAAK,UAAUA;AACf,SAAK;AAAA,EACT;AAAA,EACA,UAAU;AACN,UAAM,UAAU,KAAK;AACrB,SAAK,QAAQ,IAAIG,SAAQ;AAAA,MACrB,OAAO,KAAK,QAAQ;AAAA,MACpB,QAAQ,eAAe,OAAO;AAAA,MAC9B,aAAa,QAAQ,OAAM,SAAS;AAAA,IACxC,CAAC,CAAC;AACF,SAAK;AAAA,EACT;AAAA,EACA,MAAM,SAAS,MAAM;AACjB,UAAM,KAAK,KAAK,MAAM,SAAS,IAAI;AAAA,EACvC;AAAA,EACA,mBAAmB;AACf,WAAO,KAAK,MAAM,iDAAiD;AAAA,MAC/D,OAAO,KAAK,UAAU,OAAM,SAAS;AAAA,IACzC,CAAC;AAAA,EACL;AAAA,EACA,qBAAqB;AACjB,WAAO,KAAK,SAAS,uBAAuB,KAAK,UAAU,OAAM,SAAS,CAAC;AAAA,EAC/E;AAAA,EACA,uBAAuB;AACnB,WAAO,KAAK,SAAS,0BAA0B,KAAK,UAAU,OAAM,SAAS,CAAC;AAAA,EAClF;AAAA,EACA,aAAa;AACT,WAAO,KAAK,MAAM,eAAe,KAAK,QAAQ,CAAC,oDAAoD,KAAK,UAAU,OAAM,SAAS,CAAC;AAAA,EACtI;AAAA,EACA,iBAAiB;AACb,WAAO,KAAK,MAAM,mBAAmB,KAAK,UAAU,OAAM,SAAS,CAAC;AAAA,EACxE;AAAA,EACA,YAAY;AACR,UAAM,SAAS,KAAK,aAAa,KAAK,QAAQ,KAAK,SAAS,KAAK;AACjE,QAAI,KAAK,UAAU,OAAM,IAAI,MAAa,MAAM;AAC5C,WAAK;AACL,aAAO,KAAK,KAAK,MAAM;AAAA,IAC3B,WACS,KAAK,UAAU,OAAM,IAAI,MAAa,UAAU;AACrD,WAAK;AACL,aAAO,KAAK,UAAU,MAAM;AAAA,IAChC;AACA,SAAK,eAAe;AAAA,EACxB;AAAA,EACA,UAAU;AACN,QAAI,KAAK,WAAW;AAChB,UAAI,cAAc,KAAK,QAAQ,KAAK,SAAS;AAC7C,UAAI,gBAAgB,KAAK;AACrB,aAAK;AACL;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,UAAU,KAAK;AACrB,SAAK,QAAQ,IAAI,QAAQ;AAAA,MACrB,OAAO,KAAK,QAAQ;AAAA,MACpB,QAAQ,eAAe,OAAO;AAAA,MAC9B,aAAa,QAAQ,OAAM,SAAS;AAAA,IACxC,CAAC,CAAC;AACF,SAAK;AAAA,EACT;AAAA,EACA,cAAc;AACV,QAAI,OAAO,KAAK,QAAQ;AACxB,QAAI,aAAa;AACjB,SAAK;AACL,QAAI,QAAQ,KAAK,SAAe,QAAQ;AACpC,YAAMH,YAAW,IAAI,SAAS;AAAA,QAC1B,QAAQ,EAAE,OAAO,WAAW,KAAK,OAAO,KAAK,QAAQ,CAAC,EAAE;AAAA,QACxD,aAAa,KAAK,OAAO,KAAK,QAAQ,EAAE,OAAM,SAAS;AAAA,MAC3D,CAAC;AACD,YAAM,QAAQ,KAAK;AACnB,WAAK,OAAOA,SAAQ;AACpB,WAAK,UAAUA;AACf,aAAO,KAAK,WAAW,KAAK,OAAO,UAAU,YAAY;AACrD,YAAI,KAAK,UAAU,OAAM,IAAI,MAAa,iBAAiB;AACvD;AAAA,QACJ;AACA,YAAI,KAAK,UAAU,OAAM,IAAI,MAAa,kBAAkB;AACxD;AAAA,QACJ;AACA,YAAI,YAAY;AACZ,eAAK,MAAM;AAAA,QACf,OACK;AACD,eAAK,QAAQ,OAAO,MAAM,SAAS,KAAK,SAAS;AACjD,eAAK,QAAQ,OAAO,OAAO,MAAM,SAAS,KAAK,SAAS;AACxD,eAAK;AAAA,QACT;AAAA,MACJ;AACA,WAAK,UAAU;AAAA,IACnB,OACK;AAGD,UAAI,aAAa,KAAK;AACtB,UAAI,aAAa;AACjB,UAAI;AACJ,aAAO,KAAK,WAAW,KAAK,OAAO,UAAU,YAAY;AACrD,YAAI,KAAK,UAAU,OAAM,IAAI,MAAa,iBAAiB;AACvD;AAAA,QACJ;AACA,YAAI,KAAK,UAAU,OAAM,IAAI,MAAa,kBAAkB;AACxD;AAAA,QACJ;AACA,mBAAW,KAAK;AAChB,sBAAc,KAAK,sBAAsB,KAAK,SAAS;AACvD,aAAK;AAAA,MACT;AACA,UAAI,MAAM;AACN,aAAK,0BAA0B,SAAS,YAAY,UAAU;AAAA,MAClE,OACK;AACD,aAAK,QAAQ,IAAII,QAAI;AAAA,UACjB,OAAO;AAAA,UACP,QAAQ,UAAU,WAAW,OAAM,UAAU,GAAG,WAAW,OAAM,SAAS,GAAG,SAAS,OAAM,QAAQ,GAAG,SAAS,OAAM,OAAO,CAAC;AAAA,UAC9H,aAAa,WAAW,OAAM,SAAS;AAAA,QAC3C,CAAC,CAAC;AAAA,MACN;AAAA,IACJ;AACA,QAAI,YAAY;AACZ,aAAO,KAAK,SAAS,uBAAuB,KAAK,UAAU,OAAM,SAAS,CAAC;AAAA,IAC/E;AAAA,EACJ;AAAA,EACA,SAAS;AACL,QAAI,YAAY;AAChB,QAAI,gBAAgB,KAAK;AACzB,WAAO,KAAK,aAAa,KAAK,UAAU,OAAM,IAAI,MAAa,OAAO;AAClE,mBAAa,KAAK,QAAQ;AAC1B,WAAK;AAAA,IACT;AACA,QAAI,CAAC,KAAK,WAAW;AACjB,aAAO,KAAK,SAAS,CAAC,gBAAgB,gBAAgB,GAAG,KAAK,WAAW,CAAC;AAAA,IAC9E;AACA,QAAI,KAAK,UAAU,OAAM,IAAI,MAAa,MAAM;AAC5C,WAAK,UAAU,OAAO,CAAC,OAAO,WAAW;AACrC,qBAAa;AACb,aAAK,QAAQ,IAAI,OAAO;AAAA,UACpB,OAAO;AAAA,UACP,QAAQ,mBAAmB,eAAe,KAAK,SAAS;AAAA,UACxD,aAAa,cAAc,OAAM,SAAS;AAAA,QAC9C,CAAC,CAAC;AACF,YAAI,SAAS,KACT,KAAK,aACL,KAAK,UAAU,OAAM,IAAI,MAAa,iBAAiB;AACvD,eAAK,MAAM,0BAA0B;AAAA,YACjC,OAAO,KAAK,UAAU,OAAM,SAAS;AAAA,UACzC,CAAC;AAAA,QACL;AAAA,MACJ,CAAC;AAAA,IACL,OACK;AACD,aAAO,KAAK,SAAS,CAAC,gBAAgB,gBAAgB,GAAG,KAAK,UAAU,OAAM,SAAS,CAAC;AAAA,IAC5F;AAAA,EACJ;AAAA,EACA,QAAQ;AACJ,UAAM,UAAU,KAAK,QAAQ;AAE7B,QAAI,KAAK,aAAa,KAClB,KAAK,UAAU,OAAM,IAAI,MAAa,SACtC,KAAK,UAAU,OAAM,IAAI,MAAa,mBACrC,KAAK,QAAQ,MAAM,MAAM,CAAC,SAAS,KAAK,SAAS,SAAS,GAAI;AAC/D,WAAK,SAAS,KAAK,cAAc,OAAO;AACxC,WAAK;AAAA,IACT,WACS,KAAK,aAAc,KAAK,OAAO,SAAS,KAC7C,KAAK,UAAU,OAAM,IAAI,MAAa,SACtC,KAAK,UAAU,OAAM,IAAI,MAAa,kBAAkB;AACxD,WAAK,QAAQ,KAAK,OAAO,QAAQ,KAAK,cAAc,OAAO;AAC3D,WAAK;AAAA,IACT,OACK;AACD,WAAK,WAAW;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,SAAS;AACL,UAAM,UAAU,KAAK;AACrB,SAAK,QAAQ,IAAIA,QAAI;AAAA,MACjB,OAAO,KAAK,QAAQ;AAAA,MACpB,QAAQ,eAAe,OAAO;AAAA,MAC9B,aAAa,QAAQ,OAAM,SAAS;AAAA,IACxC,CAAC,CAAC;AACF,SAAK;AAAA,EACT;AAAA,EACA,UAAU,WAAW;AACjB,UAAM,YAAY,KAAK;AACvB,QAAI,aAAa,KAAK,QAAQ,SAAS,MAAM,KAAK;AAC9C,WAAK;AACL,aAAO,KAAK,UAAU;AAAA,IAC1B;AACA,UAAM,UAAU,KAAK;AACrB,SAAK,QAAQ,IAAI,UAAU;AAAA,MACvB,OAAO,KAAK,QAAQ;AAAA,MACpB,QAAQ,eAAe,OAAO;AAAA,MAC9B,aAAa,QAAQ,OAAM,SAAS;AAAA,IACxC,CAAC,GAAG,SAAS;AACb,SAAK;AAAA,EACT;AAAA,EACA,UAAU,WAAW,eAAe;AAChC,QAAI,YAAY,KAAK;AACrB,QAAIC,QAAO,KAAK,QAAQ;AACxB,WAAO,aACH,CAAC,CAAQ,QAAe,OAAc,QAAe,IAAI,EAAE,QAAQ,UAAU,OAAM,IAAI,CAAC,GAAG;AAC3F,WAAK;AACL,UAAI,UAAU,KAAK,QAAQ;AAC3B,MAAAA,SAAQ;AACR,UAAI,QAAQ,YAAY,IAAI,MAAM,QAAQ,SAAS,GAAG;AAClD,YAAI,OAAO,KAAK;AAChB,YAAI,QAAQ,KAAK,OAAM,IAAI,MAAa,OAAO;AAC3C,UAAAA,SAAQ,KAAK,cAAc,KAAK,QAAQ,IAAI,CAAC;AAC7C,eAAK;AAAA,QACT;AAAA,MACJ;AACA,kBAAY,KAAK;AAAA,IACrB;AACA,UAAM,WAAW,UAAUA,OAAM,GAAG,EAAE,OAAO,OAAK;AAE9C,YAAM,aAAaA,MAAK,IAAI,CAAC,MAAM;AAEnC,YAAM,qBAAqB,cAAc,KAAKA,KAAI;AAClD,aAAO,CAAC,cAAc,CAAC;AAAA,IAC3B,CAAC;AACD,QAAI,QAAQ,UAAUA,OAAM,GAAG,EAAE,OAAO,OAAKA,MAAK,IAAI,CAAC,MAAM,IAAI;AAEjE,UAAM,iBAAiB,UAAUA,OAAM,IAAI;AAC3C,QAAI,eAAe,QAAQ;AACvB,cAAQ,MAAM,OAAO,eAAa,CAAC,CAAC,eAAe,QAAQ,SAAS,CAAC;AAAA,IACzE;AACA,QAAI,UAAU,cAAQ,MAAM,CAAC,GAAG,GAAG,UAAU,GAAG,KAAK,CAAC,CAAC;AACvD,YAAQ,QAAQ,CAAC,KAAK,MAAM;AACxB,YAAM,QAAQ,QAAQ,IAAI,CAAC,KAAKA,MAAK;AACrC,YAAM,QAAQA,MAAK,MAAM,KAAK,KAAK;AACnC,UAAI,MAAM,KAAK,eAAe;AAC1B,eAAO,cAAc,KAAK,MAAM,OAAO,QAAQ,MAAM;AAAA,MACzD;AACA,UAAI;AACJ,YAAM,UAAU,KAAK;AACrB,YAAM,cAAc,QAAQ,OAAM,SAAS,IAAI,QAAQ,CAAC;AACxD,YAAM,SAAS,UAAU,QAAQ,CAAC,GAAG,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,GAAG,QAAQ,CAAC,KAAK,QAAQ,EAAE;AAC3F,UAAI,CAAC,SAAS,QAAQ,GAAG,GAAG;AACxB,YAAI,gBAAgB;AAAA,UAChB,OAAO,MAAM,MAAM,CAAC;AAAA,UACpB;AAAA,UACA;AAAA,QACJ;AACA,eAAO,IAAI,UAAU,aAAa,eAAe,OAAO,CAAC;AAAA,MAC7D,WACS,CAAC,MAAM,QAAQ,GAAG,GAAG;AAC1B,YAAI,SAAS;AAAA,UACT,OAAO,MAAM,MAAM,CAAC;AAAA,UACpB;AAAA,UACA;AAAA,QACJ;AACA,eAAO,IAAIC,IAAG,aAAa,QAAQ,OAAO,CAAC;AAAA,MAC/C,OACK;AACD,YAAI,UAAU;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AACA,qBAAa,SAAS,OAAO;AAC7B,eAAO,IAAI,IAAI,OAAO;AAAA,MAC1B;AACA,WAAK,QAAQ,MAAM,SAAS;AAE5B,kBAAY;AAAA,IAChB,CAAC;AACD,SAAK;AAAA,EACT;AAAA,EACA,KAAK,WAAW;AACZ,UAAM,YAAY,KAAK;AACvB,QAAI,aAAa,KAAK,QAAQ,SAAS,MAAM,KAAK;AAC9C,WAAK;AACL,aAAO,KAAK,UAAU;AAAA,IAC1B;AACA,WAAO,KAAK,UAAU,SAAS;AAAA,EACnC;AAAA,EACA,OAAO;AACH,WAAO,KAAK,WAAW,KAAK,OAAO,QAAQ;AACvC,WAAK,MAAM,IAAI;AAAA,IACnB;AACA,SAAK,QAAQ,kBAAkB;AAC/B,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM,oBAAoB;AACtB,YAAQ,KAAK,UAAU,OAAM,IAAI,GAAG;AAAA,MAChC,KAAY;AACR,aAAK,MAAM;AACX;AAAA,MACJ,KAAY;AACR,aAAK,QAAQ;AACb;AAAA,MACJ,KAAY;AACR,aAAK,YAAY;AACjB;AAAA,MACJ,KAAY;AACR,YAAI,oBAAoB;AACpB,eAAK,mBAAmB;AAAA,QAC5B;AACA;AAAA,MACJ,KAAY;AACR,aAAK,UAAU;AACf;AAAA,MACJ,KAAY;AAAA,MACZ,KAAY;AAAA,MACZ,KAAY;AAAA,MACZ,KAAY;AACR,aAAK,KAAK;AACV;AAAA,MACJ,KAAY;AACR,aAAK,OAAO;AACZ;AAAA,MACJ,KAAY;AACR,aAAK,MAAM;AACX;AAAA,MACJ,KAAY;AACR,aAAK,UAAU;AACf;AAAA,MACJ,KAAY;AACR,aAAK,QAAQ;AACb;AAAA,MACJ,KAAY;AAAA,MACZ,KAAY;AACR,aAAK,WAAW;AAChB;AAAA,MACJ,KAAY;AACR,aAAK,OAAO;AACZ;AAAA;AAAA,MAEJ,KAAY;AACR,aAAK,qBAAqB;AAAA,MAC9B,KAAY;AACR,aAAK,iBAAiB;AAAA,MAC1B;AACI,aAAK,WAAW;AAAA,IACxB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS,aAAa,OAAO,OAAO;AAChC,QAAI,MAAM,QAAQ,WAAW,GAAG;AAC5B,YAAM,OAAO,YAAY,IAAI;AAC7B,oBAAc,GAAG,YAAY,KAAK,IAAI,CAAC,OAAO,IAAI;AAAA,IACtD;AACA,UAAM,KAAK,WAAW,KAAK,YAAY,CAAC,CAAC,IAAI,OAAO;AACpD,QAAI,CAAC,OAAO;AACR,aAAO,KAAK,MAAM,YAAY,EAAE,IAAI,WAAW,KAAK,EAAE,MAAM,CAAC;AAAA,IACjE;AACA,WAAO,KAAK,MAAM,YAAY,EAAE,IAAI,WAAW,YAAY,KAAK,cAAc,EAAE,MAAM,CAAC;AAAA,EAC3F;AAAA,EACA,cAAcJ,QAAO;AACjB,WAAO,KAAK,QAAQ,QAAQ,MAAMA;AAAA,EACtC;AAAA,EACA,cAAcA,QAAO;AACjB,WAAO,KAAK,QAAQ,QAAQ,KAAKA;AAAA,EACrC;AAAA,EACA,WAAWA,QAAO,UAAU;AACxB,QAAI,KAAK,QAAQ,OAAO;AACpB,aAAO,WAAW,MAAM;AAAA,IAC5B,OACK;AACD,aAAOA;AAAA,IACX;AAAA,EACJ;AAAA,EACA,sBAAsB,OAAO;AACzB,UAAM,UAAU,KAAK,QAAQ,KAAK;AAClC,QAAI,MAAM,OAAM,IAAI,MAAa,OAAO;AACpC,aAAO,KAAK,cAAc,OAAO;AAAA,IACrC,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,QAAQ,MAAM,WAAW;AACrB,QAAI,WAAW;AACX,UAAI,OAAO,KAAK,SAAS,GAAG;AACxB,YAAI,CAAC,KAAK,QAAQ,OAAO;AACrB,eAAK,UAAU,KAAK,UAAU,MAAM;AAAA,QACxC;AACA,oBAAY;AAAA,MAChB;AACA,WAAK,YAAY;AACjB,mBAAa,MAAM,WAAW;AAAA,IAClC;AACA,QAAI,KAAK,QAAQ;AACb,WAAK,OAAO,SAAS,KAAK;AAC1B,WAAK,SAAS;AAAA,IAClB;AACA,WAAO,KAAK,QAAQ,OAAO,IAAI;AAAA,EACnC;AAAA,EACA,QAAQ,QAAQ,KAAK,WAAW;AAC5B,WAAO,KAAK,IAAI,MAAM,MAAM,OAAM,SAAS,GAAG,MAAM,OAAM,OAAO,CAAC;AAAA,EACtE;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,OAAO,KAAK,QAAQ;AAAA,EACpC;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,OAAO,KAAK,WAAW,CAAC;AAAA,EACxC;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,OAAO,KAAK,WAAW,CAAC;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,0BAA0B,gBAAgB,KAAK,WAAW,GAAG;AACzD,QAAI,iBAAiB;AACrB,WAAO,iBAAiB,KAAK,OAAO,QAAQ;AACxC,UAAI,wBAAwB,KAAK,OAAO,cAAc,EAAE,OAAM,IAAI,CAAC,GAAG;AAClE;AACA;AAAA,MACJ,OACK;AACD,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;;;ACj9BA,IAAqBK,aAArB,MAA+B;AAAA,EAD/B,OAC+B;AAAA;AAAA;AAAA,EAC3B,YAAY,MAAM,SAAS;AACvB,SAAK,OAAO,QAAQ,gCAAS,OAAO;AAAA,IAAE,GAAlB;AACpB,SAAK,UAAU;AACf,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,sBAAsB,MAAM,UAAU,CAAC,GAAG;AACtC,QAAI,SAAS,OAAO,OAAO,CAAC,GAAG,KAAK,SAAS,OAAO;AACpD,QAAI,OAAO,mBAAmB,OAAO;AACjC,aAAO;AAAA,IACX,OACK;AACD,aAAO,OAAO,SAAS;AAAA,IAC3B;AAAA,EACJ;AAAA,EACA,SAAS,UAAU,CAAC,GAAG;AACnB,QAAI,SAAS,OAAO,OAAO,CAAC,GAAG,KAAK,SAAS,OAAO;AACpD,QAAI,OAAO,aAAa,OAAO;AAC3B,aAAO;AAAA,IACX,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,MAAM,MAAM,UAAU,CAAC,GAAG;AACtB,QAAIC,UAAS,IAAIC,QAAO,MAAM,KAAK,cAAc,OAAO,CAAC;AACzD,WAAOD,QAAO;AAAA,EAClB;AAAA,EACA,cAAc,SAAS;AACnB,WAAO;AAAA,MACH,OAAO,KAAK,SAAS,OAAO;AAAA,IAChC;AAAA,EACJ;AAAA,EACA,KAAK,MAAM,UAAU,CAAC,GAAG;AACrB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,UAAI;AACA,YAAIE,QAAO,KAAK,MAAM,MAAM,OAAO;AACnC,gBAAQ,QAAQ,KAAK,KAAKA,KAAI,CAAC,EAAE,KAAK,eAAa;AAC/C,cAAIC,UAAS;AACb,cAAI,KAAK,sBAAsB,MAAM,OAAO,GAAG;AAC3C,YAAAA,UAASD,MAAK,SAAS;AACvB,iBAAK,WAAWC;AAAA,UACpB;AACA,iBAAO,EAAE,WAAW,MAAAD,OAAM,QAAAC,QAAO;AAAA,QACrC,CAAC,EAAE,KAAK,SAAS,MAAM;AAAA,MAC3B,SACO,GAAG;AACN,eAAO,CAAC;AACR;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,SAAS,MAAM,UAAU,CAAC,GAAG;AACzB,QAAID,QAAO,KAAK,MAAM,MAAM,OAAO;AACnC,QAAI,YAAY,KAAK,KAAKA,KAAI;AAC9B,QAAI,aAAa,OAAO,UAAU,SAAS,YAAY;AACnD,YAAM,IAAI,MAAM,8DAA8D;AAAA,IAClF;AACA,QAAIC,UAAS;AACb,QAAI,QAAQ,kBAAkB,OAAO,SAAS,UAAU;AACpD,MAAAA,UAASD,MAAK,SAAS;AACvB,WAAK,WAAWC;AAAA,IACpB;AACA,WAAO,EAAE,WAAW,MAAAD,OAAM,QAAAC,QAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,MAAM,SAAS;AACf,WAAO,KAAK,KAAK,MAAM,OAAO,EAAE,KAAK,YAAU,OAAO,IAAI;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ,MAAM,SAAS;AACnB,WAAO,KAAK,SAAS,MAAM,OAAO,EAAE;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,MAAM,SAAS;AACrB,WAAO,KAAK,KAAK,MAAM,OAAO,EAAE,KAAK,YAAU,OAAO,SAAS;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,cAAc,MAAM,SAAS;AACzB,WAAO,KAAK,SAAS,MAAM,OAAO,EAAE;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ,MAAM,SAAS;AACnB,WAAO,KAAK,KAAK,MAAM,OAAO,EACzB,KAAK,CAAC,WAAW,OAAO,UAAU,OAAO,KAAK,SAAS,CAAC;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,MAAM,SAAS;AACvB,QAAI,SAAS,KAAK,SAAS,MAAM,OAAO;AACxC,WAAO,OAAO,UAAU,OAAO,KAAK,SAAS;AAAA,EACjD;AACJ;;;AChIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAAC;AAAA,EAAA,eAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACYO,IAAM,YAAY,iCAAQ,IAAI,UAAU,IAAI,GAA1B;AAClB,IAAM,YAAY,iCAAQ,IAAI,UAAU,IAAI,GAA1B;AAClB,IAAMC,cAAa,iCAAQ,IAAI,WAAW,IAAI,GAA3B;AACnB,IAAMC,WAAU,iCAAQ,IAAIC,SAAQ,IAAI,GAAxB;AAChB,IAAM,KAAK,iCAAQ,IAAIC,IAAG,IAAI,GAAnB;AACX,IAAM,UAAU,iCAAQ,IAAI,QAAQ,IAAI,GAAxB;AAChB,IAAM,SAAS,iCAAQ,IAAI,OAAO,IAAI,GAAvB;AACf,IAAM,OAAO,iCAAQ,IAAIC,MAAK,IAAI,GAArB;AACb,IAAM,WAAW,iCAAQ,IAAI,SAAS,IAAI,GAAzB;AACjB,IAAM,SAAS,iCAAQ,IAAIC,QAAI,IAAI,GAApB;AACf,IAAM,MAAM,iCAAQ,IAAI,IAAI,IAAI,GAApB;AACZ,IAAM,YAAY,iCAAQ,IAAI,UAAU,IAAI,GAA1B;;;ACtBzB,IAAM,UAAU;AAAA,EACZ,CAAC,SAAS,GAAG;AAAA,EACb,CAAC,KAAK,GAAG;AAAA,EACT,CAAC,UAAU,GAAG;AAAA,EACd,CAAC,OAAO,GAAG;AAAA,EACX,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,OAAO,GAAG;AAAA,EACX,CAAC,MAAM,GAAG;AAAA,EACV,CAAC,IAAI,GAAG;AAAA,EACR,CAAC,QAAQ,GAAG;AAAA,EACZ,CAAC,MAAM,GAAG;AAAA,EACV,CAAC,GAAG,GAAG;AAAA,EACP,CAAC,SAAS,GAAG;AACjB;AACO,SAAS,OAAO,MAAM;AACzB,SAAQ,OAAO,SAAS,YAAY,QAAQ,KAAK,IAAI;AACzD;AAFgB;AAGhB,SAAS,WAAW,MAAM,MAAM;AAC5B,SAAO,OAAO,IAAI,KAAK,KAAK,SAAS;AACzC;AAFS;AAGF,IAAM,cAAc,WAAW,KAAK,MAAM,SAAS;AACnD,IAAM,cAAc,WAAW,KAAK,MAAM,KAAK;AAC/C,IAAM,eAAe,WAAW,KAAK,MAAM,UAAU;AACrD,IAAM,YAAY,WAAW,KAAK,MAAM,OAAO;AAC/C,IAAM,eAAe,WAAW,KAAK,MAAM,EAAE;AAC7C,IAAM,YAAY,WAAW,KAAK,MAAM,OAAO;AAC/C,IAAM,WAAW,WAAW,KAAK,MAAM,MAAM;AAC7C,IAAM,SAAS,WAAW,KAAK,MAAM,IAAI;AACzC,IAAM,aAAa,WAAW,KAAK,MAAM,QAAQ;AACjD,IAAM,WAAW,WAAW,KAAK,MAAM,MAAM;AAC7C,IAAM,QAAQ,WAAW,KAAK,MAAM,GAAG;AACvC,IAAM,cAAc,WAAW,KAAK,MAAM,SAAS;AACnD,SAAS,gBAAgB,MAAM;AAClC,SAAO,SAAS,IAAI,KACb,KAAK,UACJ,KAAK,MAAM,WAAW,IAAI,KACvB,KAAK,MAAM,YAAY,MAAM,aAC7B,KAAK,MAAM,YAAY,MAAM,YAC7B,KAAK,MAAM,YAAY,MAAM,mBAC7B,KAAK,MAAM,YAAY,MAAM;AAC5C;AARgB;AAST,SAAS,cAAc,MAAM;AAChC,SAAO,SAAS,IAAI,KAAK,CAAC,gBAAgB,IAAI;AAClD;AAFgB;AAGT,SAAS,YAAY,MAAM;AAC9B,SAAO,CAAC,EAAE,OAAO,IAAI,KAAK,KAAK;AACnC;AAFgB;AAGT,SAAS,YAAY,MAAM;AAC9B,SAAO,YAAY,IAAI,KAAK,MAAM,IAAI;AAC1C;AAFgB;;;AC9ChB,IAAM,SAAS,sCAAa,IAAIC,WAAU,SAAS,GAApC;AACf,OAAO,OAAO,QAAQ,iBAAS;AAC/B,IAAO,kCAAQ;;;ACFf,SAAS,UAAU,MAAmB,MAAqC;AACzE,MAAI,MAAM;AACR,SAAK,QAAQ,KAAK,KAAK,IAAI;AAAA,EAC7B;AACF;AAJS;AAST,IAAM,sBAAN,MAAM,qBAAoB;AAAA,EAQxB,YAAY,IAAqB;AAPjC,SAAQ,eAAe,oBAAI,IAAY;AACvC,SAAQ,YAAY,oBAAI,IAAY;AACpC,SAAQ,aAAa,oBAAI,IAAY;AACrC,SAAQ,UAAU,oBAAI,IAAY;AAClC,SAAQ,MAAM,oBAAI,IAAY;AAC9B,SAAQ,OAAO,oBAAI,IAAY;AAG7B,SAAK,MAAM,EAAE;AAAA,EACf;AAAA,EArBF,OAW0B;AAAA;AAAA;AAAA,EAYxB,MAAM,MAAmD;AACvD,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,gBAAU,KAAK,cAAc,IAAI;AAAA,IACnC,WAAW,gBAAgB,sBAAqB;AAC9C,gBAAU,KAAK,cAAc,KAAK,YAAY;AAC9C,gBAAU,KAAK,WAAW,KAAK,SAAS;AACxC,gBAAU,KAAK,YAAY,KAAK,UAAU;AAC1C,gBAAU,KAAK,SAAS,KAAK,OAAO;AACpC,gBAAU,KAAK,KAAK,KAAK,GAAG;AAC5B,gBAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAChC,OAAO;AAEL,gBAAU,KAAK,cAAc,KAAK,YAAY;AAC9C,UAAI,KAAK,YAAY;AACnB,kBAAU,KAAK,WAAW,KAAK,WAAW,KAAK;AAC/C,kBAAU,KAAK,YAAY,KAAK,WAAW,MAAM;AAAA,MACnD;AACA,gBAAU,KAAK,SAAS,KAAK,OAAO;AACpC,gBAAU,KAAK,KAAK,KAAK,GAAG;AAC5B,gBAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAChC;AACA,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,MAAuB;AACjC,WAAO,KAAK,UAAU,IAAI,IAAI,KAAK,KAAK,aAAa,IAAI,IAAI;AAAA,EAC/D;AAAA,EAEQ,cAAc,WAAgD;AACpE,eAAW,OAAO,KAAK,YAAY;AACjC,UAAI,UAAU,GAAG,EAAG,QAAO;AAAA,IAC7B;AACA,eAAW,OAAO,KAAK,cAAc;AACnC,UAAI,UAAU,GAAG,EAAG,QAAO;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAAA,EAEA,cAAc,QAAyB;AACrC,WAAO,KAAK,cAAc,CAAC,UAAU,MAAM,WAAW,MAAM,CAAC;AAAA,EAC/D;AAAA,EAEA,cAAc,QAAyB;AACrC,WAAO,KAAK,cAAc,CAAC,UAAU,MAAM,SAAS,MAAM,CAAC;AAAA,EAC7D;AAAA,EAEA,cAAc,QAAyB;AACrC,UAAM,aAAa,OAAO,KAAK,EAAE,MAAM,GAAG;AAC1C,WAAO,WAAW;AAAA,MAAM,CAACC,UACvB,KAAK,cAAc,CAAC,UAAU,MAAM,SAASA,KAAI,CAAC;AAAA,IACpD;AAAA,EACF;AAAA,EAEA,aAAa,OAAwB;AACnC,WAAO,KAAK,WAAW,IAAI,KAAK,KAAK,KAAK,aAAa,IAAI,KAAK;AAAA,EAClE;AAAA,EAEA,SAAS,MAAuB;AAC9B,WAAO,KAAK,QAAQ,IAAI,IAAI,KAAK,KAAK,aAAa,IAAI,IAAI;AAAA,EAC7D;AAAA,EAEA,MAAMC,KAAqB;AACzB,WAAO,KAAK,IAAI,IAAIA,GAAE,KAAK,KAAK,aAAa,IAAIA,GAAE;AAAA,EACrD;AAAA,EAEA,OAAOC,MAAsB;AAC3B,WAAO,KAAK,KAAK,IAAIA,IAAG,KAAK,KAAK,aAAa,IAAIA,IAAG;AAAA,EACxD;AACF;AAEA,IAAO,8BAAQ;;;ACxFR,IAAM,iBAA0B;AAAA,EACrC,KAAK,CAAC;AAAA,EACN,SAAS,CAAC;AAAA,EACV,kBAAkB,wBAAC,YACjB,QAAQ,MAAM,iBAAiB,KAAK,CAAC,GADrB;AAAA,EAElB,YAAY,CAAC;AAAA,EACb,UAAU;AAAA,EACV,WAAW;AAAA,EACX,UAAU;AAAA,EACV,aAAa;AAAA,EACb,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,UAAU;AAAA,IACR,UAAU,CAAC;AAAA,IACX,MAAM,CAAC;AAAA,IACP,QAAQ,CAAC;AAAA,IACT,WAAW,CAAC;AAAA,IACZ,WAAW,CAAC;AAAA,EACd;AAAA,EACA,WAAW,CAAC;AAAA,EACZ,qBAAqB,CAAC;AAAA,EACtB,mBAAmB,CAAC;AACtB;;;ACvBO,IAAM,eAAN,MAAmB;AAAA,EAKxB,YAAY,aAAkB;AAJ9B,SAAO,QAAwB,CAAC;AAEhC,SAAO,SAAS;AAGd,SAAK,QAAQ;AAAA,EACf;AAAA,EAZF,OAK0B;AAAA;AAAA;AAQ1B;AAKO,IAAM,qBAAN,MAAyB;AAAA,EAAzB;AACL,SAAO,QAAqC,oBAAI,IAAI;AACpD,SAAO,gBAA6B,oBAAI,IAAI;AAC5C,SAAO,WAA8B,CAAC;AAAA;AAAA,EArBxC,OAkBgC;AAAA;AAAA;AAAA,EAK9B,YAAY,aAAwB;AAClC,UAAM,EAAE,KAAK,IAAI;AACjB,QAAI,CAAC,KAAK,MAAM,IAAI,IAAI,GAAG;AACzB,YAAM,OAAO,IAAI,aAAa,WAAW;AACzC,WAAK,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC;AAAA,IAC7B,OAAO;AACL,YAAM,OAAO,IAAI,aAAa,WAAW;AACzC,YAAM,gBAAgB,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AAC/C,WAAK,MAAM,IAAI,MAAM,CAAC,GAAG,eAAe,IAAI,CAAC;AAAA,IAC/C;AAAA,EACF;AAAA,EAEA,iBACE,aACA,kBACM;AACN,UAAM,EAAE,KAAK,IAAI;AACjB,UAAM,QAAQ,KAAK,MAAM,IAAI,IAAI;AACjC,eAAW,iBAAiB,kBAAkB;AAE5C,YAAM,eAAe,cAAc,CAAC;AACpC,UAAI,KAAK,MAAM,IAAI,YAAY,GAAG;AAChC,cAAM,oBAAoB,KAAK,MAAM,IAAI,YAAY;AACrD,eAAO,QAAQ,CAAC,SAAS;AACvB,6BAAmB;AAAA,YAAQ,CAAC,qBAC1B,KAAK,MAAM,KAAK,gBAAgB;AAAA,UAClC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,6BACE,kBACM;AACN,eAAW,iBAAiB,kBAAkB;AAE5C,YAAM,eAAe,cAAc,CAAC;AACpC,WAAK,cAAc,IAAI,YAAY;AAAA,IACrC;AAAA,EACF;AAAA,EAEA,UAAU,cAA4B;AACpC,UAAM,QAAQ,KAAK,MAAM,IAAI,YAAY;AACzC,QAAI,OAAO;AACT,YAAM,QAAQ,CAAC,GAAG,KAAK;AACvB,aAAO,MAAM,WAAW,GAAG;AACzB,cAAM,cAAc,MAAM,IAAI;AAC9B,YAAI,eAAe,CAAC,YAAY,QAAQ;AACtC,sBAAY,SAAS;AACrB,gBAAM,KAAK,GAAG,YAAY,KAAK;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,eAAqB;AAEnB,eAAW,QAAQ,KAAK,eAAe;AACrC,YAAM,YAAY,KAAK,MAAM,IAAI,IAAI;AACrC,UAAI,WAAW;AACb,mBAAW,YAAY,WAAW;AAChC,gBAAM,oCACJ,SAAS,MAAM,MAAM,SAAS,iBAAiB;AAEjD,qBAAW,SAAS,mCAAmC;AACrD,gBAAI,CAAC,KAAK,cAAc,IAAI,MAAM,CAAC,CAAC,GAAG;AACrC,mBAAK,cAAc,IAAI,MAAM,CAAC,CAAC;AAAA,YACjC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,eAAW,QAAQ,KAAK,eAAe;AACrC,WAAK,UAAU,IAAI;AAAA,IACrB;AAEA,eAAW,CAAC,MAAM,YAAY,KAAK,KAAK,OAAO;AAC7C,iBAAW,eAAe,cAAc;AACtC,YAAI,CAAC,YAAY,UAAU,CAAC,KAAK,sBAAsB,IAAI,GAAG;AAC5D,sBAAY,MAAM,OAAO;AAAA,QAC3B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,sBAAsB,UAA2B;AAC/C,WAAO,KAAK,SAAS,KAAK,CAAC,iBAAiB;AAC1C,aAAO,OAAO,iBAAiB,WAC3B,iBAAiB,WACjB,aAAa,KAAK,QAAQ;AAAA,IAChC,CAAC;AAAA,EACH;AACF;;;ACnFA,IAAM,eAAe,CAAC,KAAK,SAAS,UAAU,SAAS;AAChD,IAAM,4BAA4B;AAClC,IAAM,yBAAyB;AAC/B,IAAM,0BAA0B;AAChC,IAAM,wBAAwB;AAC9B,IAAM,kBAAkB;AACxB,IAAM,4BAA4B;AAAA;AAGlC,SAAS,oBACd,sBAA2C,CAAC,GACjB;AAC3B,MAAI,MAAM,QAAQ,mBAAmB,GAAG;AACtC,WAAO;AAAA,MACL,GAAG,eAAe;AAAA,MAClB,UAAU;AAAA,IACZ;AAAA,EACF;AACA,SAAO;AAAA,IACL,GAAG,eAAe;AAAA,IAClB,GAAG;AAAA,EACL;AACF;AAbgB;AAAA;AAgBhB,eAAe,iBACb,SACA,WAC8B;AAC9B,SAAO,IAAI,4BAAoB,MAAM,UAAU,OAAO,CAAC;AACzD;AALe;AAAA;AAQf,SAAS,mBAAmB,MAAW,MAA2B;AAChE,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,aAAO,KAAK,KAAK,SAAS,sBAAsB;AAAA,IAClD,KAAK;AACH,aAAO,KAAK,KAAK,SAAS,uBAAuB;AAAA,IACnD,KAAK;AACH,aAAO,KAAK,KAAK,SAAS,qBAAqB;AAAA,EACnD;AACF;AATS;AAAA;AAYT,SAAS,YAAY,MAAqB;AACxC,MACG,8BAAc,IAAI,KAAK,CAAC,KAAK,YAC7B,MAAM,SAAS,CAAC,KAAK,MAAM,UAC3B,gCAAgB,IAAI,MACjB,CAAC,KAAK,SAAS,CAAC,KAAK,UACpB,CAAC,KAAK,UAAU,KAAK,SAAS,CAAC,KAAK,MAAM,SAC/C;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAXS;AAAA;AAcT,SAAS,oBAAoB,MAAoB;AAC/C,MAAI,QAAQ;AACZ,OAAK,aAAa,CAAC,SAAS;AAC1B,QACE,QACA,KAAK,SAAS,aACd,KAAK,KAAK,SAAS,yBAAyB,GAC5C;AACA,cAAQ;AACR,WAAK,OAAO;AAAA,IACd;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAbS;AAAA;AAgBF,SAAS,2BACX,YACkB;AACrB,QAAM,SAAS,IAAI,4BAAoB,CAAC,CAAC;AACzC,aAAW,QAAQ,OAAO,OAAO,MAAM;AACvC,SAAO;AACT;AANgB;AAAA;AAQhB,SAAS,YAAYC,MAAqB;AACxC,SAAOA,KAAI,QAAQ,oBAAoB,EAAE;AAC3C;AAFS;AAAA;AAKT,SAAS,iBACP,eACA,WACS;AACT,MAAI,CAAC,UAAU,YAAY,cAAc,SAAS,GAAG;AACnD,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,cAAc,UAAU,aAAa;AAC9C,WAAO;AAAA,EACT;AAEA,UAAQ,cAAc,UAAU;AAAA,IAC9B,KAAK;AACH,aAAO,UAAU,cAAc,cAAc,KAAK;AAAA,IACpD,KAAK;AAAA,IACL,KAAK;AACH,aAAO,UAAU,cAAc,cAAc,KAAK;AAAA,IACpD,KAAK;AACH,aAAO,UAAU,aAAa,cAAc,KAAK;AAAA,IACnD,KAAK;AAAA,IACL,KAAK;AACH,aAAO,UAAU,cAAc,cAAc,KAAK;AAAA,IACpD;AACE,aAAO;AAAA,EACX;AACF;AA1BS;AAAA;AA6BT,SAAS,aACP,WACA,WACS;AACT,SAAO,UAAU,SAAS,UAAU,KAAK;AAC3C;AALS;AAAA;AAQT,SAAS,kBACP,gBACA,WACS;AACT,SAAO,UAAU,MAAM,eAAe,KAAK;AAC7C;AALS;AAAA;AAQT,SAAS,WACP,SACA,WACS;AACT,SAAO,UAAU,OAAO,QAAQ,KAAK;AACvC;AALS;AAAA;AAQT,SAAS,gBAAgBC,WAAwC;AAC/D,SACGA,UAAS,UACRA,UAAS,OAAO,SAAS,YACzBA,UAAS,OAAO,MAAM,WAAW,GAAG,KACtC;AAEJ;AAPS;AAAA;AAUT,SAAS,yBAAyBA,WAAwC;AACxE,SACGA,UAAS,UACRA,UAAS,OAAO,SAAS,aACxBA,UAAS,OAAO,UAAU,YACzBA,UAAS,OAAO,UAAU,UAC9B;AAEJ;AARS;AAAA;AAWT,SAAS,yBAAyBA,WAAwC;AACxE,MAAI,SAAS;AACb,MACEA,UAAS,SAAS,cAClBA,UAAS,QAAQ,SAAS,UAC1BA,UAAS,MAAM,WAAW,GAC1B;AACA,IAAAA,UAAS,KAAK,CAAC,SAAS;AACtB,UACE,KAAK,SAAS,aACb,KAAK,UAAU,YACd,KAAK,UAAU,SACf,KAAK,UAAU,UACf,KAAK,UAAU,SACjB;AACA,iBAAS;AAAA,MACX;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO;AACT;AApBS;AAAA;AAuBT,SAAS,gBAAgB,MAAyB;AAChD,SAAO,MAAM,SAAS;AACxB;AAFS;AAAA;AAKT,SAAS,cAAc,MAAyB;AAC9C,SAAO,MAAM,SAAS;AACxB;AAFS;AAAA;AAKT,SAAS,iBACP,MACc;AACd,SAAO,MAAM,SAAS;AACxB;AAJS;AAoBT,IAAM,WAAN,MAAe;AAAA,EAAf;AACE,SAAQ,SAAS;AACjB,SAAQ,UAAmB;AAAA,MACzB,UAAU,CAAC;AAAA,MACX,WAAW,CAAC;AAAA,IACd;AAEA,SAAQ,iBAA8B,oBAAI,IAAI;AAC9C,SAAQ,gBAA6B,oBAAI,IAAI;AAC7C,SAAO,mBAAgC,oBAAI,IAAI;AAC/C,SAAO,eAAsB,CAAC;AAC9B,SAAO,qBAAyC,IAAI,mBAAmB;AAEvE,SAAO,UAAmB;AAAA;AAAA,EAtQ5B,OAyPe;AAAA;AAAA;AAAA,EAeL,wBAAwB,aAAyB;AACvD,UAAM,EAAE,MAAM,MAAM,IAAI;AAGxB,QAAI,KAAK,QAAQ,WAAW;AAC1B,YAAM,oCACJ,MAAM,SAAS,iBAAiB;AAClC,UAAI,KAAK,WAAW,IAAI,GAAG;AACzB,aAAK,mBAAmB,YAAY,WAAW;AAC/C,aAAK,mBAAmB;AAAA,UACtB;AAAA,UACA;AAAA,QACF;AAAA,MACF,OAAO;AACL,aAAK,mBAAmB;AAAA,UACtB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI,KAAK,QAAQ,WAAW;AAC1B,UAAI,SAAS,eAAe,SAAS,kBAAkB;AACrD,mBAAWC,SAAQ,MAAM,MAAM,QAAQ,GAAG;AACxC,eAAK,eAAe,IAAIA,KAAI;AAAA,QAC9B;AACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,KAAK,QAAQ,UAAU;AACzB,UAAI,SAAS,eAAe;AAC1B,mBAAW,YAAY,MAAM,MAAM,GAAG,GAAG;AACvC,gBAAM,kBAAkB,4BAAY,SAAS,KAAK,CAAC;AACnD,eAAK,cAAc,IAAI,eAAe;AAAA,QACxC;AAAA,MACF;AACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,iBACN,UACA,YACmB;AACnB,UAAM,eAAe,WAAW;AAAA,MAAK,CAAC,cACpC,UAAU,WAAW,KAAK,CAAC,QAAQ,SAAS,SAAS,GAAG,CAAC;AAAA,IAC3D;AAEA,WAAO,OAAO,iBAAiB,cAC3B,KAAK,QAAQ,mBACb,aAAa;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,2BACX,SACA,YAC8B;AAC9B,UAAM,YAAY,IAAI,4BAAoB,CAAC,CAAC;AAC5C,eAAW,EAAE,KAAK,UAAU,KAAK,SAAS;AACxC,YAAM,YAAY,KAAK,iBAAiB,IAAI,SAAS,IAAI,UAAU;AACnE,YAAM,qBAAqB,MAAM,iCAAiB,KAAK,SAAS;AAChE,gBAAU,MAAM,kBAAkB;AAAA,IACpC;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,eAAe,MAAgB;AAErC,QAAI,KAAK,QAAQ,aAAa,KAAK,KAAK,SAAS,WAAW,GAAG;AAC7D,WAAK,QAAQ,UAAU,KAAK,IAAI;AAChC;AAAA,IACF;AAEA,QAAI,KAAK,QAAQ,YAAY,KAAK,SAAS,eAAe,KAAK,OAAO;AACpE,iBAAW,aAAa,KAAK,OAAO;AAClC,YAAI,UAAU,SAAS,UAAU,UAAU,SAAS,eAAe;AACjE,eAAK,QAAQ,SAAS,KAAK;AAAA,YACzB,MAAM,4BAAY,UAAU,KAAK;AAAA,YACjC;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,aACN,MACA,WACM;AAEN,QAAI,KAAK,QAAQ;AACf;AAAA,IACF;AAGA,UAAM,aAAa,KAAK,KAAK;AAC7B,QACE,iCAAiB,UAAU,KAC3B,mCAAmB,YAAY,MAAM,GACrC;AACA,iBAAW,OAAO;AAClB;AAAA,IACF;AAGA,QACE,KAAK,UACL,gCAAgB,KAAK,MAAM,KAC3B,KAAK,OAAO,KAAK,SAAS,WAAW,GACrC;AACA;AAAA,IACF;AAGA,QAAI,CAAC,8BAAc,IAAI,GAAG;AACxB;AAAA,IACF;AAGA,QAAI,oCAAoB,IAAI,GAAG;AAC7B;AAAA,IACF;AAEA,UAAM,2BAAqC,CAAC;AAO5C,SAAK,WAAW,gCAAe,CAAC,oBAAoB;AAClD,sBAAgB,KAAK,CAACD,cAAa;AACjC,YAAIA,UAAS,SAAS,YAAY;AAChC;AAAA,QACF;AACA,cAAM,eAAe,KAAK,mBAAmBA,WAAU,SAAS;AAEhE,YAAI,CAAC,cAAc;AACjB,cAAI,KAAK,QAAQ,UAAU;AACzB,iBAAK,iBAAiB,IAAIA,UAAS,SAAS,CAAC;AAAA,UAC/C;AACA,cAAI,KAAK,QAAQ,aAAa;AAC5B,qCAAyB,KAAKA,UAAS,SAAS,CAAC;AAAA,UACnD;AACA,UAAAA,UAAS,OAAO;AAAA,QAClB;AAAA,MACF,CAAC;AAGD,sBAAgB,KAAK,CAACA,cAAa;AACjC,YAAIA,UAAS,SAAS,YAAY;AAChC;AAAA,QACF;AAEA,YAAIA,UAAS,SAAS,KAAK,iBAAiB,KAAKA,UAAS,SAAS,CAAC,GAAG;AACrE,UAAAA,UAAS,KAAK,CAACE,UAAS;AACtB,gBAAIA,MAAK,SAAS,SAAU;AAC5B,gBAAIA,MAAK,UAAU,YAAYA,MAAK,UAAU,MAAO;AACrD,gBAAIA,MAAK,MAAM,WAAW,GAAG;AAC3B,cAAAF,UAAS,OAAO;AAAA,YAClB;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH,CAAC,EAAE,YAAY,KAAK,QAAQ;AAG5B,QAAI,KAAK,YAAY,OAAO,KAAK,UAAU,aAAa;AACtD,iBAAW,aAAa,KAAK,OAAO;AAClC,YAAI,UAAU,SAAS,OAAQ;AAC/B,aAAK,wBAAwB,SAAS;AAAA,MACxC;AAAA,IACF;AAGA,UAAM,SAAS,KAAK;AACpB,QAAI,CAAC,KAAK,UAAU;AAClB,WAAK,OAAO;AAAA,IACd;AACA,QAAI,4BAAY,MAAM,EAAG,SAAQ,OAAO;AAGxC,QAAI,KAAK,QAAQ,aAAa;AAC5B,UAAI,yBAAyB,SAAS,GAAG;AACvC,cAAM,QAAQ,KAAK,MAAM;AACzB,cAAM,cAAc,QAAQ,MAAM,EAAE,UAAU,EAAE,OAAO,KAAK;AAC5D,cAAM,YAAY;AAClB,cAAM,iBAAiB,cAAc,cAAc;AACnD,aAAK,aAAa,KAAK,cAAc;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,aACX,YACA,WACwB;AACxB,UAAM,UAAU,CAAC;AAGjB,UAAM,mBAA2C,CAAC;AAClD,eAAW,UAAU,YAAY;AAC/B,UAAI,OAAO,WAAW,UAAU;AAC9B,cAAM,IAAI,MAAM,4CAA4C;AAAA,MAC9D,OAAO;AACL,yBAAiB,KAAK,MAAM;AAAA,MAC9B;AAAA,IACF;AAEA,eAAW,UAAU,kBAAkB;AACrC,YAAM,aACJ,OAAO,WAAW,WACd,KAAK,QAAQ,QACX,SACA,OACF,OAAO;AACb,YAAM,aAAa,OAAO,WAAW,YAAY,CAAC,KAAK,QAAQ;AAE/D,YAAMG,QAAO,gBAAQ,MAAM,YAAY;AAAA,QACrC,MAAM,aAAa,SAAS;AAAA,MAC9B,CAAC;AAGD,WAAK,eAAeA,OAAM,SAAS;AAEnC,UAAI,KAAK,QAAQ,SAAU,MAAK,sBAAsB;AACtD,UAAI,KAAK,QAAQ,UAAW,MAAK,sBAAsB;AACvD,UAAI,KAAK,QAAQ,UAAW,MAAK,yBAAyB;AAE1D,YAAM,gBAAgBA,MAAK,SAAS;AAAA,QAClC,KAAK,KAAK,QAAQ;AAAA,QAClB,IACE,OAAO,KAAK,QAAQ,cAAc,WAC9B,KAAK,QAAQ,UAAU,KACvB;AAAA,MACR,CAAC;AACD,YAAM,SAAc;AAAA,QAClB,KAAK,cAAc,SAAS;AAAA,QAC5B,MAAM,OAAO,WAAW,WAAW,SAAS,OAAO;AAAA,MACrD;AAEA,UAAI,KAAK,QAAQ,WAAW;AAC1B,eAAO,YAAY,cAAc,KAAK,SAAS;AAAA,MACjD;AAEA,UAAI,KAAK,QAAQ,UAAU;AACzB,eAAO,WAAW,MAAM,KAAK,KAAK,gBAAgB;AAClD,aAAK,iBAAiB,MAAM;AAAA,MAC9B;AAEA,UAAI,KAAK,QAAQ,aAAa;AAC5B,eAAO,cAAc,gBAClB,KAAK,EAAE,OAAO,KAAK,aAAa,CAAC,EACjC,SAAS;AAAA,MACd;AAEA,cAAQ,KAAK,MAAM;AAAA,IACrB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,sBAAsB,eAAgC;AAC5D,WAAO,KAAK,QAAQ,SAAS,UAAU,KAAK,CAAC,iBAAiB;AAC5D,aAAO,OAAO,iBAAiB,WAC3B,iBAAiB,gBACjB,aAAa,KAAK,aAAa;AAAA,IACrC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,sBAAsBH,WAA2B;AACvD,WAAO,KAAK,QAAQ,UAAU,KAAK,CAAC,kBAAkB;AACpD,aAAO,OAAO,kBAAkB,WAC5B,kBAAkBA,YAClB,cAAc,KAAKA,SAAQ;AAAA,IACjC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,qBAAqBA,WAA2B;AACtD,UAAM,eAAe,KAAK,QAAQ,SAAS,SAAS,KAAK,CAAC,iBAAiB;AACzE,aAAO,OAAO,iBAAiB,WAC3B,iBAAiBA,YACjB,aAAa,KAAKA,SAAQ;AAAA,IAChC,CAAC;AACD,UAAMI,mBAAkB,QAAQ,KAAKJ,SAAQ;AAC7C,WAAO,aAAa,SAASA,SAAQ,KAAKI,oBAAmB;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,yBAAyBJ,WAA2B;AAC1D,WAAO,KAAK,QAAQ,SAAS,KAAK;AAAA,MAAK,CAAC,iBACtC,aAAa,KAAKA,SAAQ;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,2BAA2BA,WAA2B;AAC5D,WAAO,KAAK,QAAQ,SAAS,OAAO;AAAA,MAAK,CAAC,iBACxC,aAAa,KAAKA,SAAQ;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BA,MAAa,MACX,aACwB;AACxB,SAAK,UACH,OAAO,gBAAgB,WAEnB,MAAM,WAAW,WAAW,IAC5B;AAAA,MACE,GAAG;AAAA,MACH,GAAG;AAAA,MACH,UAAU,oCAAoB,YAAY,QAAQ;AAAA,IACpD;AACN,UAAM,EAAE,SAAS,KAAK,YAAY,SAAS,IAAI,KAAK;AAEpD,QAAI,KAAK,QAAQ,WAAW;AAC1B,WAAK,mBAAmB,WAAW,SAAS,aAAa,CAAC;AAAA,IAC5D;AAGA,UAAM,oBAAoB,QAAQ;AAAA,MAChC,CAAC,MAAM,OAAO,MAAM;AAAA,IACtB;AAGA,UAAM,kBAAkB,MAAM,KAAK;AAAA,MACjC;AAAA,MACA;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,MACV;AAAA,MACA,wCAAwB,CAAC,GAAU,eAAe;AAAA,IACpD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,2BAAiC;AACtC,SAAK,mBAAmB,aAAa;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKO,wBAA8B;AACnC,eAAW,EAAE,MAAM,KAAK,KAAK,KAAK,QAAQ,UAAU;AAClD,UAAI,CAAC,KAAK,cAAc,IAAI,IAAI,GAAG;AACjC,aAAK,OAAO;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,wBAA8B;AACnC,eAAW,QAAQ,KAAK,QAAQ,WAAW;AACzC,UACE,CAAC,KAAK,eAAe,IAAI,KAAK,MAAM,KACpC,CAAC,KAAK,sBAAsB,KAAK,MAAM,GACvC;AACA,aAAK,OAAO;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiBA,WAAmD;AAC1E,WACGA,UAAS,SAAS,eAAeA,UAAS,aAAcA,UAAS;AAAA,EAEtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,mBACNA,WACA,wBACS;AAET,QAAI,gCAAgBA,SAAQ,KAAK,CAAC,yCAAyBA,SAAQ,GAAG;AACpE,aAAO;AAAA,IACT;AAEA,QAAI,yCAAyBA,SAAQ,GAAG;AACtC,aAAO;AAAA,IACT;AAIA,QAAI,KAAK,QAAQ,SAAS,OAAO,SAAS,GAAG;AAC3C,YAAM,gBAAgBA,UAAS,MAAM,IAAI,KAAK,gBAAgB;AAC9D,UACE,cAAc;AAAA,QACZ,CAAC,iBACC,gBAAgB,KAAK,2BAA2B,YAAY;AAAA,MAChE,GACA;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,QAAI,YAAY;AAEhB,eAAW,gBAAgBA,UAAS,OAAO;AACzC,YAAM,gBAAgB,KAAK,iBAAiB,YAAY;AAIxD,UAAI,iBAAiB,KAAK,yBAAyB,aAAa,GAAG;AACjE,eAAO;AAAA,MACT;AAGA,UACE,kBACC,aAAa,SAAS,aAAa,KAClC,KAAK,qBAAqB,aAAa,IACzC;AACA,oBAAY;AACZ;AAAA,MACF;AAGA,UAAI,iBAAiB,KAAK,sBAAsB,aAAa,GAAG;AAC9D,eAAO;AAAA,MACT;AAEA,cAAQ,aAAa,MAAM;AAAA,QACzB,KAAK;AAIH,sBAAY;AAAA,YACV,GAAG,KAAK,QAAQ;AAAA,YAChB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,EAAE,SAAS,aAAa,SAAS,IAC7B,OACA,iCAAiB,cAAc,sBAAsB;AACzD;AAAA,QACF,KAAK;AACH,sBAAY,6BAAa,cAAc,sBAAsB;AAC7D;AAAA,QACF,KAAK;AACH,sBAAY,kCAAkB,cAAc,sBAAsB;AAClE;AAAA,QACF,KAAK;AACH,sBAAY,2BAAW,cAAc,sBAAsB;AAC3D;AAAA,QACF;AACE;AAAA,MACJ;AAIA,UAAI,CAAC,WAAW;AACd,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,eACLG,OACA,WACM;AACN,IAAAA,MAAK,KAAK,CAAC,SAAS;AAClB,UAAI,KAAK,SAAS,QAAQ;AACxB,eAAO,KAAK,aAAa,MAAM,SAAS;AAAA,MAC1C;AACA,UAAI,KAAK,SAAS,UAAU;AAC1B,eAAO,KAAK,eAAe,IAAI;AAAA,MACjC;AACA,UAAI,KAAK,SAAS,WAAW;AAC3B,YAAI,mCAAmB,MAAM,OAAO,GAAG;AACrC,eAAK,SAAS;AAEd,eAAK,OAAO;AAAA,QACd,WAAW,mCAAmB,MAAM,KAAK,GAAG;AAC1C,eAAK,SAAS;AAEd,eAAK,OAAO;AAAA,QACd;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;",
  "names": ["plugin", "str", "semicolon", "string", "root", "str", "str", "id", "selector", "AtRule", "Root", "string", "Rule", "Root", "AtRule", "colon", "string", "str", "Rule", "parse", "parser", "LazyResult", "Processor", "Root", "Rule", "AtRule", "stringify", "root", "str", "root", "root", "str", "parser", "parse", "LazyResult", "root", "parser", "parse", "plugin", "str", "Root", "Processor", "LazyResult", "plugin", "Root", "LazyResult", "postcss", "Processor", "parse", "AtRule", "Rule", "Root", "str", "hex", "cloneNode", "Node", "Container", "Node", "selector", "id", "Root", "Container", "str", "selector", "Container", "string", "isIdentifier", "Node", "Comment", "Node", "ID", "Node", "Node", "String", "Node", "Container", "selector", "Node", "Node", "list", "list", "Parser", "Root", "selector", "unescaped", "space", "Comment", "String", "word", "ID", "Processor", "parser", "Parser", "root", "string", "combinator", "comment", "combinator", "comment", "Comment", "ID", "Root", "String", "Processor", "word", "id", "tag", "str", "selector", "word", "node", "root", "isPseudoElement"]
}
