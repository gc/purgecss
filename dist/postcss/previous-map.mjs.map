{
  "version": 3,
  "sources": ["../../src/postcss/previous-map.js"],
  "sourcesContent": ["function fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str)\n  }\n}\n\nexport class PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    const prev = opts.map ? opts.map.prev : undefined\n    const text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (text) this.text = text\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  decodeInline(text) {\n    const baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    const baseUri = /^data:application\\/json;base64,/\n    const charsetUri = /^data:application\\/json;charset=utf-?8,/\n    const uri = /^data:application\\/json,/\n\n    const uriMatch = text.match(charsetUri) || text.match(uri)\n    if (uriMatch) {\n      return decodeURIComponent(text.substr(uriMatch[0].length))\n    }\n\n    const baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri)\n    if (baseUriMatch) {\n      return fromBase64(text.substr(baseUriMatch[0].length))\n    }\n\n    const encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n\n  loadAnnotation(css) {\n    const comments = css.match(/\\/\\*\\s*# sourceMappingURL=/g)\n    if (!comments) return\n\n    // sourceMappingURLs from comments, strings, etc.\n    const start = css.lastIndexOf(comments.pop())\n    const end = css.indexOf('*/', start)\n\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\n    }\n  }\n\n  loadFile(path) {\n    throw new Error(\"Shouldnt be used\");\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        const prevPath = prev(file)\n        if (prevPath) {\n          const map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      const map = this.annotation\n      return this.loadFile(map)\n    }\n  }\n\n  startWith(string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  withContent() {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n}"],
  "mappings": "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",
  "names": []
}
